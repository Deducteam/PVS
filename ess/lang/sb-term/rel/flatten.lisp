;;; -*- Mode: Lisp;  Package: syntax-box; Log: sb-changes.log  -*-
;;; Sccs Id @(#)flatten.lisp	1.3 9/21/89
;;; ******************************************************************* ;;;
;;;          (c) Copyright 1989 by Carnegie Mellon University.          ;;;
;;;                        All rights reserved.                         ;;;
;;;         This code was written as part of the Ergo project.          ;;;
;;;  If you want to use this code or any Ergo software, please contact  ;;;
;;;			Frank Pfenning (fp@cs.cmu.edu)			;;;
;;; ******************************************************************* ;;;


;;; ERGO Project, Syntax Box.

;;; Anne Rogers 
;;; Revised, Scott Dietzen, Mon Oct 13 16:05:43 1986


;;;;    Basic Function: Flatten Patterns

(in-package 'syntax-box)  (use-package :ergolisp)




; WHAT IS FLATTENING:
;  Flattening is taking a production from a nonterminal defintion and
;  construting a new set of patterns based on that production.  Each
;  new production has either a keyword, a lexical terminal, a nonterminal, or
;  a juxtaposition
;  in the first two positions.  All of the new productions taken together generate
;  the same strings as the original production did.   We need atomic symbols in
;  the first two positions for two reasons.  First, it makes building the look
;  ahead sets easier because we have fewer cases to test.  And second,
;  we need a list of the productions that have recursive first
;  symbols to generate correct code for them.
;
; FLATTENING BY PARTS:
;  Flattening is an inductive process.  The base cases are
;    singleton keyword, noterminal, external nonterminal, and juxtaposition
;    patterns.  Nothing needs to be done with them.
;
;  Note: A# -- is an A* that has been generated by flatten.
;
;  flatten( [A] ) --> epsilon and flatten(A)
;
;  flatten( {A | B | C} ) --> flatten(A) and flatten(B) and flatten(C)
;
;  flatten( {A}* ) --> epsilon and flatten( {A A#} )
;  
;  flatten( {A}+ ) --> flatten( {A A#} )
;
;  flatten( {A ** k} ) --> epsilon and flatten( {A {k A}#} )
;
;  flatten( {A ++ k} --> flatten( {A {k A}#} )
;
;  flatten( {A B} ) --> flatten(A) and tack B onto the end of each
;                       of the resulting patterns (if the new pattern
;			is not a sequence then just make one from the two
;			pieces).  Check to make sure that for each
;			of the resulting sequences that both
;                       the first and the second symbol are atomic.
;			If the first symbol is not atomic then
;			reflatten the whole pattern (these kinds of new
;			patterns will occur when the first grammar item in
;			the original pattern goes to epsilon.)  If the
;			second symbol is not atomic then call flatten on
;			the second half of the pattern and combine the front
;			with the results.


;  It is important to get the abstract syntax moved to the right places.
;  When we are flattening a construct out of existence we have to make
;  sure that the new productions set all the right flags and call all the
;  right constructors.  Also, when we pull a guy out of a looping
;  construct we must make sure that the partial results get put in the
;  right slot.



; flatten-alternative:  
;         Given a pattern signal an error if it can be empty (ie. it is an
;         opt, star, or doublestar).  If not call flatten.

(defun flatten-alternative (pat)
  (let ((results nil))

    (case (get-kind pat)
	 
      ((seq plus doubleplus)
          ; flatten the pattern and check all the results.
       (do ((new-alts (flatten-pattern pat) (cdr new-alts))
	    (temp-result nil nil))
	   ((null new-alts))
			
  	     ; if the first two guys in the pattern
	     ; are not atomic then check will return
	     ; some new patterns.  Add these to the end
	     ; of the list.  Ow. save the pattern.
	 (setq temp-result (check-alt (car new-alts)))
	 (if temp-result
	     (setq new-alts (append new-alts temp-result))
	     (push (car new-alts) results))))

          ; Epsilon productions are illegal.
      ((opt star doublestar) (my-error 1))
	  
	      ; base case - no need to flatten.
      ((ukeyword nonterminal ext-nonterminal jux)
       (push pat results))

      (t (my-error 15)))

    results))
			
						
; Check-alt: Check to make sure that the pattern is finished being flattened.
; Both the first son and the second son must be atomic.  If the first son is
; not atomic then call flatten on the whole guy.  If the second son (or if the
; second son is sequence then the first element of the second son) is not
; atomic then flatten it and build a set of sequence patterns from the first
; son and the results of the flatten. The result of check-alt is a list of new
; patterns.

(defun check-alt (pat)
  (let ((first-son (if (not (atomic pat)) (get-first-son pat) nil)))

    (cond ((atomic pat) nil)

	      ; If we have a sequence and the first son is a jux, then
	      ; we are ok.  The jux buys us two flattened symbols.
	  ((eq (get-kind first-son) 'jux) nil)

	  ((atomic first-son)
	   (let* ((second-son (get-second-son pat))

		     ; if the second son is a sequence then we need the
		     ; first son of the sequence.
		  (second-element 
		   (if (member (get-kind second-son) '(seq internal-seq))
		       (car (get-sons second-son))
		       second-son)))

	         ; If the second son is not atomic then call flatten
	         ; pattern on the second son.  We know that the
	         ; first son of the original pattern was atomic
	         ; so we can throw a  list of new patterns together
	         ; by combining the new results and first son into a
	         ; set of new sequences.
	     (if (not (atomic second-element))
		 (let ((pat-result (get-result pat))
		       (pat-as (get-as pat)))
		   (mapcar
		    #'(lambda (x) (make-pattern :kind 'seq
						:slot pat-result
						:augment pat-as
						:sons (list first-son x)))
		    (flatten-pattern second-son))))))

	      ; if the first son is not atomic flatten again.
	  (t (flatten-pattern pat)))))
			       


; Flatten-pattern: Pat -> Pat*
;  see general note.  The result of flattening is a list of patterns.

(defun flatten-pattern (pat)
  (let ((pat-as (get-as pat)) (pat-result (get-result pat)))
	 
    (case (get-kind pat)
	   
          ; base cases -- just return
      ((nonterminal ext-nonterminal ukeyword jux)
       (list pat))

          ; {A | B | C} --> flatten(A) and flatten(B) and flatten(C).
          ; we have to add a piece of abstract syntax that sets the
          ; alternation flag to the right value.  Also, we have to
          ; call each alternative's abstract syntax.
      (alt 
       (do ((branches (get-sons pat) (cdr branches))
	    (count 0 (+ count 1)) (result))
	   ((null branches) result)
			 
	 (setq result
	       (append result (add-as-to-results
			       (flatten-pattern (car branches))
			       count
			       pat-result
			       pat-as)))))


          ; [A] --> epsilon and flatten(A)
          ; again set the right flags and call the optional abstract
          ; syntax.
      (opt
       (cons (make-null-pattern pat-result pat-as)
	     (add-as-to-results (flatten-pattern (get-first-son pat))
				1
				pat-result
				pat-as)))
	       
          ; A* --> epsilon and flatten( {A A#} )
          ; set star flag, drag along syntax and remember to cons
          ; the partial result onto the star's final slot.
      ((star gen-star)
       (if pat-as
	   (cons (make-pattern :kind 'just-as :augment pat-as)
		 (combine-first-list
		  (no-flag-add-as-to-results
		   (flatten-pattern (get-first-son pat))
		   (piece-of-loop (get-first-son pat) pat-result))
		  (build-star pat)))

	       ; if the star does not have any abstract syntax then we do
	       ; not have to add a null pattern.
	   (combine-first-list
	    (no-flag-add-as-to-results
	     (flatten-pattern (get-first-son pat))
	     (piece-of-loop (get-first-son pat) pat-result))
	    (build-star pat))))

          ; A+ --> flatten( {A A*} )
          ; piece of loop and bring along the syntax.	        
      (plus
       (combine-first-list
	(no-flag-add-as-to-results
	 (flatten-pattern (get-first-son pat))
	 (piece-of-loop (get-first-son pat) pat-result))
	(build-star pat)))
	       

          ; A ** k --> epsilon and flatten( {A {k A}# )
          ; flags, piece of loop and bring along the abstract syntax.
      (doublestar
       (let* ((subpat (get-subpat pat))
	      (sep (get-separator pat))
	      (fpats (flatten-pattern subpat))
	      (second (make-pattern :kind 'gen-star
				    :augment pat-as
				    :slot pat-result
				    :sons (list (make-pattern :kind 'seq
						    :slot (get-result subpat)
						    :sons (list sep subpat))))))

	 (if pat-as
	     (cons (make-pattern :kind 'just-as :augment pat-as)
		   (combine-first-list
		    (no-flag-add-as-to-results
		     fpats
		     (piece-of-loop subpat pat-result))
		    second))

	         ; if the doublestar does not have any abstract syntax then we do
	         ; not need to add a null patter
	     (combine-first-list
	      (no-flag-add-as-to-results
	       fpats
	       (piece-of-loop subpat pat-result))
	      second))))

          ; A ++ k --> flatten( {A {k A}* )
          ; same as doublestar except no flags.
      (doubleplus
       (let* ((subpat (get-subpat pat))
	      (sep (get-separator pat))
	      (fpats (flatten-pattern subpat))
	      (second (make-pattern :kind 'gen-star
				    :augment pat-as
				    :slot pat-result
				    :sons (list (make-pattern :kind 'seq
						  :slot (get-result subpat)
						  :sons (list sep subpat))))))

	 (combine-first-list
	  (no-flag-add-as-to-results
	   fpats
	   (piece-of-loop subpat pat-result))
	  second)))

      ((seq internal-seq)
       
       (let ((first-son (get-first-son pat))
	     (rest (get-second-son pat)))
		     
	 (case (get-kind first-son)

	       ; keyword, nonterminal, ext-nonterminal, or jux
	       ;  -- already flattened.
	   ((nonterminal ukeyword ext-nonterminal jux)
	    (list pat))
	          
	       ; if it is just abstract syntax then tack it
	       ; onto the second son and throw away the first.
	   (just-as
	    (tack-seq-as-on first-son rest pat-as))

	       ; if the first son can go to epsilon then we need to handle
	       ; the null case.  If the first son has abstract syntax that
	       ; needs to be handled then the result from flattening it
	       ; will have a 'just-as pattern at the head of the list.
	       ; We need to add this to the back of the original seq. to
	       ; form the first new pattern for the seq.  If the first son
	       ; does not have any abstract syntax attached to it then we just
	       ; add rest, the back of the seq, to the result list.
	   ((opt star doublestar gen-star)
	    (let ((temp (flatten-pattern first-son)))
	      (if (eq (get-kind (car temp)) 'just-as)
		  (cons (tack-seq-as-on (car temp) rest pat-as)
			(seq-combine-first-list (cdr temp) rest pat-as))
		  
		  (cons (tack-seq-as-on () rest pat-as)
			(seq-combine-first-list temp rest pat-as)))))

	   
	       ; flatten the first son and combine the back
	       ; end with the results.
	   ((alt plus doubleplus seq internal-seq)
	    (seq-combine-first-list (flatten-pattern first-son) rest pat-as))
	   
	   (t (my-error 18)))))

          ; fall out the end.
      (t (my-error 18)))))



; Pattern and Abstract Syntax generators.

; Make-null-pattern: Number x Number x Augment -> Pattern
;  Make an epsilon pattern.  Set the flag in result to the correct value and
;  call the abstract syntax if there is any.

(defun make-null-pattern (result-slot pat-as)
  (if pat-as
      (make-pattern :kind 'just-as
		    :augment (make-and (list (known-branch 0 result-slot) pat-as)))

      (make-pattern :kind 'just-as
		    :augment (known-branch 0 result-slot))))

	      
; Piece-of-loop: Number x Number -> Augment Pattern
;  Build abstract syntax that moves a the partial result of a son of a loop
;  to the loop's final result.

(defun piece-of-loop (son final)
  (let ((partial (if (eq (get-kind son) 'alt)
		     (+ (get-result son) 1)
		     (get-result son))))
    (make-augment :kind 'piece-of-loop 
	      :args (list partial final))))

; Known-branch: Number x Number -> Augment pattern
;  Set the flag in slot to the correct value, number.

(defun known-branch (number slot)
  (make-augment :kind 'known-branch
	    :args (list number slot)))


; Make-and: Augment pattern* -> augment pattern
;  If we have more than one pattern in as-list then we need to make
;  an augment pattern AND.  

(defun make-and (as-list)
      ; get rid of extra nulls.
  (delete-if #'null as-list)
  (if (> (length as-list) 1)
      (make-augment :kind 'and :args as-list)
      (car as-list)))

				  
	       
; Build-star: Pattern -> Pattern
;  Take a star or plus pattern and build an identical gen-star pattern
;

(defun build-star (pat)
  (make-pattern :kind 'gen-star
		:slot (get-result pat)
		:augment (get-as pat)
		:sons (get-sons pat)))
		 



;  Add as to the right places.

; Add-as-to-results: Pattern* x Number x Number x Augment -> Pattern*
;  Add as, the abstract syntax, to each of the patterns in pat-list
;  also set the flag in result-slot to have the value branch-number.
;
(defun add-as-to-results (pat-list branch-number result-slot as)

        ; For each pattern
    (do ((patterns pat-list (cdr patterns)) (temp-as nil nil) (result))
	((null patterns) result)
	     
         ; do we have abstract syntax?  if so save it.
      (if as (push as temp-as))

         ; does the pattern have any abstract syntax
      (if (get-as (car patterns)) (push (get-as (car patterns)) temp-as))

         ; add the flag setting code
      (push (known-branch branch-number result-slot) temp-as)
	     
      (push (make-pattern :kind (get-kind (car patterns))
			  :slot (get-result (car patterns))
			  :augment (make-and temp-as)
			  :sons (get-sons (car patterns)))
	    result)))


; No-flag-add-as-to-results: Pat* x Augment -> Pattern*
;  Same as add-as-to-results but with out the flag.

(defun no-flag-add-as-to-results (pat-list as)
	 
        ; for each pattern
    (do ((patterns pat-list (cdr patterns)) (temp-as nil nil) (result))
	((null patterns) result)
	     
          ; does we have abstract syntax?  if so save it.
      (if as (push as temp-as))

          ; does the pattern have abstract syntax?
      (if (get-as (car patterns)) (push (get-as (car patterns)) temp-as))
	     
      (push (make-pattern :kind (get-kind (car patterns))
			  :slot (get-result (car patterns))
			  :augment (make-and temp-as)
			  :sons (get-sons (car patterns)))
	    result)))


; Tack-seq-as-on: Pattern x Pattern x AUGMENT -> Pattern
;  Take the abstract syntax out of the just-as pattern and add it to
;  pat.

(defun tack-seq-as-on (just-as-pat pat seq-as)
  (let (temp-as)
	 
        ; does the sequence have abstract syntax?  if so save it.
    (if seq-as (push seq-as temp-as))

        ; does the pattern have abstract syntax?
    (if (get-as pat) (push (get-as pat) temp-as))

    (if just-as-pat (push (get-as just-as-pat) temp-as))
	 
    (make-pattern :kind (get-kind pat)
		  :slot (get-result pat)
		  :augment (make-and temp-as)
		  :sons (get-sons pat))))



; Combine-first-list
;
;
; Combine-first-list: Pattern* x Pattern -> Pattern*
;   For each guy in first-list build a new sequence with second.

(defun combine-first-list (first-list second)
    (mapcar #'(lambda (x) (combine x second)) first-list))




; Seq-Combine-first-list:
;
;    for each guy in first-list build a new sequence with it and second.
;    same as combine-first-list except that the there is an extra piece of
;    abstract syntax that can be added on.

(defun seq-combine-first-list (first-list second seq-as)

     (do ((guys first-list (cdr guys)) (temp) (result))
	 ((null guys) result)

       (setq temp (combine (car guys) second))
       
          ; if the new sequence already has abstract syntax then we need to
          ; use the abstract syntax pattern 'and to combine the new sequence
          ; as and seq-as.
       (if (get-as temp) 
	   (set-pattern-augment temp
				(make-and (list (get-as temp) seq-as)))
	   (set-pattern-augment temp
				seq-as))

       (push temp result)))


; Combine: Pattern x Pattern -> Pattern
;  Make a sequence from the two pieces.  Find the end of the
;  first sequence and then tack back into the structure at that
;  point.

(defun combine (front back &optional (front-seq-as nil))
  (let ((front-as (get-as front)))

    (cond ((eq (get-kind front) 'seq)

	       ; if the front is a sequence then we need to save its abstract 
	       ; syntax until we find the end of the sequence.  Once we find the
	       ; end we need to tack the as for the whole seq onto the end
	       ; pattern.  This assures that the asbtract syntax for the front
	       ; will get done before the back is handled.
	   (cond ((and front-as front-seq-as)
		  (setq front-seq-as (make-and (list front-as front-seq-as))))

		 (front-as
		  (setq front-seq-as (get-as front))))

	   (make-pattern :kind 'seq
			 :slot (get-result front)
			 :sons (list (car (get-sons front))
				     (combine (cadr (get-sons front)) back
					      front-seq-as))))

	      ; Internal sequence is the same as sequence.
	  ((eq (get-kind front) 'internal-seq)
	   (cond ((and front-as front-seq-as)
		  (setq front-seq-as (make-and (list front-as front-seq-as))))
		 
		 (front-as
		  (setq front-seq-as front-as)))

	   (make-pattern :kind 'seq
			 :slot (get-result front)
			 :sons (list (car (get-sons front))
				     (combine (cadr (get-sons front)) back
					      front-seq-as))))
	  (t (if front-seq-as
		 (setq front
		       (car (no-flag-add-as-to-results
			     (list front) front-seq-as))))

	     (make-pattern :kind 'seq :sons (list front back))))))

