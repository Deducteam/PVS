(wf_FODL_Language
 (no_metavariable_TCC1 0
  (no_metavariable_TCC1-4 "" 3712869947
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (rewrite "every_conjunct2")
        (("" (hide -1 -2 2)
          (("" (replace -1 :hide? t)
            (("" (rewrite "every_nth")
              (("" (grind)
                ((""
                  (lemma
                   "max_map[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate,
                        Function_, sigFunction_]]")
                  (("" (expand "restrict")
                    ((""
                      (name-replace "rn"
                       "reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,
                   LAMBDA (v: Variable): 0,
                   LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0,
                   LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (p: Predicate, l: list[nat]): 1 + max(l),
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n,
                   LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)"
                       :hide? t)
                      ((""
                        (inst -1 "LAMBDA (s:
                         Term_
                             [Constant, Metavariable, Variable,
                              Predicate, sigPredicate, Function_,
                              sigFunction_]):
                 rn(s)" "list_var!1" "i!1")
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]"))
  (no_metavariable_TCC1-3 "" 3387092913
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (rewrite "every_conjunct2")
        (("" (hide -1 -2 2)
          (("" (replace -1 :hide? t)
            (("" (rewrite "every_nth")
              (("" (grind)
                ((""
                  (lemma
                   "max_map[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate,
                      Function_, sigFunction_]]")
                  (("" (inst?)
                    (("" (inst -1 "i!1")
                      (("" (assert)
                        ((""
                          (name-replace "rn"
                           "reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,
                 LAMBDA (v: Variable): 0,
                 LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0,
                 LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (p: Predicate, l: list[nat]): 1 + max(l),
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n,
                 LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0,
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n,
                 LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)"
                           :hide? t)
                          (("" (expand "restrict")
                            ((""
                              (name-replace "rnn"
                               "rn(nth(list_var!1, i!1))")
                              (("" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (max_map formula-decl nil list_max_map nil)
    (max def-decl "nat" list_max nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]"))
  (no_metavariable_TCC1-2 "" 3385275494
   ("" (skosimp)
    ((""
      (case "FORALL (l: list[FODL_Language]): every(LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(l)))(l)")
      (("1" (replace -2 :hide? t)
        (("1" (expand "complexity" 1 2)
          (("1" (expand "reduce_nat")
            (("1" (expand "complexity" -1 2)
              (("1"
                (case-replace "(LAMBDA (l: FODL_Language):
                              reduce_nat(LAMBDA (c: Constant): 0,
                                         LAMBDA (m: Metavariable): 0,
                                         LAMBDA (v: Variable): 0,
                                         LAMBDA
                                         (f: Function_, l: list[nat]):
                                         1 + max(l),
                                         0,
                                         0,
                                         LAMBDA (n: nat): 1 + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA
                                         (p: Predicate, l: list[nat]):
                                         1 + max(l),
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat): 1 + n,
                                         LAMBDA
                                         (pre_post: [nat, nat]):
                                         1 + pre_post`1 + pre_post`2,
                                         0,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat): 1 + n)
                                        (l)) = (reduce_nat(LAMBDA (c: Constant): 0,
                                       LAMBDA (m: Metavariable): 0,
                                       LAMBDA (v: Variable): 0,
                                       LAMBDA (f: Function_, l: list[nat]):
                                         1 + max(l),
                                       0, 0, LAMBDA (n: nat): 1 + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (p: Predicate, l: list[nat]):
                                         1 + max(l),
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat): 1 + n,
                                       LAMBDA (pre_post: [nat, nat]):
                                         1 + pre_post`1 + pre_post`2,
                                       0, LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat): 1 + n))")
                (("1" (inst?) nil nil)
                 ("2" (hide-all-but 1)
                  (("2" (apply-extensionality) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide-all-but 1)
        (("2" (induct "l")
          (("1" (grind) nil nil)
           ("2" (skosimp)
            (("2" (expand "every" +)
              (("2" (assert)
                (("2" (expand "map" 1 2)
                  (("2" (expand "max" 1 2)
                    (("2" (split)
                      (("1" (expand "max" +)
                        (("1" (expand "map" +)
                          (("1" (expand "max" 1 1)
                            (("1" (assert)
                              (("1"
                                (lift-if)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2"
                        (case "FORALL (P, Q: PRED[FODL_Language]): (FORALL (x: FODL_Language): P(x) => Q(x)) => FORALL (l: list[FODL_Language]): every(P)(l) => every(Q)(l)")
                        (("1"
                          (inst -1
                           "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons2_var!1))"
                           "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons(cons1_var!1, cons2_var!1)))")
                          (("1" (prop)
                            (("1" (inst -1 "cons2_var!1")
                              (("1"
                                (prop)
                                (("1"
                                  (expand "map" -1)
                                  (("1"
                                    (expand "max" -1)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (skosimp)
                                (("2"
                                  (expand "map" 1)
                                  (("2"
                                    (expand "max" 1)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2" (skosimp)
                            (("2" (induct "l")
                              (("1"
                                (expand "every")
                                (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (skosimp*)
                                (("2"
                                  (expand "every" 1)
                                  (("2"
                                    (prop)
                                    (("1"
                                      (inst -3 "cons1_var!2")
                                      (("1"
                                        (prop)
                                        (("1"
                                          (expand "every" -2)
                                          (("1" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "every" -1)
                                      (("2" (prop) nil nil))
                                      nil)
                                     ("3"
                                      (expand "every" -1)
                                      (("3" (prop) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]"))
  (no_metavariable_TCC1-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -3)
        (("" (expand "complexity" 1 2)
          (("" (expand "reduce_nat")
            ((""
              (case "FORALL (l: list[FODL_Language]): every(LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(l)))(l)")
              (("1" (inst -1 "list_var!1")
                (("1" (expand "complexity" -1 2)
                  (("1"
                    (case-replace "(LAMBDA (l: FODL_Language):
                          reduce_nat(LAMBDA (c: Constant): 0,
                                     LAMBDA (m: Metavariable): 0,
                                     LAMBDA (v: Variable): 0,
                                     LAMBDA
                                     (f: Function_, l: list[nat]):
                                     1 + max(l),
                                     0,
                                     0,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA
                                     (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA
                                     (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                     0,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n)
                                    (l)) = (reduce_nat(LAMBDA (c: Constant): 0,
                                   LAMBDA (m: Metavariable): 0,
                                   LAMBDA (v: Variable): 0,
                                   LAMBDA (f: Function_, l: list[nat]):
                                     1 + max(l),
                                   0, 0, LAMBDA (n: nat): 1 + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat): 1 + n,
                                   LAMBDA (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                   0, LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat): 1 + n))")
                    (("1" (hide-all-but 1)
                      (("1" (apply-extensionality) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (induct "l")
                  (("1" (grind) nil nil)
                   ("2" (skosimp)
                    (("2" (expand "every" +)
                      (("2" (assert)
                        (("2" (expand "map" 1 2)
                          (("2" (expand "max" 1 2)
                            (("2" (split)
                              (("1"
                                (expand "max" +)
                                (("1"
                                  (expand "map" +)
                                  (("1"
                                    (expand "max" 1 1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lift-if)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (case
                                 "FORALL (P, Q: PRED[FODL_Language]): (FORALL (x: FODL_Language): P(x) => Q(x)) => FORALL (l: list[FODL_Language]): every(P)(l) => every(Q)(l)")
                                (("1"
                                  (inst
                                   -1
                                   "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons2_var!1))"
                                   "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons(cons1_var!1, cons2_var!1)))")
                                  (("1"
                                    (prop)
                                    (("1"
                                      (inst -1 "cons2_var!1")
                                      (("1"
                                        (prop)
                                        (("1"
                                          (expand "map" -1)
                                          (("1"
                                            (expand "max" -1)
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide-all-but 1)
                                      (("2"
                                        (skosimp)
                                        (("2"
                                          (expand "map" 1)
                                          (("2"
                                            (expand "max" 1)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (skosimp)
                                    (("2"
                                      (induct "l")
                                      (("1"
                                        (expand "every")
                                        (("1" (propax) nil nil))
                                        nil)
                                       ("2"
                                        (skosimp*)
                                        (("2"
                                          (expand "every" 1)
                                          (("2"
                                            (prop)
                                            (("1"
                                              (inst -3 "cons1_var!2")
                                              (("1"
                                                (prop)
                                                (("1"
                                                  (expand "every" -2)
                                                  (("1"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "every" -1)
                                              (("2" (prop) nil nil))
                                              nil)
                                             ("3"
                                              (expand "every" -1)
                                              (("3" (prop) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max def-decl "nat" list_max nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (list_induction formula-decl nil list_adt nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]")))
 (no_metavariable_TCC2 0
  (no_metavariable_TCC2-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f_var)" "nil")))
 (no_metavariable_TCC3 0
  (no_metavariable_TCC3-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f1_var)"
    "nil")))
 (no_metavariable_TCC4 0
  (no_metavariable_TCC4-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f2_var)"
    "nil")))
 (no_metavariable_TCC5 0
  (no_metavariable_TCC5-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f1_var)"
    "nil")))
 (no_metavariable_TCC6 0
  (no_metavariable_TCC6-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f2_var)"
    "nil")))
 (no_metavariable_TCC7 0
  (no_metavariable_TCC7-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f1_var)"
    "nil")))
 (no_metavariable_TCC8 0
  (no_metavariable_TCC8-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f2_var)"
    "nil")))
 (no_metavariable_TCC9 0
  (no_metavariable_TCC9-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f1_var)"
    "nil")))
 (no_metavariable_TCC10 0
  (no_metavariable_TCC10-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f2_var)"
    "nil")))
 (no_metavariable_TCC11 0
  (no_metavariable_TCC11-5 "" 3712865779
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (rewrite "every_conjunct2")
        (("" (hide -1 -2 2)
          (("" (replace -1 :hide? t)
            (("" (rewrite "every_nth")
              (("" (grind)
                ((""
                  (lemma
                   "max_map[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate,
                          Function_, sigFunction_]]")
                  (("" (expand "restrict")
                    ((""
                      (name-replace "rn"
                       "reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,
                     LAMBDA (v: Variable): 0,
                     LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0,
                     LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (p: Predicate, l: list[nat]): 1 + max(l),
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n,
                     LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0,
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n,
                     LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)"
                       :hide? t)
                      ((""
                        (inst -1 "LAMBDA (s:
                         Term_
                             [Constant, Metavariable, Variable,
                              Predicate, sigPredicate, Function_,
                              sigFunction_]):
                 rn(s)" "list_var!1" "i!1")
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (max_map formula-decl nil list_max_map nil)
    (max def-decl "nat" list_max nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]"))
  (no_metavariable_TCC11-4 "" 3594666213
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (rewrite "every_conjunct2")
        (("" (hide -1 -2 2)
          (("" (replace -1 :hide? t)
            (("" (rewrite "every_nth")
              (("" (grind)
                ((""
                  (lemma
                   "max_map[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate,
                        Function_, sigFunction_]]")
                  (("" (inst?)
                    (("" (inst -1 "i!1")
                      (("" (assert)
                        ((""
                          (name-replace "rn"
                           "reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,
                   LAMBDA (v: Variable): 0,
                   LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0,
                   LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (p: Predicate, l: list[nat]): 1 + max(l),
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n,
                   LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)"
                           :hide? t)
                          (("" (expand "restrict")
                            ((""
                              (name-replace "rnn"
                               "rn(nth(list_var!1, i!1))")
                              (("" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (max_map formula-decl nil list_max_map nil)
    (max def-decl "nat" list_max nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]"))
  (no_metavariable_TCC11-3 "" 3387093783 ("" (grind) nil nil)
   ((every_nth formula-decl nil list_props nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (max_map formula-decl nil list_max_map nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max def-decl "nat" list_max nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]"))
  (no_metavariable_TCC11-2 "" 3385275733
   ("" (skosimp*)
    (("" (replace -1)
      (("" (hide -1)
        (("" (expand "complexity" 1 2)
          (("" (expand "reduce_nat")
            ((""
              (case "FORALL (l: list[FODL_Language]): every(LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(l)))(l)")
              (("1" (inst -1 "list_var!1")
                (("1" (expand "complexity" -1 2)
                  (("1"
                    (case-replace "(LAMBDA (l: FODL_Language):
                              reduce_nat(LAMBDA (c: Constant): 0,
                                         LAMBDA (m: Metavariable): 0,
                                         LAMBDA (v: Variable): 0,
                                         LAMBDA
                                         (f: Function_, l: list[nat]):
                                         1 + max(l),
                                         0,
                                         0,
                                         LAMBDA (n: nat): 1 + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA
                                         (p: Predicate, l: list[nat]):
                                         1 + max(l),
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat): 1 + n,
                                         LAMBDA
                                         (pre_post: [nat, nat]):
                                         1 + pre_post`1 + pre_post`2,
                                         0,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat, m: nat): 1 + m + n,
                                         LAMBDA (n: nat): 1 + n)
                                        (l)) = (reduce_nat(LAMBDA (c: Constant): 0,
                                       LAMBDA (m: Metavariable): 0,
                                       LAMBDA (v: Variable): 0,
                                       LAMBDA (f: Function_, l: list[nat]):
                                         1 + max(l),
                                       0, 0, LAMBDA (n: nat): 1 + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (p: Predicate, l: list[nat]):
                                         1 + max(l),
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat): 1 + n,
                                       LAMBDA (pre_post: [nat, nat]):
                                         1 + pre_post`1 + pre_post`2,
                                       0, LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat): 1 + n))")
                    (("1" (hide-all-but 1)
                      (("1" (apply-extensionality) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (induct "l")
                  (("1" (expand "every") (("1" (propax) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (expand "every" 1)
                      (("2" (prop)
                        (("1" (expand "map" 1)
                          (("1" (expand "max" 1)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2"
                          (case "FORALL (P, Q: PRED[FODL_Language]): (FORALL (x: FODL_Language): P(x) => Q(x)) => FORALL (l: list[FODL_Language]): every(P)(l) => every(Q)(l)")
                          (("1"
                            (inst -1
                             "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons2_var!1))"
                             "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons(cons1_var!1, cons2_var!1)))")
                            (("1" (prop)
                              (("1"
                                (inst -1 "cons2_var!1")
                                (("1" (prop) nil nil))
                                nil)
                               ("2"
                                (hide-all-but 1)
                                (("2"
                                  (skosimp*)
                                  (("2"
                                    (expand "map" 1)
                                    (("2"
                                      (expand "max" 1)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (skosimp)
                              (("2"
                                (induct "l")
                                (("1"
                                  (expand "every" 1)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2"
                                  (skosimp*)
                                  (("2"
                                    (expand "every" 1)
                                    (("2"
                                      (prop)
                                      (("1"
                                        (expand "every" -2)
                                        (("1"
                                          (prop)
                                          (("1"
                                            (inst -4 "cons1_var!2")
                                            (("1" (prop) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "every" -1)
                                        (("2" (prop) nil nil))
                                        nil)
                                       ("3"
                                        (expand "every" -1)
                                        (("3" (prop) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]"))
  (no_metavariable_TCC11-1 nil 3385274577
   ("" (skosimp*)
    (("" (replace -1)
      (("" (hide -1)
        (("" (expand "complexity" 1 2)
          (("" (expand "reduce_nat")
            ((""
              (case "FORALL (l: list[FODL_Language]): every(LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(l)))(l)")
              (("1" (inst -1 "list_var!1")
                (("1" (expand "complexity" -1 2)
                  (("1"
                    (case-replace "(LAMBDA (l: FODL_Language):
                          reduce_nat(LAMBDA (c: Constant): 0,
                                     LAMBDA (m: Metavariable): 0,
                                     LAMBDA (v: Variable): 0,
                                     LAMBDA
                                     (f: Function_, l: list[nat]):
                                     1 + max(l),
                                     0,
                                     0,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA
                                     (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA
                                     (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                     0,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n)
                                    (l)) = (reduce_nat(LAMBDA (c: Constant): 0,
                                   LAMBDA (m: Metavariable): 0,
                                   LAMBDA (v: Variable): 0,
                                   LAMBDA (f: Function_, l: list[nat]):
                                     1 + max(l),
                                   0, 0, LAMBDA (n: nat): 1 + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat): 1 + n,
                                   LAMBDA (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                   0, LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat): 1 + n))")
                    (("1" (hide-all-but 1)
                      (("1" (apply-extensionality) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (induct "l")
                  (("1" (expand "every") (("1" (propax) nil nil)) nil)
                   ("2" (skosimp*)
                    (("2" (expand "every" 1)
                      (("2" (prop)
                        (("1" (expand "map" 1)
                          (("1" (expand "max" 1)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2"
                          (case "FORALL (P, Q: PRED[FODL_Language]): (FORALL (x: FODL_Language): P(x) => Q(x)) => FORALL (l: list[FODL_Language]): every(P)(l) => every(Q)(l)")
                          (("1"
                            (inst -1
                             "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons2_var!1))"
                             "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons(cons1_var!1, cons2_var!1)))")
                            (("1" (prop)
                              (("1"
                                (inst -1 "cons2_var!1")
                                (("1" (prop) nil nil))
                                nil)
                               ("2"
                                (hide-all-but 1)
                                (("2"
                                  (skosimp*)
                                  (("2"
                                    (expand "map" 1)
                                    (("2"
                                      (expand "max" 1)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (skosimp)
                              (("2"
                                (induct "l")
                                (("1"
                                  (expand "every" 1)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2"
                                  (skosimp*)
                                  (("2"
                                    (expand "every" 1)
                                    (("2"
                                      (prop)
                                      (("1"
                                        (expand "every" -2)
                                        (("1"
                                          (prop)
                                          (("1"
                                            (inst -4 "cons1_var!2")
                                            (("1" (prop) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "every" -1)
                                        (("2" (prop) nil nil))
                                        nil)
                                       ("3"
                                        (expand "every" -1)
                                        (("3" (prop) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (max def-decl "nat" list_max nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil))
   nil
   (no_metavariable subtype "wf_FODL_Language.list_var"
    "list[{x: Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(x) < complexity(l)}]")))
 (no_metavariable_TCC12 0
  (no_metavariable_TCC12-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.t0_var)"
    "nil")))
 (no_metavariable_TCC13 0
  (no_metavariable_TCC13-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.t1_var)"
    "nil")))
 (no_metavariable_TCC14 0
  (no_metavariable_TCC14-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f_var)" "nil")))
 (no_metavariable_TCC15 0
  (no_metavariable_TCC15-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f_var)" "nil")))
 (no_metavariable_TCC16 0
  (no_metavariable_TCC16-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.P_var)" "nil")))
 (no_metavariable_TCC17 0
  (no_metavariable_TCC17-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.P_var)" "nil")))
 (no_metavariable_TCC18 0
  (no_metavariable_TCC18-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.f_var)" "nil")))
 (no_metavariable_TCC19 0
  (no_metavariable_TCC19-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.term_var)"
    "nil")))
 (no_metavariable_TCC20 0
  (no_metavariable_TCC20-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.P1_var)"
    "nil")))
 (no_metavariable_TCC21 0
  (no_metavariable_TCC21-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.P2_var)"
    "nil")))
 (no_metavariable_TCC22 0
  (no_metavariable_TCC22-1 nil 3385274577
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.P1_var)"
    "nil")))
 (no_metavariable_TCC23 0
  (no_metavariable_TCC23-1 nil 3594441978
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.P2_var)"
    "nil")))
 (no_metavariable_TCC24 0
  (no_metavariable_TCC24-1 nil 3594441978
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (no_metavariable termination
    "wf_FODL_Language.no_metavariable(wf_FODL_Language.P_var)" "nil")))
 (wf_TCC1 0
  (wf_TCC1-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (wf termination "wf_FODL_Language.wf(wf_FODL_Language.f_var)"
    "nil")))
 (wf_TCC2 0
  (wf_TCC2-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (wf termination "wf_FODL_Language.wf(wf_FODL_Language.f_var)"
    "nil")))
 (wf_TCC3 0
  (wf_TCC3-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (wf termination "wf_FODL_Language.wf(wf_FODL_Language.pp`1)"
    "nil")))
 (wf_TCC4 0
  (wf_TCC4-1 nil 3385274577 ("" (termination-tcc) nil nil)
   ((sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (wf termination "wf_FODL_Language.wf(wf_FODL_Language.pp`2)"
    "nil")))
 (wf_Term_Constant 0
  (wf_Term_Constant-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Term_Constant subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].c(wf_FODL_Language.c)"
    "wf_Term_")))
 (wf_Term_Constant_type 0
  (wf_Term_Constant_type-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1) (("" (propax) nil nil)) nil)) nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (wf_Term_Constant_type subtype "wf_FODL_Language.x" "wf_Term_")))
 (wf_Term_Metavariable 0
  (wf_Term_Metavariable-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Term_Metavariable subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].m(wf_FODL_Language.m)"
    "wf_Term_")))
 (wf_Term_Metavariable_type 0
  (wf_Term_Metavariable_type-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1) (("" (propax) nil nil)) nil)) nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (wf_Term_Metavariable_type subtype "wf_FODL_Language.x"
    "wf_Term_")))
 (wf_Term_Variable 0
  (wf_Term_Variable-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Term_Variable subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].v(wf_FODL_Language.v)"
    "wf_Term_")))
 (wf_Term_Variable_type 0
  (wf_Term_Variable_type-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1) (("" (propax) nil nil)) nil)) nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (wf_Term_Variable_type subtype "wf_FODL_Language.x" "wf_Term_")))
 (wf_Term_FunctionApp_TCC1 0
  (wf_Term_FunctionApp_TCC1-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (replace -2 :dir rl)
      (("" (hide -2)
        ((""
          (case "FORALL (l: list[wf_Term_]): length(l) = length[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]](l)")
          (("1" (inst?) nil nil)
           ("2" (hide-all-but 1)
            (("2" (induct "l")
              (("1" (expand "length") (("1" (propax) nil nil)) nil)
               ("2" (skosimp*)
                (("2" (expand "length" 1) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" wf_FODL_Language
     nil))
   nil
   (wf_Term_FunctionApp_ subtype "wf_FODL_Language.l"
    "{lPrime: list_adt[FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].Term_].list | wf_FODL_Language.sigFunction_(wf_FODL_Language.f) = list_props[FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].Term_].length(lPrime)}")))
 (wf_Term_FunctionApp 0
  (wf_Term_FunctionApp-2 "" 3594674142
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      (("" (rewrite "every_nth")
        (("" (rewrite "every_nth")
          (("1" (skosimp)
            (("1" (inst -1 "i!1") (("1" (flatten) nil nil)) nil)) nil)
           ("2" (hide 2)
            (("2" (skosimp)
              (("2" (assert)
                (("2" (hide -1)
                  (("2" (replace -1) (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (every_nth formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" wf_FODL_Language
     nil))
   shostak
   (wf_Term_FunctionApp subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].F(wf_FODL_Language.f, wf_FODL_Language.l)"
    "wf_Term_"))
  (wf_Term_FunctionApp-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      ((""
        (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(LAMBDA (x: FODL_Language): P(x) AND Q(x))(l) IMPLIES every(Q)(l)")
        (("1" (inst?) (("1" (prop) nil nil)) nil)
         ("2" (hide-all-but 1)
          (("2" (skolem!)
            (("2" (induct "l")
              (("1" (expand "every") (("1" (propax) nil nil)) nil)
               ("2" (skosimp*)
                (("2" (prop)
                  (("1" (expand "every" 1)
                    (("1" (expand "every" -2) (("1" (prop) nil nil))
                      nil))
                    nil)
                   ("2" (expand "every" -1) (("2" (prop) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (every_nth formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" wf_FODL_Language
     nil))
   nil
   (wf_Term_FunctionApp subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].F(wf_FODL_Language.f, wf_FODL_Language.l)"
    "wf_Term_")))
 (wf_Formula_TRUE 0
  (wf_Formula_TRUE-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_TRUE subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].TRUE"
    "wf_Formula_")))
 (wf_Formula_FALSE 0
  (wf_Formula_FALSE-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_FALSE subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].FALSE"
    "wf_Formula_")))
 (wf_Formula_NOT 0
  (wf_Formula_NOT-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_NOT subtype "" "wf_Formula_")))
 (wf_Formula_IMPLIES 0
  (wf_Formula_IMPLIES-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_IMPLIES subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].IMPLIES(wf_FODL_Language.f_0, wf_FODL_Language.f_1)"
    "wf_Formula_")))
 (wf_Formula_OR 0
  (wf_Formula_OR-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_OR subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].OR(wf_FODL_Language.f_0, wf_FODL_Language.f_1)"
    "wf_Formula_")))
 (wf_Formula_AND 0
  (wf_Formula_AND-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_AND subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].AND(wf_FODL_Language.f_0, wf_FODL_Language.f_1)"
    "wf_Formula_")))
 (wf_Formula_IFF 0
  (wf_Formula_IFF-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_IFF subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].IFF(wf_FODL_Language.f_0, wf_FODL_Language.f_1)"
    "wf_Formula_")))
 (wf_Formula_PredicateApp_TCC1 0
  (wf_Formula_PredicateApp_TCC1-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (replace -2 :dir rl)
      (("" (hide -2)
        ((""
          (case "FORALL (l: list[wf_Term_]): length(l) = length[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]](l)")
          (("1" (inst?) nil nil)
           ("2" (hide-all-but 1)
            (("2" (induct "l")
              (("1" (expand "length") (("1" (propax) nil nil)) nil)
               ("2" (skosimp*)
                (("2" (expand "length" 1) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" wf_FODL_Language
     nil))
   nil
   (wf_Formula_PredicateApp_ subtype "wf_FODL_Language.l"
    "{lPrime: list_adt[FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].Term_].list | wf_FODL_Language.sigPredicate(wf_FODL_Language.p) = list_props[FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].Term_].length(lPrime)}")))
 (wf_Formula_PredicateApp 0
  (wf_Formula_PredicateApp-2 "" 3594674219
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      (("" (rewrite "every_nth")
        (("" (rewrite "every_nth")
          (("1" (skosimp)
            (("1" (inst -1 "i!1") (("1" (flatten) nil nil)) nil)) nil)
           ("2" (hide 2)
            (("2" (skosimp)
              (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (every_nth formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" wf_FODL_Language
     nil))
   shostak
   (wf_Formula_PredicateApp subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].P(wf_FODL_Language.p, wf_FODL_Language.l)"
    "wf_Formula_"))
  (wf_Formula_PredicateApp-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      ((""
        (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(LAMBDA (x: FODL_Language): P(x) AND Q(x))(l) IMPLIES every(Q)(l)")
        (("1" (inst?) (("1" (prop) nil nil)) nil)
         ("2" (hide-all-but 1)
          (("2" (skolem!)
            (("2" (induct "l")
              (("1" (expand "every") (("1" (propax) nil nil)) nil)
               ("2" (skosimp*)
                (("2" (prop)
                  (("1" (expand "every" 1)
                    (("1" (expand "every" -2) (("1" (prop) nil nil))
                      nil))
                    nil)
                   ("2" (expand "every" -1) (("2" (prop) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil)
    (every_nth formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" wf_FODL_Language
     nil))
   nil
   (wf_Formula_PredicateApp subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].P(wf_FODL_Language.p, wf_FODL_Language.l)"
    "wf_Formula_")))
 (wf_Formula_EQ 0
  (wf_Formula_EQ-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1) (("" (propax) nil nil)) nil)) nil)
   ((wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil))
   nil
   (wf_Formula_EQ subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].=(wf_FODL_Language.t_0, wf_FODL_Language.t_1)"
    "wf_Formula_")))
 (wf_Formula_EXISTS_ 0
  (wf_Formula_EXISTS_-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_EXISTS_ subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].EXISTS_(wf_FODL_Language.v, wf_FODL_Language.f)"
    "wf_Formula_")))
 (wf_Formula_FORALL_ 0
  (wf_Formula_FORALL_-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Formula_FORALL_ subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].FORALL_(wf_FODL_Language.v, wf_FODL_Language.f)"
    "wf_Formula_")))
 (wf_Formula_DIAMOND 0
  (wf_Formula_DIAMOND-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      (("" (hide -3 -4)
        (("" (smash)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil))
   nil
   (wf_Formula_DIAMOND subtype
    "(FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].◇)(wf_FODL_Language.P, wf_FODL_Language.f)"
    "wf_Formula_")))
 (wf_Formula_BOX 0
  (wf_Formula_BOX-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      (("" (hide -3 -4)
        (("" (smash)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil))
   nil
   (wf_Formula_BOX subtype
    "(FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].□)(wf_FODL_Language.P, wf_FODL_Language.f)"
    "wf_Formula_")))
 (wf_Program_T?? 0
  (wf_Program_T??-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1) (("" (propax) nil nil)) nil)) nil)
   ((no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil))
   nil
   (wf_Program_T?? subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].T?(wf_FODL_Language.f)"
    "wf_Program_")))
 (wf_Program_A 0
  (wf_Program_A-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1) (("" (propax) nil nil)) nil)) nil)
   ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil))
   nil
   (wf_Program_A subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].A(wf_FODL_Language.pre, wf_FODL_Language.post)"
    "wf_Program_")))
 (wf_Program_SKIP 0
  (wf_Program_SKIP-1 nil 3385274577 ("" (grind) nil nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)) nil
   (wf_Program_SKIP subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].SKIP"
    "wf_Program_")))
 (wf_Program_ASSIGNMENT 0
  (wf_Program_ASSIGNMENT-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1) (("" (propax) nil nil)) nil)) nil)
   ((no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil)
    (wf_Program_SKIP name-judgement "wf_Program_" wf_FODL_Language
     nil))
   nil
   (wf_Program_ASSIGNMENT subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].<|(wf_FODL_Language.v, wf_FODL_Language.t)"
    "wf_Program_")))
 (wf_Program_COMPOSITION 0
  (wf_Program_COMPOSITION-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      (("" (split 1)
        (("1" (hide -3 -4)
          (("1" (smash)
            (("1" (grind) nil nil) ("2" (grind) nil nil)
             ("3" (grind) nil nil) ("4" (grind) nil nil)
             ("5" (grind) nil nil) ("6" (grind) nil nil)
             ("7" (grind) nil nil))
            nil))
          nil)
         ("2" (hide -1 -2)
          (("2" (smash)
            (("1" (grind) nil nil) ("2" (grind) nil nil)
             ("3" (grind) nil nil) ("4" (grind) nil nil)
             ("5" (grind) nil nil) ("6" (grind) nil nil)
             ("7" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil)
    (wf_Program_SKIP name-judgement "wf_Program_" wf_FODL_Language
     nil))
   nil
   (wf_Program_COMPOSITION subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].//(wf_FODL_Language.P_0, wf_FODL_Language.P_1)"
    "wf_Program_")))
 (wf_Program_CHOICE 0
  (wf_Program_CHOICE-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      (("" (split 1)
        (("1" (hide -3 -4)
          (("1" (smash)
            (("1" (grind) nil nil) ("2" (grind) nil nil)
             ("3" (grind) nil nil) ("4" (grind) nil nil)
             ("5" (grind) nil nil) ("6" (grind) nil nil)
             ("7" (grind) nil nil))
            nil))
          nil)
         ("2" (hide -1 -2)
          (("2" (smash)
            (("1" (grind) nil nil) ("2" (grind) nil nil)
             ("3" (grind) nil nil) ("4" (grind) nil nil)
             ("5" (grind) nil nil) ("6" (grind) nil nil)
             ("7" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil)
    (wf_Program_SKIP name-judgement "wf_Program_" wf_FODL_Language
     nil))
   nil
   (wf_Program_CHOICE subtype
    "(FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].+)(wf_FODL_Language.P_0, wf_FODL_Language.P_1)"
    "wf_Program_")))
 (wf_Program_ITERATION 0
  (wf_Program_ITERATION-1 nil 3385274577
   ("" (skolem-typepred)
    (("" (expand "wf" 1)
      (("" (smash)
        (("1" (grind) nil nil) ("2" (grind) nil nil)
         ("3" (grind) nil nil) ("4" (grind) nil nil)
         ("5" (grind) nil nil) ("6" (grind) nil nil)
         ("7" (grind) nil nil))
        nil))
      nil))
    nil)
   ((no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]"
     wf_FODL_Language nil)
    (Function_ formal-type-decl nil wf_FODL_Language nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]"
     wf_FODL_Language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil wf_FODL_Language nil)
    (Variable formal-type-decl nil wf_FODL_Language nil)
    (Metavariable formal-type-decl nil wf_FODL_Language nil)
    (Constant formal-type-decl nil wf_FODL_Language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" wf_FODL_Language nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" wf_FODL_Language
     nil)
    (wf_Program_SKIP name-judgement "wf_Program_" wf_FODL_Language
     nil))
   nil
   (wf_Program_ITERATION subtype
    "FODL_Language_adt[wf_FODL_Language.Constant, wf_FODL_Language.Metavariable, wf_FODL_Language.Variable, wf_FODL_Language.Predicate, wf_FODL_Language.sigPredicate, wf_FODL_Language.Function_, wf_FODL_Language.sigFunction_].*(wf_FODL_Language.P)"
    "wf_Program_"))))

