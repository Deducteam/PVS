
%% PVS Version 3.2
%% 6.2 [Linux (x86)] (May 3, 2004 1:28)
$$$pvs-strategies
(defhelper install-theories-to-rewrite (theories)
  (let ((th (car theories)) (ths (cdr theories)))
    (if theories
	(then
	 (auto-rewrite-theory th :always? !!)
	 (install-theories-to-rewrite ths))
      (skip)))
  "Installs theories to rewrite"
  "Installing the theories to rewrite"
)

(defstep purify-fodl (&optional fnum induct &rest theories)
  (then
   (if theories
       (install-theories-to-rewrite theories)
     (install-theories-to-rewrite ("SpecProperties" "SpecActions" "SpecPredicates")))
   (auto-rewrite "wf_P" "wf_F")
   (auto-rewrite-theory "FODL_semantic" :always? !!)
   (auto-rewrite-theory "mucalculus" :always? !!)
   (auto-rewrite-theory "sets" :always? !!)   
   (auto-rewrite "mConstant" "mPredicate" "mFunction_")
   (auto-rewrite "map" "nth")
   (if fnum
       (assert fnum)
     (assert))
   (stop-rewrite))
  "Purifies a first-order dynamic logic formula"
  "Purifying using first-order dynamic logic"
)

(defstep prove-wf (fnum)
  (then
   (if theories
       (install-theories-to-rewrite theories)
     (install-theories-to-rewrite ("SpecProperties" "SpecActions" "SpecPredicates")))
   (auto-rewrite-theory "wf_FODL_Language" :always? !!) 
   (auto-rewrite "every")
   (assert fnum)
   (stop-rewrite))
  "Proves that a formula is well formed"
  "Proving that a formula is well formed"
)

(defstep prove-no_metavariable (fnum &rest theories)
  (then
   (if theories
       (install-theories-to-rewrite theories)
     (install-theories-to-rewrite ("SpecProperties" "SpecActions" "SpecPredicates")))
   (auto-rewrite-theory "wf_FODL_Language" :always? !!) 
   (auto-rewrite "every")
   (assert fnum)
   (stop-rewrite))
  "Proves that a formula has no metavariable"
  "Proving that a formula has no metavariable"
)

(defstep purify-fa (&optional fnum strong)
  (then
   (if strong
       (auto-rewrite-theory "FA_semantic" :always? !!)
     (auto-rewrite-theory "FA_semantic" :exclude ("zero" "one" "one_prime"
						  "C_0" "C_1" "one_prime_C_0"
						  "one_prime_C_1" "one_prime_Addr"
						  "one_prime_Data"
						  "sum" "product" "complement"
						  "composition" "converse" "fork")
			  :always? !!))
   (if fnum
       (assert fnum)
     (assert))
   (stop-rewrite))
  "Purifies a fork algebra formula"
  "Purifying using fork algebra"
)

(defstep purify-ag (&optional fnum strong &rest theories)
  (then
   (purify-fodl fnum theories)
   (purify-fa fnum strong))
  "Purifies an Ag formula"
  "Purifying using Ag"
)

(defstep expand-meaning (&optional (fnum *) ocurrence)
  (try
   (expand "meaningF" fnum ocurrence)
   (skip)
   (try
    (expand "m" fnum ocurrence)
    (skip)
    (skip)))
  "Expands the meaning of a first-order dynamic logic formula"
  "Expanding the meaning of a first-order dynamic logic formula"
)  

$$$PVSHOME/.pvs.lisp
(in-package :pvs)

(setq *decision-procedures* (remove 'ics *decision-procedures*))

(defun valid-binfile? (filename)
  (let ((fe (get-context-file-entry filename)))
    (and fe
	 (ce-object-date fe)
	 (let ((specdate (file-write-date (make-specpath filename)))
	       (bindate (file-write-date (make-binpath filename))))
	   (and bindate
		specdate
		(eql bindate (ce-object-date fe))
		(<= specdate bindate))))))

(defun asociate-proof-with-formula (theory-name formula-name strategy)
  (let ((theory (get-typechecked-theory theory-name)))
    (if theory
	(let ((fdecl (find-if #'(lambda (d)
				  (and (formula-decl? d)
				       (same-id d formula-name)))
		       (all-decls theory))))
	  (if fdecl
	      (multiple-value-bind (strat err)
		  (if (stringp strategy)
		      (ignore-errors (values (read-from-string strategy)))
		      strategy)
		(let ((just (unless err
			      (or (revert-justification strat)
				  (revert-justification (list "" strat))
				  strat))))
		  (unless just
		    (type-error strategy "Bad form for strategy~%  ~s" strategy))
		  (setf (justification fdecl) just)
		  (save-all-proofs theory)
		  (pvs-message "Formula ~a associated with new strategy"
		    formula-name)))
	      (pvs-message "Formula ~a not found" formula-name)))
	(pvs-message "Theory ~a not found" theory-name))))

(defun collect-strategy-names (&optional all?)
  (with-open-file (*standard-output* "/dev/null" :direction :output
				     :if-exists :overwrite)
    (with-open-file (*error-output* "/dev/null" :direction :output
				    :if-exists :overwrite)
      (read-strategies-files)))
  (let ((names nil))
    (maphash #'(lambda (n s)
		 (push (string-downcase (string n)) names))
	     *rulebase*)
    (maphash #'(lambda (n s)
		 (unless (and (not all?)
			      (defhelper-entry? s))
		   (push (string-downcase (string n)) names)))
	     *rules*)
    (maphash #'(lambda (n s)
		 (unless (or (and (not all?)
				  (defhelper-entry? s))
			     (defstep-entry? s))
		   (push (string-downcase (string n)) names)))
	     *steps*)
    (sort names #'string<)))

$$$PVSHOME/.pvs.lisp
(in-package :pvs)

(setq *decision-procedures* (remove 'ics *decision-procedures*))

(defun valid-binfile? (filename)
  (let ((fe (get-context-file-entry filename)))
    (and fe
	 (ce-object-date fe)
	 (let ((specdate (file-write-date (make-specpath filename)))
	       (bindate (file-write-date (make-binpath filename))))
	   (and bindate
		specdate
		(eql bindate (ce-object-date fe))
		(<= specdate bindate))))))

(defun asociate-proof-with-formula (theory-name formula-name strategy)
  (let ((theory (get-typechecked-theory theory-name)))
    (if theory
	(let ((fdecl (find-if #'(lambda (d)
				  (and (formula-decl? d)
				       (same-id d formula-name)))
		       (all-decls theory))))
	  (if fdecl
	      (multiple-value-bind (strat err)
		  (if (stringp strategy)
		      (ignore-errors (values (read-from-string strategy)))
		      strategy)
		(let ((just (unless err
			      (or (revert-justification strat)
				  (revert-justification (list "" strat))
				  strat))))
		  (unless just
		    (type-error strategy "Bad form for strategy~%  ~s" strategy))
		  (setf (justification fdecl) just)
		  (save-all-proofs theory)
		  (pvs-message "Formula ~a associated with new strategy"
		    formula-name)))
	      (pvs-message "Formula ~a not found" formula-name)))
	(pvs-message "Theory ~a not found" theory-name))))

(defun collect-strategy-names (&optional all?)
  (with-open-file (*standard-output* "/dev/null" :direction :output
				     :if-exists :overwrite)
    (with-open-file (*error-output* "/dev/null" :direction :output
				    :if-exists :overwrite)
      (read-strategies-files)))
  (let ((names nil))
    (maphash #'(lambda (n s)
		 (push (string-downcase (string n)) names))
	     *rulebase*)
    (maphash #'(lambda (n s)
		 (unless (and (not all?)
			      (defhelper-entry? s))
		   (push (string-downcase (string n)) names)))
	     *rules*)
    (maphash #'(lambda (n s)
		 (unless (or (and (not all?)
				  (defhelper-entry? s))
			     (defstep-entry? s))
		   (push (string-downcase (string n)) names)))
	     *steps*)
    (sort names #'string<)))

$$$SpecProperties.pvs
SpecProperties: THEORY

  BEGIN

    IMPORTING FA_Language, 
              wf_FODL_Language[Constant, 
                               Metavariable,
                               Variable, 
                               Predicate, sigPredicate,
                               Function_, sigFunction_]

    %% Predicados de la especificación Ag.
    %% Predicates of the Ag specification.
    IMPORTING SpecPredicates

    %% Acciones atómicas de la especificación Ag.
    %% Atomic actions of the Ag specification.
    IMPORTING SpecActions

    %                                                                               %
    % DirtyCacheWrite_preserves_NonDirtyCache: LEMMA                                %
    % FORALL (cs: DirtyCacheSystem): NonDirtyCache(cs) =>                           %
    %    [DirtyCacheWrite(cs)]NonDirtyCache(cs)                                     %
    DirtyCacheWrite_preserves_NonDirtyCache: wf_Formula_ = 
                 FORALL_(v(cs), NonDirtyCache(v(cs)) IMPLIES 
                              [](DirtyCacheWrite(v(cs)), NonDirtyCache(v(cs))))
    %                                                                               %
    % DirtyFlush_preserves_NonDirtyCache: LEMMA                                     %
    % FORALL (cs: DirtyCacheSystem): NonDirtyCache(cs) =>                           %
    %    [DirtyFlush(cs)]NonDirtyCache(cs)                                          %
    DirtyFlush_preserves_NonDirtyCache: wf_Formula_ = 
                 FORALL_(v(cs), NonDirtyCache(v(cs)) IMPLIES 
                              [](DirtyFlush(v(cs)), NonDirtyCache(v(cs))))
    %                                                                               %
    % DirtyLoad_preserves_NonDirtyCache: LEMMA                                      %
    % FORALL (cs: DirtyCacheSystem): NonDirtyCache(cs) =>                           %
    %    [DirtyLoad(cs)]NonDirtyCache(cs)                                           %
    DirtyLoad_preserves_NonDirtyCache: wf_Formula_ = 
                 FORALL_(v(cs), NonDirtyCache(v(cs)) IMPLIES 
                              [](DirtyLoad(v(cs)), NonDirtyCache(v(cs))))
    %                                                                               %
    % DirtySetFlush_preserves_NonDirtyCache: LEMMA                                  %
    % FORALL (cs: DirtyCacheSystem): NonDirtyCache(cs) =>                           %
    %    [DirtySetFlush(cs)]NonDirtyCache(cs)                                       %
    DirtySetFlush_preserves_NonDirtyCache: wf_Formula_ = 
                 FORALL_(v(cs), NonDirtyCache(v(cs)) IMPLIES 
                              [](DirtySetFlush(v(cs)), NonDirtyCache(v(cs))))
    %                                                                               %
    % AllStar_preserves_NonDirtyCache: LEMMA                                        %
    % FORALL (cs: DirtyCacheSystem): NonDirtyCache(cs) =>                           %
    %    [(DirtyCacheWrite(cs)+DirtyFlush(cs)+DirtyLoad(cs)+                        %
    %      DirtySetFlush(cs))*]NonDirtyCache(cs)                                    %
    AllStar_preserves_NonDirtyCache: wf_Formula_ = 
                 FORALL_(v(cs), NonDirtyCache(v(cs)) IMPLIES 
                              [](*(DirtyCacheWrite(v(cs))+DirtyFlush(v(cs))+
                                   DirtyLoad(v(cs))+DirtySetFlush(v(cs))), 
                                 NonDirtyCache(v(cs))))
    %                                                                               %
    % DirtySetFlush_leaves_DirtyCacheConsistent: LEMMA                              %
    % FORALL (cs: DirtyCacheSystem): NonDirtyCache(cs) =>                           %
    %    [DirtySetFlush(cs)]DirtyCacheConsistent(cs)                                %
    DirtySetFlush_leaves_DirtyCacheConsistent: wf_Formula_ = 
                 FORALL_(v(cs), NonDirtyCache(v(cs)) IMPLIES 
                              [](DirtySetFlush(v(cs)), DirtyCacheConsistent(v(cs))))
    %                                                                               %
    % Consistency_criteria: THEOREM                                                 %
    % FORALL (cs: DirtyCacheSystem): NonDirtyCache(cs) =>                           %
    %    [(DirtyCacheWrite(cs)+DirtyFlush(cs)+DirtyLoad(cs)+                        %
    %      DirtySetFlush(cs))*;DirtySetFlush(cs)]DirtyCacheConsistent(cs)           %
    Consistency_criteria: wf_Formula_ = FORALL_(v(cs), NonDirtyCache(v(cs)) IMPLIES 
                                [](*(DirtyCacheWrite(v(cs))+DirtyFlush(v(cs))+
                                     DirtyLoad(v(cs))+DirtySetFlush(v(cs)))//DirtySetFlush(v(cs)), 
                                   DirtyCacheConsistent(v(cs))))
    %                                                                               %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    IMPORTING FA_lemmas,
              FODL_lemmas[Constant, 
                          Metavariable,
                          Variable, 
                          Predicate, sigPredicate,
                          Function_, sigFunction_,
                          TypePred,
                          TPMetavariable, TPVariable,
                          Carrier,
                          mTypePred,
                          mConstant, 
                          mPredicate, 
                          mFunction_]

    IMPORTING FODL_conversions[Constant, 
                               Metavariable,
                               Variable, 
                               Predicate, sigPredicate,
                               Function_, sigFunction_,
                               TypePred,
                               TPMetavariable, TPVariable,
                               Carrier,
                               mTypePred,
                               mConstant, 
                               mPredicate, 
                               mFunction_]

    DirtyCacheWrite_preserves_NonDirtyCache: LEMMA
       DirtyCacheWrite_preserves_NonDirtyCache
 
    DirtyFlush_preserves_NonDirtyCache: LEMMA
       DirtyFlush_preserves_NonDirtyCache
 
    DirtyLoad_preserves_NonDirtyCache: LEMMA
       DirtyLoad_preserves_NonDirtyCache
 
    DirtySetFlush_preserves_NonDirtyCache: LEMMA
       DirtySetFlush_preserves_NonDirtyCache
 
    AllStar_preserves_NonDirtyCache: LEMMA
       AllStar_preserves_NonDirtyCache

    DirtySetFlush_leaves_DirtyCacheConsistent: LEMMA
       DirtySetFlush_leaves_DirtyCacheConsistent
 
    Consistency_criteria: THEOREM
       Consistency_criteria

 END SpecProperties

$$$SpecProperties.prf
(SpecProperties (IMP_FODL_lemmas_TCC1 0 (IMP_FODL_lemmas_TCC1-2 "pvs 3.2" 3290494410 3292718050 ("" (skosimp*) (("" (case "t!1 = Carrier OR t!1 = Addr OR t!1 = Data OR t!1 = Dirty OR t!1 = Cache OR t!1 = Memory OR t!1 = DirtyCache OR t!1 = DirtyCacheSystem") (("1" (prop) (("1" (inst 1 "zero") (("1" (expand "mTypePred") (("1" (smash) (("1" (purify-fa 1 t) nil nil)) nil)) nil)) nil) ("2" (inst 1 "LAMBDA (x: [FA_Element, FA_Element]): x = (element(epsilon({e: (Addr_Element) | TRUE})), element(epsilon({e: (Addr_Element) | TRUE})))") (("1" (expand "mTypePred") (("1" (smash) (("1" (purify-fa 1 t) (("1" (prop) (("1" (decompose-equality -1) (("1" (use "non_empty_Addr") (("1" (inst -2 "(element[Element]
                  (epsilon[(Addr_Element)]({e: (Addr_Element) | TRUE})),
              element[Element]
                  (epsilon[(Addr_Element)]({e: (Addr_Element) | TRUE})))") nil nil)) nil) ("2" (use "non_empty_Addr") nil nil)) nil) ("2" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (skosimp) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (use "non_empty_Addr") nil nil)) nil)) nil) ("4" (skosimp*) (("4" (use "non_empty_Addr") nil nil)) nil)) nil) ("3" (apply-extensionality 1 :hide? t) (("1" (bddsimp) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil) ("3" (skosimp*) (("3" (use "non_empty_Addr") nil nil)) nil) ("4" (skosimp) (("4" (use "non_empty_Addr") nil nil)) nil) ("5" (skosimp) (("5" (use "non_empty_Addr") nil nil)) nil)) nil) ("4" (apply-extensionality 1 :hide? t) (("1" (bddsimp) (("1" (skosimp) nil nil) ("2" (skosimp) (("2" (skosimp) nil nil)) nil) ("3" (inst?) (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (use "non_empty_Addr") nil nil)) nil) ("3" (skosimp) (("3" (use "non_empty_Addr") nil nil)) nil) ("4" (skosimp) (("4" (use "non_empty_Addr") nil nil)) nil) ("5" (skosimp) (("5" (use "non_empty_Addr") nil nil)) nil) ("6" (skosimp) (("6" (use "non_empty_Addr") nil nil)) nil)) nil) ("5" (apply-extensionality 1 :hide? t) (("1" (bddsimp) (("1" (inst 1 "epsilon({e: (Addr_Element) | TRUE})") (("1" (prop) (("1" (assert) nil nil)) nil) ("2" (use "non_empty_Addr") nil nil)) nil) ("2" (replace -1) (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil)) nil) ("3" (inst 1 "LAMBDA (x: [FA_Element, FA_Element]): x = (element(epsilon({e: (Data_Element) | TRUE})), element(epsilon({e: (Data_Element) | TRUE})))") (("1" (expand "mTypePred") (("1" (smash) (("1" (purify-fa 1 t) (("1" (prop) (("1" (decompose-equality -1) (("1" (use "non_empty_Data") (("1" (inst?) nil nil)) nil) ("2" (use "non_empty_Data") nil nil)) nil) ("2" (apply-extensionality 1 :hide? t) (("1" (bddsimp) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil) ("3" (skosimp*) (("3" (use "non_empty_Data") nil nil)) nil) ("4" (skosimp*) (("4" (use "non_empty_Data") nil nil)) nil)) nil) ("3" (apply-extensionality 1 :hide? t) (("1" (bddsimp) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil) ("3" (skosimp*) (("3" (use "non_empty_Data") nil nil)) nil) ("4" (skosimp*) (("4" (use "non_empty_Data") nil nil)) nil) ("5" (skosimp*) (("5" (use "non_empty_Data") nil nil)) nil)) nil) ("4" (apply-extensionality 1 :hide? t) (("1" (bddsimp) (("1" (skosimp*) nil nil) ("2" (skosimp*) nil nil) ("3" (inst?) (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil) ("3" (skosimp*) (("3" (use "non_empty_Data") nil nil)) nil) ("4" (skosimp*) (("4" (use "non_empty_Data") nil nil)) nil) ("5" (skosimp*) (("5" (use "non_empty_Data") nil nil)) nil) ("6" (skosimp*) (("6" (use "non_empty_Data") nil nil)) nil)) nil) ("5" (apply-extensionality 1 :hide? t) (("1" (bddsimp) (("1" (inst?) (("1" (assert) nil nil) ("2" (use "non_empty_Data") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil)) nil) ("4" (inst 1 "zero") (("4" (expand "mTypePred") (("4" (smash) (("4" (purify-fa 1 t) nil nil)) nil)) nil)) nil) ("5" (inst 1 "zero") (("5" (expand "mTypePred") (("5" (smash) (("5" (purify-fa 1 t) nil nil)) nil)) nil)) nil) ("6" (inst 1 "zero") (("6" (expand "mTypePred") (("6" (smash) (("6" (purify-fa 1 t) nil nil)) nil)) nil)) nil) ("7" (inst 1 "sum(composition(fork(composition(Pi_1, one_prime_C_0), composition(Pi_2, composition(zero, inl))), Pi_2), composition(fork(composition(Pi_1, one_prime_C_1), composition(Pi_2, composition(zero, inr))), Pi_2))") (("7" (expand "mTypePred") (("7" (smash) (("7" (purify-fa 1 t) (("7" (expand "extend") (("7" (inst 1 "zero" "zero") (("1" (apply-extensionality 1 :hide? t) (("1" (prop) (("1" (skosimp*) (("1" (smash) (("1" (skosimp*) (("1" (purify-fa -8 t) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (smash) (("2" (skosimp*) (("2" (purify-fa -8 t) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) nil nil) ("3" (purify-fa 1 t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (inst 1 "sum(composition(fork(composition(Pi_1, one_prime_C_0), composition(Pi_2, composition(zero, inl))), Pi_2), composition(fork(composition(Pi_1, one_prime_C_1), composition(Pi_2, composition(zero, inr))), Pi_2))") (("8" (expand "mTypePred") (("8" (smash) (("8" (purify-fa 1 t) (("8" (expand "extend") (("8" (inst 1 "zero" "sum(composition(fork(composition(Pi_1, one_prime_C_0), composition(Pi_2, composition(zero, inl))), Pi_2), composition(fork(composition(Pi_1, one_prime_C_1), composition(Pi_2, composition(zero, inr))), Pi_2))") (("1" (apply-extensionality 1 :hide? t) (("1" (prop) (("1" (skosimp*) (("1" (smash) (("1" (skosimp*) (("1" (purify-fa -8 t) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (smash) (("2" (skosimp*) (("2" (purify-fa -8 t) (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) (("2" (inst 1 "zero" "zero") (("1" (prop) (("1" (apply-extensionality 1 :hide? t) (("1" (expand "extend") (("1" (prop) (("1" (skosimp*) (("1" (smash) (("1" (skosimp*) (("1" (purify-fa -8 t) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (smash) (("2" (skosimp*) (("2" (purify-fa -8 t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality 1 :hide? t) (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) nil nil) ("3" (purify-fa 1 t) nil nil)) nil)) nil) ("3" (purify-fa 1 t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil) proved ((DirtyCacheSystem adt-constructor-decl "(DirtyCacheSystem?)" FA_semantic nil) (DirtyCacheSystem? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (DirtyCache adt-constructor-decl "(DirtyCache?)" FA_semantic nil) (DirtyCache? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Memory adt-constructor-decl "(Memory?)" FA_semantic nil) (Memory? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Cache adt-constructor-decl "(Cache?)" FA_semantic nil) (Cache? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Dirty adt-constructor-decl "(Dirty?)" FA_semantic nil) (Dirty? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Data adt-constructor-decl "(Data?)" FA_semantic nil) (Data? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Addr adt-constructor-decl "(Addr?)" FA_semantic nil) (Addr? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Carrier adt-constructor-decl "(Carrier?)" FA_semantic nil) (Carrier? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (= const-decl "[T, T -> boolean]" equalities nil) (TypePred type-decl nil FA_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (DirtyCache const-decl "Carrier" FA_semantic nil) (Memory const-decl "Carrier" FA_semantic nil) (inr const-decl "Carrier" FA_semantic nil) (one_prime_C_1 const-decl "Carrier" FA_semantic nil) (inl const-decl "Carrier" FA_semantic nil) (Pi_2 const-decl "Carrier" FA_semantic nil) (one_prime_C_0 const-decl "Carrier" FA_semantic nil) (Pi_1 const-decl "Carrier" FA_semantic nil) (fork const-decl "Carrier" FA_semantic nil) (extend const-decl "R" extend nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (pair? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (el0 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (c_0 const-decl "Element" FA_semantic nil) (el1 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (c_1 const-decl "Element" FA_semantic nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (C_0 const-decl "Carrier" FA_semantic nil) (C_1 const-decl "Carrier" FA_semantic nil) (Dirty const-decl "Carrier" FA_semantic nil) (Dom const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (Cache const-decl "Carrier" FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Data_Element const-decl "PRED[Element]" FA_semantic nil) (non_empty_Data formula-decl nil FA_semantic nil) (Data const-decl "PRED[Carrier]" FA_semantic nil) (one_prime_Data const-decl "Carrier" FA_semantic nil) (Data const-decl "PRED[FA_Element]" FA_semantic nil) (TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (non_empty_Addr formula-decl nil FA_semantic nil) (FALSE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Addr const-decl "PRED[Carrier]" FA_semantic nil) (Pair const-decl "bool" FA_semantic nil) (Functional const-decl "bool" FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (OneToOne const-decl "bool" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (t!1 skolem-const-decl "TypePred" SpecProperties nil) (Carrier const-decl "PRED[Carrier]" FA_semantic nil)) 18932 14580 t shostak) (IMP_FODL_lemmas_TCC1-1 nil 3290484298 nil ("" (skosimp*) (("" (case "t!1 = Carrier OR t!1 = Addr OR t!1 = Data OR t!1 = Dirty OR t!1 = Cache OR t!1 = Memory OR t!1 = DirtyCache OR t!1 = DirtyCacheSystem") (("1" (prop) (("1" (inst 1 "zero") (("1" (expand "mTypePred") (("1" (smash) (("1" (purify-fa 1 t) nil nil)) nil)) nil)) nil) ("2" (inst 1 "LAMBDA (x: [FA_Element, FA_Element]): x = (element(epsilon({e: (Addr_Element) | TRUE})), element(epsilon({e: (Addr_Element) | TRUE})))") (("1" (expand "mTypePred") (("1" (smash) (("1" (purify-fa 1 t) (("1" (prop) (("1" (decompose-equality -1) (("1" (use "non_empty_Addr") nil nil)) nil) ("2" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (use "non_empty_Addr") nil nil)) nil)) nil)) nil) ("3" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (use "non_empty_Addr") nil nil)) nil)) nil)) nil) ("4" (apply-extensionality 1) (("1" (hide 2) (("1" (skosimp*) (("1" (use "non_empty_Addr") nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil)) nil)) nil) ("5" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (inst 1 "epsilon({e: (Addr_Element) | TRUE})") (("1" (prop) (("1" (assert) nil nil)) nil) ("2" (use "non_empty_Addr") nil nil)) nil) ("2" (replace -1) (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Addr") nil nil)) nil)) nil) ("3" (inst 1 "LAMBDA (x: [FA_Element, FA_Element]): x = (element(epsilon({e: (Data_Element) | TRUE})), element(epsilon({e: (Data_Element) | TRUE})))") (("1" (expand "mTypePred") (("1" (smash) (("1" (purify-fa 1 t) (("1" (prop) (("1" (decompose-equality -1) (("1" (use "non_empty_Data") nil nil)) nil) ("2" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (use "non_empty_Data") nil nil)) nil)) nil)) nil) ("3" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (use "non_empty_Data") nil nil)) nil)) nil)) nil) ("4" (apply-extensionality 1) (("1" (hide 2) (("1" (skosimp*) (("1" (use "non_empty_Data") nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil)) nil)) nil) ("5" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (inst 1 "epsilon({e: (Data_Element) | TRUE})") (("1" (prop) (("1" (assert) nil nil)) nil) ("2" (use "non_empty_Data") nil nil)) nil) ("2" (replace -1) (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (use "non_empty_Data") nil nil)) nil)) nil) ("4" (inst 1 "zero") (("4" (expand "mTypePred") (("4" (smash) (("4" (purify-fa 1 t) nil nil)) nil)) nil)) nil) ("5" (inst 1 "zero") (("5" (expand "mTypePred") (("5" (smash) (("5" (purify-fa 1 t) nil nil)) nil)) nil)) nil) ("6" (inst 1 "zero") (("6" (expand "mTypePred") (("6" (smash) (("6" (purify-fa 1 t) nil nil)) nil)) nil)) nil) ("7" (inst 1 "sum(composition(fork(composition(Pi_1, one_prime_C_0), composition(Pi_2, composition(zero, inl))), Pi_2), composition(fork(composition(Pi_1, one_prime_C_1), composition(Pi_2, composition(zero, inr))), Pi_2))") (("7" (expand "mTypePred") (("7" (smash) (("7" (purify-fa 1 t) (("7" (expand "extend") (("7" (inst 1 "zero" "zero") (("1" (apply-extensionality 1) (("1" (prop) (("1" (skosimp*) (("1" (smash) (("1" (purify-fa -6 t) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (smash) (("2" (purify-fa -6 t) nil nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) nil nil) ("3" (purify-fa 1 t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (inst 1 "sum(composition(fork(composition(Pi_1, one_prime_C_0), composition(Pi_2, composition(zero, inl))), Pi_2), composition(fork(composition(Pi_1, one_prime_C_1), composition(Pi_2, composition(zero, inr))), Pi_2))") (("8" (expand "mTypePred") (("8" (smash) (("8" (purify-fa 1 t) (("8" (expand "extend") (("8" (inst 1 "zero" "sum(composition(fork(composition(Pi_1, one_prime_C_0), composition(Pi_2, composition(zero, inl))), Pi_2), composition(fork(composition(Pi_1, one_prime_C_1), composition(Pi_2, composition(zero, inr))), Pi_2))") (("1" (apply-extensionality 1) (("1" (prop) (("1" (skosimp*) (("1" (smash) (("1" (purify-fa -6 t) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (smash) (("2" (purify-fa -6 t) (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) (("2" (inst 1 "zero" "zero") (("1" (prop) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (expand "extend") (("1" (prop) (("1" (skosimp*) (("1" (smash) (("1" (purify-fa -6 t) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (smash) (("2" (purify-fa -6 t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality 1) (("2" (hide 2) (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) nil nil) ("3" (purify-fa 1 t) nil nil)) nil)) nil) ("3" (purify-fa 1 t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil) proved ((DirtyCacheSystem adt-constructor-decl "(DirtyCacheSystem?)" FA_semantic nil) (DirtyCacheSystem? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (DirtyCache adt-constructor-decl "(DirtyCache?)" FA_semantic nil) (DirtyCache? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Memory adt-constructor-decl "(Memory?)" FA_semantic nil) (Memory? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Cache adt-constructor-decl "(Cache?)" FA_semantic nil) (Cache? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Dirty adt-constructor-decl "(Dirty?)" FA_semantic nil) (Dirty? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Data adt-constructor-decl "(Data?)" FA_semantic nil) (Data? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Addr adt-constructor-decl "(Addr?)" FA_semantic nil) (Addr? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (Carrier adt-constructor-decl "(Carrier?)" FA_semantic nil) (Carrier? adt-recognizer-decl "[TypePred -> boolean]" FA_semantic nil) (= const-decl "[T, T -> boolean]" equalities nil) (TypePred type-decl nil FA_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (DirtyCache const-decl "Carrier" FA_semantic nil) (Memory const-decl "Carrier" FA_semantic nil) (fork const-decl "Carrier" FA_semantic nil) (Pi_1 const-decl "Carrier" FA_semantic nil) (one_prime_C_0 const-decl "Carrier" FA_semantic nil) (Pi_2 const-decl "Carrier" FA_semantic nil) (inl const-decl "Carrier" FA_semantic nil) (one_prime_C_1 const-decl "Carrier" FA_semantic nil) (inr const-decl "Carrier" FA_semantic nil) (extend const-decl "R" extend nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (pair? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (el0 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (c_0 const-decl "Element" FA_semantic nil) (el1 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (c_1 const-decl "Element" FA_semantic nil) (Cache const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (Dom const-decl "Carrier" FA_semantic nil) (Dirty const-decl "Carrier" FA_semantic nil) (C_1 const-decl "Carrier" FA_semantic nil) (C_0 const-decl "Carrier" FA_semantic nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Data_Element const-decl "PRED[Element]" FA_semantic nil) (non_empty_Data formula-decl nil FA_semantic nil) (Data const-decl "PRED[Carrier]" FA_semantic nil) (one_prime_Data const-decl "Carrier" FA_semantic nil) (Data const-decl "PRED[FA_Element]" FA_semantic nil) (TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (non_empty_Addr formula-decl nil FA_semantic nil) (FALSE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Addr const-decl "PRED[Carrier]" FA_semantic nil) (Pair const-decl "bool" FA_semantic nil) (Functional const-decl "bool" FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (OneToOne const-decl "bool" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (Carrier const-decl "PRED[Carrier]" FA_semantic nil)) nil nil nil nil)) (DirtyCacheWrite_preserves_NonDirtyCache 0 (DirtyCacheWrite_preserves_NonDirtyCache-3 "" 3292704349 3292718973 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (replace -2 1) (("1" (replace -3 1) (("1" (replace -4 1) (("1" (hide -2 -3 -4) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4 -5) (("1" (purify-fa -3) (("1" (purify-fa 1) (("1" (case "composition(composition(composition(t!2, one), t!3), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): composition(a, sum(b, c)) = sum(composition(a, b), composition(a, c))") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(product(complement(sum(d!1, t!2)), one_prime), composition(composition(t!2, one), t!3)) = zero") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a: Carrier): sum(a, zero) = a") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "complement(sum(d!1, t!2)) = product(complement(d!1), complement(t!2))") (("1" (replace -1) (("1" (hide -1) (("1" (use "BA_6") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "BA_4") (("1" (inst -1 "complement(t!2)" "one_prime") (("1" (replace -1) (("1" (hide -1) (("1" (use "BA_6") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c, a1, b1: Carrier): sum(composition(a, b), c) = c AND sum(a, a1) = a AND sum(b, b1) = b IMPLIES sum(composition(a1, b1), c) = c") (("1" (inst -1 "product(complement(d!1), one_prime)" "ca!1" "mem!1" "product(product(complement(d!1), one_prime), complement(t!2))" "product(ca!1, complement(composition(t!2, one)))") (("1" (prop) (("1" (hide 2) (("1" (purify-fa 1 :strong t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (replace -2 -1 :dir rl) (("2" (replace -3 -1 :dir rl) (("2" (hide -2 -3) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (decompose-equality -1) (("2" (bddsimp) (("2" (skosimp*) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) (("2" (hide 1) (("2" (skosimp*) (("2" (typepred "t!2") (("2" (expand "TPVariable" -1) (("2" (expand "mTypePred" -1) (("2" (expand "Addr" -1) (("2" (prop) (("2" (purify-fa -2 :strong t) (("2" (decompose-equality -2) (("2" (inst -1 "(x!3, x!5)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (prop) (("1" (inst 1 "x!3") (("1" (prop) nil nil)) nil) ("2" (inst 2 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst 1 "x!3") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) nil nil) ("2" (skosimp*) (("2" (typepred "t!3") (("2" (expand "TPVariable" -1) (("2" (expand "mTypePred" -1) (("2" (expand "Data" -1) (("2" (flatten) (("2" (expand "Pair" -1) (("2" (flatten) (("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 1) (("2" (inst?) (("2" (prop) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPVariable") (("1" (expand "TPMetavariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TypePred type-decl nil FA_semantic nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Constant type-decl nil FA_Language nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (DirtyCacheWrite_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (DirtyCacheWrite const-decl "[(v?) -> wf_Program_]" SpecActions nil) (pre_DirtyCacheWrite const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (post_DirtyCacheWrite const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (nth def-decl "T" list_props nil) (mTerm def-decl "Carrier" FODL_semantic nil) (map adt-def-decl "list[T1]" list_adt_map nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) (t!1 skolem-const-decl "(mTypePred(TPVariable(cs)))" SpecProperties nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (Memory_DirtyCache_DirtyCacheSystem formula-decl nil FA_semantic nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (Cache_Dirty_DirtyCache formula-decl nil FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (Neg const-decl "Carrier" FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (addr? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (addr adt-constructor-decl "(addr?)" FA_Language nil) (one const-decl "Carrier" FA_semantic nil) (data? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (data adt-constructor-decl "(data?)" FA_Language nil) (one_prime const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (FALSE const-decl "bool" booleans nil) (Addr const-decl "PRED[Carrier]" FA_semantic nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (BA_4 formula-decl nil FA_axioms nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (BA_6 formula-decl nil FA_axioms nil) (zero const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (Data const-decl "PRED[Carrier]" FA_semantic nil) (Pair const-decl "bool" FA_semantic nil) (FunctionUpdate const-decl "Carrier" FA_semantic nil) (FunctionUndef const-decl "Carrier" FA_semantic nil) (NOT const-decl "[bool -> bool]" booleans nil) (cs0? adt-recognizer-decl "[Metavariable -> boolean]" FA_Language nil) (cs0 adt-constructor-decl "(cs0?)" FA_Language nil)) 29191 7140 t shostak) (DirtyCacheWrite_preserves_NonDirtyCache-2 "Fix for 3.2" 3290489781 3292689201 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (replace -2 1) (("1" (replace -3 1) (("1" (replace -4 1) (("1" (hide -2 -3 -4) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4 -5) (("1" (purify-fa -3) (("1" (purify-fa 1) (("1" (case "composition(composition(composition(t!2, one), t!3), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): composition(a, sum(b, c)) = sum(composition(a, b), composition(a, c))") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(product(complement(sum(d!1, t!2)), one_prime), composition(composition(t!2, one), t!3)) = zero") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a: Carrier): sum(a, zero) = a") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "complement(sum(d!1, t!2)) = product(complement(d!1), complement(t!2))") (("1" (replace -1) (("1" (hide -1) (("1" (use "BA_6") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "BA_4") (("1" (inst -1 "complement(t!2)" "one_prime") (("1" (replace -1) (("1" (hide -1) (("1" (use "BA_6") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c, a1, b1: Carrier): sum(composition(a, b), c) = c AND sum(a, a1) = a AND sum(b, b1) = b IMPLIES sum(composition(a1, b1), c) = c") (("1" (inst -1 "product(complement(d!1), one_prime)" "ca!1" "mem!1" "product(product(complement(d!1), one_prime), complement(t!2))" "product(ca!1, complement(composition(t!2, one)))") (("1" (prop) (("1" (hide 2) (("1" (purify-fa 1 :strong t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (replace -2 -1 :dir rl) (("2" (replace -3 -1 :dir rl) (("2" (hide -2 -3) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (decompose-equality -1) (("2" (bddsimp) (("2" (skosimp*) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) (("2" (hide 1) (("2" (skosimp*) (("2" (typepred "t!2") (("2" (expand "TPVariable" -1) (("2" (expand "mTypePred" -1) (("2" (expand "Addr" -1) (("2" (prop) (("2" (purify-fa -2 :strong t) (("2" (decompose-equality -2) (("2" (inst -1 "(x!3, x!5)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (prop) (("1" (inst 1 "x!3") (("1" (prop) nil nil)) nil) ("2" (inst 2 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst 1 "x!3") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) nil nil) ("2" (skosimp*) (("2" (typepred "t!3") (("2" (expand "TPVariable" -1) (("2" (expand "mTypePred" -1) (("2" (expand "Data" -1) (("2" (flatten) (("2" (expand "Pair" -1) (("2" (flatten) (("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 1) (("2" (inst?) (("2" (prop) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPVariable") (("1" (expand "TPMetavariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((cs0 adt-constructor-decl "(cs0?)" FA_Language nil) (cs0? adt-recognizer-decl "[Metavariable -> boolean]" FA_Language nil) (NOT const-decl "[bool -> bool]" booleans nil) (FunctionUndef const-decl "Carrier" FA_semantic nil) (FunctionUpdate const-decl "Carrier" FA_semantic nil) (Pair const-decl "bool" FA_semantic nil) (Data const-decl "PRED[Carrier]" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (BA_6 formula-decl nil FA_axioms nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (BA_4 formula-decl nil FA_axioms nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (Addr const-decl "PRED[Carrier]" FA_semantic nil) (FALSE const-decl "bool" booleans nil) (product const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (data adt-constructor-decl "(data?)" FA_Language nil) (data? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (one const-decl "Carrier" FA_semantic nil) (addr adt-constructor-decl "(addr?)" FA_Language nil) (addr? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (composition const-decl "Carrier" FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (Neg const-decl "Carrier" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Cache_Dirty_DirtyCache formula-decl nil FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (Memory_DirtyCache_DirtyCacheSystem formula-decl nil FA_semantic nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) nil (cs adt-constructor-decl "(cs?)" FA_Language nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) nil (mTerm def-decl "Carrier" FODL_semantic nil) (nth def-decl "T" list_props nil) (post_DirtyCacheWrite const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (pre_DirtyCacheWrite const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (DirtyCacheWrite const-decl "[(v?) -> wf_Program_]" SpecActions nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (DirtyCacheWrite_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil) (Constant type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Predicate type-decl nil FA_Language nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (TypePred type-decl nil FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (Element nonempty-type-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Carrier type-eq-decl nil FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil)) 31583 7450 t shostak) (DirtyCacheWrite_preserves_NonDirtyCache-1 nil 3290484298 3290485536 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (replace -2 1) (("1" (replace -3 1) (("1" (replace -4 1) (("1" (hide -2 -3 -4) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4 -5) (("1" (purify-fa -3) (("1" (purify-fa 1) (("1" (case "composition(composition(composition(t!2, one), t!3), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): composition(a, sum(b, c)) = sum(composition(a, b), composition(a, c))") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(product(complement(sum(d!1, t!2)), one_prime), composition(composition(t!2, one), t!3)) = zero") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a: Carrier): sum(a, zero) = a") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "complement(sum(d!1, t!2)) = product(complement(d!1), complement(t!2))") (("1" (replace -1) (("1" (hide -1) (("1" (use "BA_6") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "BA_4") (("1" (inst -1 "complement(t!2)" "one_prime") (("1" (replace -1) (("1" (hide -1) (("1" (use "BA_6") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c, a1, b1: Carrier): sum(composition(a, b), c) = c AND sum(a, a1) = a AND sum(b, b1) = b IMPLIES sum(composition(a1, b1), c) = c") (("1" (inst -1 "product(complement(d!1), one_prime)" "ca!1" "mem!1" "product(product(complement(d!1), one_prime), complement(t!2))" "product(ca!1, complement(composition(t!2, one)))") (("1" (prop) (("1" (hide 2) (("1" (purify-fa 1 :strong t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (replace -2 -1 :dir rl) (("2" (replace -3 -1 :dir rl) (("2" (hide -2 -3) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (decompose-equality -1) (("2" (bddsimp) (("2" (skosimp*) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) (("2" (hide 1) (("2" (prop) (("2" (skosimp*) (("2" (typepred "t!2") (("2" (expand "TPVariable" -1) (("2" (expand "mTypePred" -1) (("2" (expand "Addr" -1) (("2" (prop) (("2" (purify-fa -2 :strong t) (("2" (decompose-equality -2) (("2" (inst -1 "(x!1, x!4)") (("2" (bddsimp) (("2" (replace -2 -1 :dir rl) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (prop) (("1" (inst 1 "x!3") (("1" (prop) nil nil)) nil) ("2" (inst 2 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst 1 "x!3") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) nil nil) ("2" (skosimp*) (("2" (typepred "t!3") (("2" (expand "TPVariable" -1) (("2" (expand "mTypePred" -1) (("2" (expand "Data" -1) (("2" (flatten) (("2" (expand "Pair" -1) (("2" (flatten) (("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 1) (("2" (inst?) (("2" (prop) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPVariable") (("1" (expand "TPMetavariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((cs0 adt-constructor-decl "(cs0?)" FA_Language nil) (cs0? adt-recognizer-decl "[Metavariable -> boolean]" FA_Language nil) (NOT const-decl "[bool -> bool]" booleans nil) (FunctionUndef const-decl "Carrier" FA_semantic nil) (FunctionUpdate const-decl "Carrier" FA_semantic nil) (Pair const-decl "bool" FA_semantic nil) (Data const-decl "PRED[Carrier]" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (BA_6 formula-decl nil FA_axioms nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (BA_4 formula-decl nil FA_axioms nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (Addr const-decl "PRED[Carrier]" FA_semantic nil) (FALSE const-decl "bool" booleans nil) (product const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (data adt-constructor-decl "(data?)" FA_Language nil) (data? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (one const-decl "Carrier" FA_semantic nil) (addr adt-constructor-decl "(addr?)" FA_Language nil) (addr? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (composition const-decl "Carrier" FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (Neg const-decl "Carrier" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Cache_Dirty_DirtyCache formula-decl nil FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (Memory_DirtyCache_DirtyCacheSystem formula-decl nil FA_semantic nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (mTerm def-decl "Carrier" FODL_semantic nil) (nth def-decl "T" list_props nil) (post_DirtyCacheWrite const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (pre_DirtyCacheWrite const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (DirtyCacheWrite const-decl "[(v?) -> wf_Program_]" SpecActions nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (DirtyCacheWrite_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil) (Constant type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Predicate type-decl nil FA_Language nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (TypePred type-decl nil FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (Element nonempty-type-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Carrier type-eq-decl nil FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil)) 722380 14290 nil nil)) (DirtyFlush_preserves_NonDirtyCache 0 (DirtyFlush_preserves_NonDirtyCache-2 "" 3292710041 3292718073 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (typepred "t!1") (("1" (expand "TPVariable" -1) (("1" (expand "mTypePred" -1) (("1" (expand "DirtyCacheSystem" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (hide -4 -5 -6) (("1" (expand "Leq" -3) (("1" (expand "Leq" 1) (("1" (expand "Neg") (("1" (expand "FunctionUpdate") (("1" (expand "FunctionUndef") (("1" (case "composition(composition(t!2, one), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(composition(t!2, one), composition(t!2, ca!1)) = composition(t!2, ca!1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "complement(product(d!1, complement(t!2))) = sum(complement(d!1), t!2)") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(product(sum(complement(d!1), t!2), one_prime), product(ca!1, complement(composition(t!2, one)))) = composition(product(complement(d!1), one_prime), product(ca!1, complement(composition(t!2, one))))") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(t!2, ca!1) = zero") (("1" (replace -1) (("1" (case "FORALL (a: Carrier): sum(a, zero) = a") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "product(mem!1, complement(composition(zero, one))) = mem!1") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, b1, c: Carrier): sum(composition(a, b), c) = c IMPLIES sum(composition(a, product(b, b1)), c) = c") (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (decompose-equality -1) (("2" (bddsimp) (("2" (skosimp*) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "composition(composition(t!2, ca!1), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): sum(a, b) = b IMPLIES sum(a, sum(b, c)) = sum(b, c)") (("1" (inst?) (("1" (prop) (("1" (hide 3) (("1" (purify-fa 1 :strong t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (purify-fa -4 :strong t) (("1" (decompose-equality -4) (("1" (inst -1 "(x!1, x!2)") (("1" (bddsimp) (("1" (skosimp*) (("1" (inst 2 "x!5") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 3 "x!4") (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst 3 "x!4") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sum") (("2" (decompose-equality -5) (("2" (inst -1 "(x!1, x!2)") (("2" (assert) (("2" (expand "composition") (("2" (inst 1 "x!3") (("2" (assert) (("2" (expand "product") (("2" (expand "complement") (("2" (expand "one_prime") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 3) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (apply-extensionality 3) (("2" (hide 2 3) (("2" (skosimp*) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) (("2" (typepred "t!2") (("2" (purify-fa -1) (("2" (prop) (("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst-cp -1 "(x!3, x!5)") (("2" (inst -1 "(x!1, x!6)") (("2" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (purify-fa -1 t) (("1" (decompose-equality -1) (("1" (inst -1 "(x!6, x!5)") (("1" (bddsimp) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst -1 "(x!6, x!5)") (("2" (bddsimp) (("2" (inst 1 "x!5") (("2" (prop) (("2" (inst 1 "x!6") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa -4 t) (("2" (decompose-equality -4) (("2" (inst -1 "(x!3, x!5)") (("2" (bddsimp) (("2" (purify-fa -2 t) (("2" (replace -2) (("2" (inst 1 "x!5") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (purify-fa -4 t) (("3" (decompose-equality -4) (("3" (inst -1 "(x!1, x!6)") (("3" (bddsimp) (("3" (purify-fa -2 t) (("3" (replace -2) (("3" (inst 1 "x!6") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (purify-fa -3 t) (("4" (decompose-equality -3) (("4" (inst -1 "(x!1, x!6)") (("4" (bddsimp) (("4" (purify-fa -2 t) (("4" (replace -2) (("4" (inst 1 "x!6") (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (inst?) (("1" (prop) (("1" (skosimp*) (("1" (assert) (("1" (inst 1 "x!3") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (inst 1 "x!3") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (typepred "t!2") (("1" (purify-fa -1) (("1" (prop) (("1" (purify-fa -1 t) (("1" (decompose-equality -1) (("1" (inst-cp -1 "(x!1, x!4)") (("1" (inst -1 "(x!3, x!5)") (("1" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2 -5 1) (("1" (purify-fa :strong t) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (inst -2 "(x!4, x!5)") (("1" (bddsimp) (("1" (replace -2) (("1" (inst 1 "x!5") (("1" (prop) nil nil)) nil)) nil) ("2" (inst -1 "(x!4, x!5)") (("2" (bddsimp) (("1" (inst 1 "x!5") (("1" (prop) nil nil)) nil) ("2" (hide -3 1 3 4) (("2" (typepred "t!2") (("2" (purify-fa -1) (("2" (prop) (("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst -1 "(x!4, x!5)") (("2" (bddsimp) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst -1 "(x!4, x!5)") (("2" (bddsimp) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst -1 "(x!4, x!5)") (("2" (bddsimp) (("2" (inst 1 "x!5") (("2" (prop) (("2" (inst 1 "x!4") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa -4 t) (("2" (decompose-equality -4) (("2" (inst -1 "(x!1, x!4)") (("2" (bddsimp) (("2" (purify-fa -2 t) (("2" (replace -2) (("2" (inst 1 "x!4") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (purify-fa -4 t) (("3" (decompose-equality -4) (("3" (inst -1 "(x!3, x!5)") (("3" (bddsimp) (("3" (purify-fa -2 t) (("3" (replace -2) (("3" (inst 1 "x!5") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (purify-fa -3 t) (("4" (decompose-equality -3) (("4" (inst -1 "(x!3, x!5)") (("4" (bddsimp) (("4" (purify-fa -2 t) (("4" (replace -2) (("4" (inst 1 "x!5") (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) nil nil) ("2" (skosimp*) (("2" (inst 1 "x!3") (("2" (inst 1 "x!3") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable" -1) (("2" (expand "mTypePred" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPVariable") (("1" (expand "TPMetavariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((cs0 adt-constructor-decl "(cs0?)" FA_Language nil) (cs0? adt-recognizer-decl "[Metavariable -> boolean]" FA_Language nil) (NOT const-decl "[bool -> bool]" booleans nil) (Leq const-decl "bool" FA_semantic nil) (Neg const-decl "Carrier" FA_semantic nil) (FunctionUndef const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (Dom const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (FALSE const-decl "bool" booleans nil) (OneToOne const-decl "bool" FA_semantic nil) (Functional const-decl "bool" FA_semantic nil) (Pair const-decl "bool" FA_semantic nil) (Addr const-decl "PRED[Carrier]" FA_semantic nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (zero const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (addr adt-constructor-decl "(addr?)" FA_Language nil) (addr? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (composition const-decl "Carrier" FA_semantic nil) (FunctionUpdate const-decl "Carrier" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Cache_Dirty_DirtyCache formula-decl nil FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (Memory_DirtyCache_DirtyCacheSystem formula-decl nil FA_semantic nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (t!1 skolem-const-decl "(mTypePred(TPVariable(cs)))" SpecProperties nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (map adt-def-decl "list[T1]" list_adt_map nil) (mTerm def-decl "Carrier" FODL_semantic nil) (nth def-decl "T" list_props nil) (post_DirtyFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (pre_DirtyFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (DirtyFlush const-decl "[(v?) -> wf_Program_]" SpecActions nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (DirtyFlush_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil) (Constant type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Predicate type-decl nil FA_Language nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (TypePred type-decl nil FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (Element nonempty-type-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Carrier type-eq-decl nil FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil)) 14630 9220 t shostak) (DirtyFlush_preserves_NonDirtyCache-1 nil 3290484298 3292689211 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (typepred "t!1") (("1" (expand "TPVariable" -1) (("1" (expand "mTypePred" -1) (("1" (expand "DirtyCacheSystem" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (hide -4 -5 -6) (("1" (expand "Leq" -3) (("1" (expand "Leq" 1) (("1" (expand "Neg") (("1" (expand "FunctionUpdate") (("1" (expand "FunctionUndef") (("1" (case "composition(composition(t!2, one), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(composition(t!2, one), composition(t!2, ca!1)) = composition(t!2, ca!1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "complement(product(d!1, complement(t!2))) = sum(complement(d!1), t!2)") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(product(sum(complement(d!1), t!2), one_prime), product(ca!1, complement(composition(t!2, one)))) = composition(product(complement(d!1), one_prime), product(ca!1, complement(composition(t!2, one))))") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(t!2, ca!1) = zero") (("1" (replace -1) (("1" (case "FORALL (a: Carrier): sum(a, zero) = a") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "product(mem!1, complement(composition(zero, one))) = mem!1") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, b1, c: Carrier): sum(composition(a, b), c) = c IMPLIES sum(composition(a, product(b, b1)), c) = c") (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (decompose-equality -1) (("2" (bddsimp) (("2" (skosimp*) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "composition(composition(t!2, ca!1), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): sum(a, b) = b IMPLIES sum(a, sum(b, c)) = sum(b, c)") (("1" (inst?) (("1" (prop) (("1" (hide 3) (("1" (purify-fa 1 :strong t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (purify-fa -4 :strong t) (("1" (decompose-equality -4) (("1" (inst -1 "(x!1, x!2)") (("1" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 3) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (apply-extensionality 3) (("2" (hide 2 3) (("2" (skosimp*) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) (("2" (typepred "t!2") (("2" (purify-fa -1) (("2" (prop) (("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst-cp -1 "(x!3, x!5)") (("2" (inst -1 "(x!1, x!6)") (("2" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (purify-fa -1 t) (("1" (decompose-equality -1) (("1" (inst -1 "(x!6, x!5)") (("1" (bddsimp) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst -1 "(x!6, x!5)") (("2" (bddsimp) (("2" (inst 1 "x!5") (("2" (prop) (("2" (inst 1 "x!6") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa -4 t) (("2" (decompose-equality -4) (("2" (inst -1 "(x!3, x!5)") (("2" (bddsimp) (("2" (purify-fa -2 t) (("2" (replace -2) (("2" (inst 1 "x!5") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (purify-fa -4 t) (("3" (decompose-equality -4) (("3" (inst -1 "(x!1, x!6)") (("3" (bddsimp) (("3" (purify-fa -2 t) (("3" (replace -2) (("3" (inst 1 "x!6") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (purify-fa -3 t) (("4" (decompose-equality -3) (("4" (inst -1 "(x!1, x!6)") (("4" (bddsimp) (("4" (purify-fa -2 t) (("4" (replace -2) (("4" (inst 1 "x!6") (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (typepred "t!2") (("1" (purify-fa -1) (("1" (prop) (("1" (purify-fa -1 t) (("1" (decompose-equality -1) (("1" (inst-cp -1 "(x!1, x!4)") (("1" (inst -1 "(x!3, x!5)") (("1" (bddsimp) (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2 -5 1) (("1" (purify-fa :strong t) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (inst -2 "(x!4, x!5)") (("1" (bddsimp) (("1" (replace -2) (("1" (inst 1 "x!5") (("1" (prop) nil nil)) nil)) nil) ("2" (inst -1 "(x!4, x!5)") (("2" (bddsimp) (("1" (inst 1 "x!5") (("1" (prop) nil nil)) nil) ("2" (hide -3 1 3 4) (("2" (typepred "t!2") (("2" (purify-fa -1) (("2" (prop) (("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst -1 "(x!4, x!5)") (("2" (bddsimp) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst -1 "(x!4, x!5)") (("2" (bddsimp) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (purify-fa -1 t) (("2" (decompose-equality -1) (("2" (inst -1 "(x!4, x!5)") (("2" (bddsimp) (("2" (inst 1 "x!5") (("2" (prop) (("2" (inst 1 "x!4") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa -4 t) (("2" (decompose-equality -4) (("2" (inst -1 "(x!1, x!4)") (("2" (bddsimp) (("2" (purify-fa -2 t) (("2" (replace -2) (("2" (inst 1 "x!4") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (purify-fa -4 t) (("3" (decompose-equality -4) (("3" (inst -1 "(x!3, x!5)") (("3" (bddsimp) (("3" (purify-fa -2 t) (("3" (replace -2) (("3" (inst 1 "x!5") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (purify-fa -3 t) (("4" (decompose-equality -3) (("4" (inst -1 "(x!3, x!5)") (("4" (bddsimp) (("4" (purify-fa -2 t) (("4" (replace -2) (("4" (inst 1 "x!5") (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) nil nil) ("2" (skosimp*) (("2" (inst 1 "x!3") (("2" (inst 1 "x!3") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable" -1) (("2" (expand "mTypePred" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPVariable") (("1" (expand "TPMetavariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TypePred type-decl nil FA_semantic nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Constant type-decl nil FA_Language nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (DirtyFlush_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (DirtyFlush const-decl "[(v?) -> wf_Program_]" SpecActions nil) (pre_DirtyFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (post_DirtyFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (nth def-decl "T" list_props nil) (mTerm def-decl "Carrier" FODL_semantic nil) nil (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) nil (AssMetavariable type-eq-decl nil FODL_semantic nil) (Memory_DirtyCache_DirtyCacheSystem formula-decl nil FA_semantic nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (Cache_Dirty_DirtyCache formula-decl nil FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (FunctionUpdate const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (addr? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (addr adt-constructor-decl "(addr?)" FA_Language nil) (one const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (Addr const-decl "PRED[Carrier]" FA_semantic nil) (Pair const-decl "bool" FA_semantic nil) (Functional const-decl "bool" FA_semantic nil) (OneToOne const-decl "bool" FA_semantic nil) (FALSE const-decl "bool" booleans nil) (converse const-decl "Carrier" FA_semantic nil) (Dom const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (FunctionUndef const-decl "Carrier" FA_semantic nil) (Neg const-decl "Carrier" FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (NOT const-decl "[bool -> bool]" booleans nil) (cs0? adt-recognizer-decl "[Metavariable -> boolean]" FA_Language nil) (cs0 adt-constructor-decl "(cs0?)" FA_Language nil)) 9553 8720 nil nil)) (DirtyLoad_preserves_NonDirtyCache 0 (DirtyLoad_preserves_NonDirtyCache-2 "" 3292724426 3292724426 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem") (("1" (skosimp*) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (inst?) (("1" (prop) (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (hide -4 -5 -6) (("1" (expand "Leq" -3) (("1" (expand "Leq" 1) (("1" (expand "Neg") (("1" (expand "FunctionUpdate") (("1" (expand "FunctionUndef") (("1" (case "composition(composition(t!2, one), composition(t!2, mem!1)) = composition(t!2, mem!1)") (("1" (hide -1) (("1" (case "composition(composition(t!2, one), composition(t!2, mem!1)) = composition(t!2, mem!1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(t!2, mem!1) = zero") (("1" (replace -1) (("1" (hide -1) (("1" (case "sum(product(ca!1, complement(composition(zero, one))), zero) = ca!1") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "composition(composition(t!2, mem!1), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): composition(a, sum(b, c)) = sum(composition(a, b), composition(a, c))") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): sum(a, c) = c AND sum(b, c) = c IMPLIES sum(sum(a, b), c) = c") (("1" (inst?) (("1" (prop) (("1" (hide 3) (("1" (case "FORALL (a, b, c, d: Carrier): sum(composition(a, b), c) = c IMPLIES sum(composition(a, product(b, d)), c) = c") (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (decompose-equality -1) (("2" (bddsimp) (("2" (skosimp*) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("2" (skosimp*) (("2" (typepred "t!2") (("2" (purify-fa -1 :strong t) (("2" (prop) (("2" (decompose-equality -1) (("2" (decompose-equality -2) (("2" (decompose-equality -3) (("2" (decompose-equality -4) (("2" (inst -1 "(x!3, x!4)") (("2" (bddsimp) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (replace -1 :dir rl) (("2" (replace -2 :dir rl) (("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (inst 2 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst?) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 3) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (apply-extensionality 2) (("2" (hide 2) (("2" (skosimp*) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) (("2" (typepred "t!2") (("2" (purify-fa -1 :strong t) (("2" (prop) (("2" (decompose-equality -1) (("2" (decompose-equality -2) (("2" (decompose-equality -3) (("2" (decompose-equality -4) (("2" (inst-cp -1 "(x!3, x!5)") (("2" (inst -1 "(x!1, x!6)") (("2" (bddsimp) (("2" (replace -2) (("2" (replace -5) (("2" (inst -8 "(x!5, x!6)") (("2" (bddsimp) (("1" (replace -8) (("1" (propax) nil nil)) nil) ("2" (inst -7 "(x!5, x!6)") (("2" (bddsimp) (("1" (inst 1 "x!6") (("1" (prop) nil nil)) nil) ("2" (inst?) (("2" (prop) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (typepred "t!2") (("1" (purify-fa -1 :strong t) (("1" (prop) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (decompose-equality -3) (("1" (decompose-equality -4) (("1" (inst-cp -1 "(x!1, x!4)") (("1" (inst -1 "(x!3, x!5)") (("1" (bddsimp) (("1" (replace -2) (("1" (replace -5) (("1" (inst -8 "(x!4, x!5)") (("1" (bddsimp) (("1" (replace -8) (("1" (propax) nil nil)) nil) ("2" (inst 1 "x!5") (("2" (inst -7 "(x!4, x!5)") (("2" (bddsimp) (("2" (inst 1 "x!5") (("2" (prop) (("2" (inst 1 "x!4") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!1") (("2" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (typepred "t!2") (("1" (purify-fa -1 :strong t) (("1" (prop) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (decompose-equality -3) (("1" (decompose-equality -4) (("1" (inst-cp -1 "(x!1, x!4)") (("1" (inst -1 "(x!3, x!5)") (("1" (bddsimp) (("1" (replace -2) (("1" (replace -5) (("1" (inst -8 "(x!4, x!5)") (("1" (bddsimp) (("1" (replace -8) (("1" (propax) nil nil)) nil) ("2" (inst 1 "x!5") (("2" (inst -7 "(x!4, x!5)") (("2" (bddsimp) (("2" (inst 1 "x!5") (("2" (prop) (("2" (inst 1 "x!4") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!1") (("2" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPMetavariable") (("1" (expand "TPVariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved nil 5358091 68410 t shostak) (DirtyLoad_preserves_NonDirtyCache-1 nil 3290484298 3292718089 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem") (("1" (skosimp*) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (inst?) (("1" (prop) (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (hide -4 -5 -6) (("1" (expand "Leq" -3) (("1" (expand "Leq" 1) (("1" (expand "Neg") (("1" (expand "FunctionUpdate") (("1" (expand "FunctionUndef") (("1" (case "composition(composition(t!2, one), composition(t!2, mem!1)) = composition(t!2, mem!1)") (("1" (hide -1) (("1" (case "composition(composition(t!2, one), composition(t!2, mem!1)) = composition(t!2, mem!1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(t!2, mem!1) = zero") (("1" (replace -1) (("1" (hide -1) (("1" (case "sum(product(ca!1, complement(composition(zero, one))), zero) = ca!1") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "composition(composition(t!2, mem!1), one) = composition(t!2, one)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): composition(a, sum(b, c)) = sum(composition(a, b), composition(a, c))") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (a, b, c: Carrier): sum(a, c) = c AND sum(b, c) = c IMPLIES sum(sum(a, b), c) = c") (("1" (inst?) (("1" (prop) (("1" (hide 3) (("1" (case "FORALL (a, b, c, d: Carrier): sum(composition(a, b), c) = c IMPLIES sum(composition(a, product(b, d)), c) = c") (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (decompose-equality -1) (("2" (bddsimp) (("2" (skosimp*) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 1 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("2" (skosimp*) (("2" (typepred "t!2") (("2" (purify-fa -1 :strong t) (("2" (prop) (("2" (decompose-equality -1) (("2" (decompose-equality -2) (("2" (decompose-equality -3) (("2" (decompose-equality -4) (("2" (inst -1 "(x!1, x!3)") (("2" (bddsimp) (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (replace -1 :dir rl) (("2" (replace -2 :dir rl) (("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (inst 2 "x!3") (("2" (prop) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst?) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 3) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (apply-extensionality 2) (("2" (hide 2) (("2" (skosimp*) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) (("2" (typepred "t!2") (("2" (purify-fa -1 :strong t) (("2" (prop) (("2" (decompose-equality -1) (("2" (decompose-equality -2) (("2" (decompose-equality -3) (("2" (decompose-equality -4) (("2" (inst-cp -1 "(x!3, x!5)") (("2" (inst -1 "(x!1, x!6)") (("2" (bddsimp) (("2" (replace -2) (("2" (replace -5) (("2" (inst -8 "(x!5, x!6)") (("2" (bddsimp) (("1" (replace -8) (("1" (propax) nil nil)) nil) ("2" (inst -7 "(x!5, x!6)") (("2" (bddsimp) (("1" (inst 1 "x!6") (("1" (prop) nil nil)) nil) ("2" (inst?) (("2" (prop) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (typepred "t!2") (("1" (purify-fa -1 :strong t) (("1" (prop) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (decompose-equality -3) (("1" (decompose-equality -4) (("1" (inst-cp -1 "(x!1, x!4)") (("1" (inst -1 "(x!3, x!5)") (("1" (bddsimp) (("1" (replace -2) (("1" (replace -5) (("1" (inst -8 "(x!4, x!5)") (("1" (bddsimp) (("1" (replace -8) (("1" (propax) nil nil)) nil) ("2" (inst 1 "x!5") (("2" (inst -7 "(x!4, x!5)") (("2" (bddsimp) (("2" (inst 1 "x!5") (("2" (prop) (("2" (inst 1 "x!4") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!1") (("2" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (typepred "t!2") (("1" (purify-fa -1 :strong t) (("1" (prop) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (decompose-equality -3) (("1" (decompose-equality -4) (("1" (inst-cp -1 "(x!1, x!4)") (("1" (inst -1 "(x!3, x!5)") (("1" (bddsimp) (("1" (replace -2) (("1" (replace -5) (("1" (inst -8 "(x!4, x!5)") (("1" (bddsimp) (("1" (replace -8) (("1" (propax) nil nil)) nil) ("2" (inst 1 "x!5") (("2" (inst -7 "(x!4, x!5)") (("2" (bddsimp) (("2" (inst 1 "x!5") (("2" (prop) (("2" (inst 1 "x!4") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 1 "x!1") (("2" (prop) (("1" (inst?) nil nil) ("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPMetavariable") (("1" (expand "TPVariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((cs0 adt-constructor-decl "(cs0?)" FA_Language nil) (cs0? adt-recognizer-decl "[Metavariable -> boolean]" FA_Language nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (Memory_DirtyCache_DirtyCacheSystem formula-decl nil FA_semantic nil) (Cache_Dirty_DirtyCache formula-decl nil FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (Neg const-decl "Carrier" FA_semantic nil) (FunctionUndef const-decl "Carrier" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (FALSE const-decl "bool" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (OneToOne const-decl "bool" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (Functional const-decl "bool" FA_semantic nil) (Pair const-decl "bool" FA_semantic nil) (Addr const-decl "PRED[Carrier]" FA_semantic nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (one_prime const-decl "Carrier" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (addr adt-constructor-decl "(addr?)" FA_Language nil) (addr? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (composition const-decl "Carrier" FA_semantic nil) (FunctionUpdate const-decl "Carrier" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (t!1 skolem-const-decl "(mTypePred(TPVariable(cs)))" SpecProperties nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (map adt-def-decl "list[T1]" list_adt_map nil) (mTerm def-decl "Carrier" FODL_semantic nil) (nth def-decl "T" list_props nil) (post_DirtyLoad const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (pre_DirtyLoad const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (DirtyLoad const-decl "[(v?) -> wf_Program_]" SpecActions nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (DirtyLoad_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil) (Constant type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Predicate type-decl nil FA_Language nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (TypePred type-decl nil FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (Element nonempty-type-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Carrier type-eq-decl nil FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil)) 15713 8010 nil nil)) (DirtySetFlush_preserves_NonDirtyCache 0 (DirtySetFlush_preserves_NonDirtyCache-2 "" 3292725259 3292725259 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem") (("1" (skosimp*) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (inst?) (("1" (prop) (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (hide -4 -5 -6) (("1" (expand "Leq" -3) (("1" (expand "Leq" 1) (("1" (expand "Neg") (("1" (expand "FunctionUpdate") (("1" (expand "FunctionUndef") (("1" (case "composition(product(complement(zero), one_prime), ca!1) = ca!1") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(d!1, ca!1) = zero") (("1" (case "sum(product(mem!1, complement(composition(zero, one))), zero) = mem!1") (("1" (hide -1) (("1" (replace -1) (("1" (case "sum(product(mem!1, complement(composition(zero, one))), zero) = mem!1") (("1" (replace -1) (("1" (hide -1) (("1" (purify-fa -1 :strong t) (("1" (decompose-equality -1) (("1" (purify-fa -4 :strong t) (("1" (decompose-equality -4) (("1" (purify-fa 1 :strong t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (inst -2 "(x!1, x!2)") (("1" (bddsimp) (("1" (inst -2 "(x!1, x!2)") (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (case "composition(composition(d!1, ca!1), one) = composition(d!1, one)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "BA_3") (("1" (inst -1 "ca!1" "sum(product(mem!1, complement(composition(d!1, one))), composition(d!1, ca!1))") (("1" (replace -1) (("1" (hide -1) (("1" (use "BA_5") (("1" (hide -1) (("1" (purify-fa 2 :strong t) (("1" (apply-extensionality 2) (("1" (hide 3) (("1" (bddsimp) (("1" (skosimp*) (("1" (inst 1 "x!1") (("1" (prop) (("1" (typepred "d!1") (("1" (expand "Dirty") (("1" (purify-fa -1 :strong t) (("1" (decompose-equality -1) (("1" (inst -1 "(x!1, x!3)") (("1" (bddsimp) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 2 "x!1") (("2" (prop) (("2" (purify-fa -2 :strong t) (("2" (decompose-equality -2) (("2" (inst -1 "(x!1, x!1)") (("2" (bddsimp) (("2" (purify-fa -3 :strong t) (("2" (decompose-equality -3) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 3) (("2" (purify-fa :strong t) (("2" (decompose-equality -1) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (apply-extensionality 2) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (skosimp*) (("2" (inst -4 "(x!1, x!6)") (("2" (bddsimp) (("2" (replace -5) (("2" (skosimp*) (("2" (inst 1 "x!7") (("2" (inst 1 "x!6") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) (("2" (smash) (("1" (skosimp*) (("1" (assert) nil nil)) nil) ("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPMetavariable") (("1" (expand "TPVariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved nil 797815 13780 t shostak) (DirtySetFlush_preserves_NonDirtyCache-1 nil 3290484298 3292718097 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem") (("1" (skosimp*) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (inst?) (("1" (prop) (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4) (("1" (replace -4) (("1" (replace -5) (("1" (replace -6) (("1" (hide -4 -5 -6) (("1" (expand "Leq" -3) (("1" (expand "Leq" 1) (("1" (expand "Neg") (("1" (expand "FunctionUpdate") (("1" (expand "FunctionUndef") (("1" (case "composition(product(complement(zero), one_prime), ca!1) = ca!1") (("1" (replace -1) (("1" (hide -1) (("1" (case "composition(d!1, ca!1) = zero") (("1" (case "sum(product(mem!1, complement(composition(zero, one))), zero) = mem!1") (("1" (hide -1) (("1" (replace -1) (("1" (case "sum(product(mem!1, complement(composition(zero, one))), zero) = mem!1") (("1" (replace -1) (("1" (hide -1) (("1" (purify-fa -1 :strong t) (("1" (decompose-equality -1) (("1" (purify-fa -4 :strong t) (("1" (decompose-equality -4) (("1" (purify-fa 1 :strong t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (inst -2 "(x!1, x!2)") (("1" (bddsimp) (("1" (inst -3 "(x!1, x!2)") (("1" (inst?) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa 1 :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (case "composition(composition(d!1, ca!1), one) = composition(d!1, one)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "BA_3") (("1" (inst -1 "ca!1" "sum(product(mem!1, complement(composition(d!1, one))), composition(d!1, ca!1))") (("1" (replace -1) (("1" (hide -1) (("1" (use "BA_5") (("1" (hide -1) (("1" (purify-fa 2 :strong t) (("1" (apply-extensionality 2) (("1" (hide 3) (("1" (bddsimp) (("1" (skosimp*) (("1" (inst 1 "x!1") (("1" (prop) (("1" (typepred "d!1") (("1" (expand "Dirty") (("1" (purify-fa -1 :strong t) (("1" (decompose-equality -1) (("1" (inst -1 "(x!1, x!3)") (("1" (bddsimp) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 2 "x!1") (("2" (prop) (("2" (purify-fa -2 :strong t) (("2" (decompose-equality -2) (("2" (inst -1 "(x!1, x!1)") (("2" (bddsimp) (("2" (purify-fa -3 :strong t) (("2" (decompose-equality -3) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 3) (("2" (purify-fa :strong t) (("2" (decompose-equality -1) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (apply-extensionality 2) (("2" (hide 2) (("2" (bddsimp) (("1" (skosimp*) (("1" (inst?) nil nil)) nil) ("2" (skosimp*) (("2" (inst -4 "(x!1, x!6)") (("2" (bddsimp) (("2" (replace -5) (("2" (skosimp*) (("2" (inst 1 "x!7") (("2" (inst 1 "x!6") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (purify-fa :strong t) (("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPMetavariable") (("1" (expand "TPVariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TypePred type-decl nil FA_semantic nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Constant type-decl nil FA_Language nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (DirtySetFlush_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (DirtySetFlush const-decl "[(v?) -> wf_Program_]" SpecActions nil) (pre_DirtySetFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (post_DirtySetFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (nth def-decl "T" list_props nil) (mTerm def-decl "Carrier" FODL_semantic nil) (map adt-def-decl "list[T1]" list_adt_map nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) (t!1 skolem-const-decl "(mTypePred(TPVariable(cs)))" SpecProperties nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (FunctionUpdate const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (Dom const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (BA_5 formula-decl nil FA_axioms nil) (BA_3 formula-decl nil FA_axioms nil) (sum const-decl "Carrier" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (FALSE const-decl "bool" booleans nil) (FunctionUndef const-decl "Carrier" FA_semantic nil) (Neg const-decl "Carrier" FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (Cache_Dirty_DirtyCache formula-decl nil FA_semantic nil) (Memory_DirtyCache_DirtyCacheSystem formula-decl nil FA_semantic nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (cs0? adt-recognizer-decl "[Metavariable -> boolean]" FA_Language nil) (cs0 adt-constructor-decl "(cs0?)" FA_Language nil)) 8330 5680 nil nil)) (AllStar_preserves_NonDirtyCache 0 (AllStar_preserves_NonDirtyCache-1 nil 3290484298 3292718125 ("" (expand "AllStar_preserves_NonDirtyCache" 1) (("" (expand-meaning) (("" (expand-meaning 1) (("" (expand-meaning 1) (("" (skosimp*) (("" (purify-fodl -1) (("" (lemma "PDL_6_box_form") (("" (inst -1 "NonDirtyCache(v(cs))" "DirtyCacheWrite(v(cs)) + DirtyFlush(v(cs)) + DirtyLoad(v(cs)) + DirtySetFlush(v(cs))" "w!1 WITH [(cs) := t!1]") (("" (expand-meaning -1) (("" (inst?) (("" (expand-meaning -1) (("" (prop) (("" (hide 2) (("" (expand-meaning 1) (("" (prop) (("1" (purify-fodl 1) nil nil) ("2" (expand-meaning 1) (("2" (skosimp*) (("2" (expand-meaning 1) (("2" (prop) (("2" (purify-fodl -2) (("2" (expand-meaning 1) (("2" (skosimp*) (("2" (purify-fodl 1) (("2" (hide -1 -4) (("2" (purify-fodl -2) (("2" (prop) (("1" (lemma "DirtyCacheWrite_preserves_NonDirtyCache") (("1" (purify-fodl -1) (("1" (inst -1 "wPrime!2") (("1" (inst -1 "mMetavariable!1") (("1" (inst -1 "wPrime!1(cs)") (("1" (prop) (("1" (inst -1 "wPrime!2") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "DirtyFlush_preserves_NonDirtyCache") (("2" (purify-fodl -1) (("2" (inst -1 "wPrime!2") (("2" (inst -1 "mMetavariable!1") (("2" (inst -1 "wPrime!1(cs)") (("2" (prop) (("2" (inst -1 "wPrime!2") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "DirtyLoad_preserves_NonDirtyCache") (("3" (purify-fodl -1) (("3" (inst -1 "wPrime!2") (("3" (inst -1 "mMetavariable!1") (("3" (inst -1 "wPrime!1(cs)") (("3" (prop) (("3" (inst -1 "wPrime!2") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "DirtySetFlush_preserves_NonDirtyCache") (("4" (purify-fodl -1) (("4" (inst -1 "wPrime!2") (("4" (inst -1 "mMetavariable!1") (("4" (inst -1 "wPrime!1(cs)") (("4" (prop) (("4" (inst -1 "wPrime!2") (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((meaningF const-decl "PRED[World_]" FODL_semantic nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Constant type-decl nil FA_Language nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (nth def-decl "T" list_props nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TypePred type-decl nil FA_semantic nil) (mTerm def-decl "Carrier" FODL_semantic nil) (map adt-def-decl "list[T1]" list_adt_map nil) (FODL_Language type-decl nil FODL_Language_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (wf_Term_ type-eq-decl nil wf_FODL_Language nil) (v adt-constructor-decl "[Variable -> (v?)]" FODL_Language_adt nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (+ adt-constructor-decl "[[Program_, Program_] -> (CHOICE?)]" FODL_Language_adt nil) (DirtyCacheWrite const-decl "[(v?) -> wf_Program_]" SpecActions nil) (DirtyFlush const-decl "[(v?) -> wf_Program_]" SpecActions nil) (DirtyLoad const-decl "[(v?) -> wf_Program_]" SpecActions nil) (DirtySetFlush const-decl "[(v?) -> wf_Program_]" SpecActions nil) (World_ type-eq-decl nil FODL_semantic nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (DirtyCacheWrite_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (DirtyCacheWrite_preserves_NonDirtyCache formula-decl nil SpecProperties nil) (DirtyFlush_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (DirtyFlush_preserves_NonDirtyCache formula-decl nil SpecProperties nil) (DirtyLoad_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (DirtyLoad_preserves_NonDirtyCache formula-decl nil SpecProperties nil) (DirtySetFlush_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (DirtySetFlush_preserves_NonDirtyCache formula-decl nil SpecProperties nil) (pre_DirtyCacheWrite const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (post_DirtyCacheWrite const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (pre_DirtyFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (post_DirtyFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (pre_DirtyLoad const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (post_DirtyLoad const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (pre_DirtySetFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (post_DirtySetFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (PDL_6_box_form formula-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (AllStar_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil)) 27490 19930 nil nil)) (DirtySetFlush_leaves_DirtyCacheConsistent 0 (DirtySetFlush_leaves_DirtyCacheConsistent-2 "" 3292725642 3292725642 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem") (("1" (skosimp*) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (inst?) (("1" (prop) (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4) (("1" (replace -4) (("1" (replace -6) (("1" (hide -4 -5 -6) (("1" (purify-fa 1 t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (skosimp*) (("1" (typepred "d!1") (("1" (purify-fa -1 t) (("1" (decompose-equality -1) (("1" (inst -1 "(x!1, x!4)") (("1" (bddsimp) (("1" (replace -2) (("1" (inst 1 "x!4") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa -4 t) (("2" (decompose-equality -4) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 1 "x!1") (("2" (assert) (("2" (inst 2 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPMetavariable") (("1" (expand "TPVariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved nil 374189 6020 t shostak) (DirtySetFlush_leaves_DirtyCacheConsistent-1 nil 3290484298 3292718130 ("" (purify-fodl) (("" (skosimp*) (("" (inst -2 "LAMBDA (m: Metavariable): t!1") (("1" (skosimp*) (("1" (typepred "t!1") (("1" (expand "TPVariable") (("1" (expand "mTypePred") (("1" (expand "DirtyCacheSystem") (("1" (skosimp*) (("1" (lemma "Memory_DirtyCache_DirtyCacheSystem") (("1" (inst?) (("1" (prop) (("1" (typepred "dca!1") (("1" (expand "DirtyCache" -1) (("1" (skosimp*) (("1" (lemma "Cache_Dirty_DirtyCache") (("1" (inst?) (("1" (prop) (("1" (hide -3 -7) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -5) (("1" (hide -5) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (replace -4 :dir rl) (("1" (hide -1 -2 -4) (("1" (replace -4) (("1" (replace -6) (("1" (hide -4 -5 -6) (("1" (purify-fa 1 t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (skosimp*) (("1" (typepred "d!1") (("1" (purify-fa -1 t) (("1" (decompose-equality -1) (("1" (inst -1 "(x!1, x!4)") (("1" (bddsimp) (("1" (replace -2) (("1" (inst 1 "x!4") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa -4 t) (("2" (decompose-equality -4) (("2" (inst -1 "(x!1, x!2)") (("2" (bddsimp) (("2" (inst 2 "x!1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "TPVariable") (("2" (expand "mTypePred") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (typepred "t!1") (("2" (case "m!1 = cs0") (("1" (replace -1) (("1" (expand "TPMetavariable") (("1" (expand "TPVariable") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TypePred type-decl nil FA_semantic nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Constant type-decl nil FA_Language nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (DirtySetFlush_leaves_DirtyCacheConsistent const-decl "wf_Formula_" SpecProperties nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (DirtySetFlush const-decl "[(v?) -> wf_Program_]" SpecActions nil) (pre_DirtySetFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (post_DirtySetFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (DirtyCacheConsistent const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (nth def-decl "T" list_props nil) (mTerm def-decl "Carrier" FODL_semantic nil) (map adt-def-decl "list[T1]" list_adt_map nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) (t!1 skolem-const-decl "(mTypePred(TPVariable(cs)))" SpecProperties nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (FunctionUndef const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (FunctionUpdate const-decl "Carrier" FA_semantic nil) (Leq const-decl "bool" FA_semantic nil) (Neg const-decl "Carrier" FA_semantic nil) (Addr const-decl "PRED[FA_Element]" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (one_prime_Addr const-decl "Carrier" FA_semantic nil) (Addr_Element const-decl "PRED[Element]" FA_semantic nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Cache_Dirty_DirtyCache formula-decl nil FA_semantic nil) (Memory_DirtyCache_DirtyCacheSystem formula-decl nil FA_semantic nil) (DirtyCacheSystem const-decl "PRED[Carrier]" FA_semantic nil) (cs0? adt-recognizer-decl "[Metavariable -> boolean]" FA_Language nil) (cs0 adt-constructor-decl "(cs0?)" FA_Language nil)) 5285 4650 nil nil)) (Consistency_criteria 0 (Consistency_criteria-1 nil 3290484298 3292718142 ("" (expand "Consistency_criteria" 1) (("" (expand-meaning 1) (("" (expand-meaning 1) (("" (expand-meaning 1) (("" (skosimp*) (("" (purify-fodl -1) (("" (lemma "PDL_4_box_form") (("" (inst -1 "DirtyCacheConsistent(v(cs))" "*(DirtyCacheWrite(v(cs)) + DirtyFlush(v(cs)) + DirtyLoad(v(cs)) + DirtySetFlush(v(cs)))" "DirtySetFlush(v(cs))" "w!1 WITH [(cs) := t!1]") (("" (expand-meaning -1) (("" (inst -1 "mMetavariable!1") (("" (expand-meaning -1) (("" (prop) (("" (hide 2 3) (("" (expand-meaning 1) (("" (skosimp*) (("" (lemma "AllStar_preserves_NonDirtyCache") (("" (expand "AllStar_preserves_NonDirtyCache" -1) (("" (expand-meaning -1) (("" (expand-meaning -1) (("" (inst -1 "w!1 WITH [(cs) := t!1]") (("" (inst -1 "mMetavariable!1") (("" (inst -1 "(w!1 WITH [(cs) := t!1])(cs)") (("" (expand-meaning -1) (("" (prop) (("1" (expand-meaning -1) (("1" (inst -1 "wPrime!1") (("1" (prop) (("1" (purify-fodl -1) (("1" (lemma "DirtySetFlush_leaves_DirtyCacheConsistent") (("1" (expand "DirtySetFlush_leaves_DirtyCacheConsistent" -1) (("1" (expand-meaning -1) (("1" (expand-meaning -1) (("1" (inst -1 "wPrime!1") (("1" (inst -1 "mMetavariable!1") (("1" (inst -1 "wPrime!1(cs)") (("1" (expand-meaning -1) (("1" (prop) (("1" (hide -2 -3 -4) (("1" (purify-fodl) nil nil)) nil) ("2" (hide -2 -3 2) (("2" (purify-fodl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (purify-fodl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((meaningF const-decl "PRED[World_]" FODL_semantic nil) (NonDirtyCache const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil) (Function_ type-decl nil FA_Language nil) (sigPredicate const-decl "[Predicate -> nat]" FA_Language nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate type-decl nil FA_Language nil) (Variable type-decl nil FA_Language nil) (Metavariable type-decl nil FA_Language nil) (Constant type-decl nil FA_Language nil) (wf_F const-decl "[[f: Function_,
  {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] ->
   wf_Term_]" wf_FODL_Language nil) (wf_P const-decl "[[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] ->
   wf_Formula_]" wf_FODL_Language nil) (nth def-decl "T" list_props nil) (mPredicate const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FA_semantic nil) (mFunction_ const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FA_semantic nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant const-decl "[Constant -> Carrier]" FA_semantic nil) (mTypePred const-decl "[TypePred -> [Carrier -> bool]]" FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (TPVariable const-decl "[Variable -> TypePred]" FA_semantic nil) (TPMetavariable const-decl "[Metavariable -> TypePred]" FA_semantic nil) (TypePred type-decl nil FA_semantic nil) (mTerm def-decl "Carrier" FODL_semantic nil) (map adt-def-decl "list[T1]" list_adt_map nil) (FODL_Language type-decl nil FODL_Language_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (wf_Term_ type-eq-decl nil wf_FODL_Language nil) (DirtyCacheConsistent const-decl "[wf_Term_ -> wf_Formula_]" SpecPredicates nil) (v adt-constructor-decl "[Variable -> (v?)]" FODL_Language_adt nil) (cs? adt-recognizer-decl "[Variable -> boolean]" FA_Language nil) (cs adt-constructor-decl "(cs?)" FA_Language nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (* adt-constructor-decl "[Program_ -> (ITERATION?)]" FODL_Language_adt nil) (+ adt-constructor-decl "[[Program_, Program_] -> (CHOICE?)]" FODL_Language_adt nil) (DirtyCacheWrite const-decl "[(v?) -> wf_Program_]" SpecActions nil) (DirtyFlush const-decl "[(v?) -> wf_Program_]" SpecActions nil) (DirtyLoad const-decl "[(v?) -> wf_Program_]" SpecActions nil) (DirtySetFlush const-decl "[(v?) -> wf_Program_]" SpecActions nil) (World_ type-eq-decl nil FODL_semantic nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (AllStar_preserves_NonDirtyCache formula-decl nil SpecProperties nil) (DirtySetFlush_leaves_DirtyCacheConsistent const-decl "wf_Formula_" SpecProperties nil) (post_DirtySetFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (pre_DirtySetFlush const-decl "[(v?) -> wf_Formula_]" SpecActions nil) (DirtySetFlush_leaves_DirtyCacheConsistent formula-decl nil SpecProperties nil) (AllStar_preserves_NonDirtyCache const-decl "wf_Formula_" SpecProperties nil) (PDL_4_box_form formula-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (Consistency_criteria const-decl "wf_Formula_" SpecProperties nil)) 11585 9720 nil nil)))

$$$RTC.pvs
RTC[T: TYPE]: THEORY

  BEGIN

    RTC(P: PRED[[T, T]])(tp: [T, T]): INDUCTIVE bool = 
             tp`1 = tp`2 OR EXISTS (t: T): RTC(P)(tp`1, t) AND P(t, tp`2)

  END RTC

$$$list_max.pvs
list_max: THEORY

  BEGIN

    max(l: list[nat]): RECURSIVE nat =
      IF null?(l) THEN 0 ELSE max(car(l), max(cdr(l))) ENDIF
       MEASURE length

  END list_max

$$$list_max.prf
(|list_max| (|max_TCC1| "" (SUBTYPE-TCC) NIL NIL)
 (|max_TCC2| "" (TERMINATION-TCC) NIL NIL))


$$$FODL_Language.pvs
FODL_Language[Constant: TYPE, 
              Metavariable: TYPE, 
              Variable: TYPE,
              Predicate: TYPE, sigPredicate: [Predicate -> nat], 
              Function_: TYPE, sigFunction_: [Function_ -> nat]]: 
        DATATYPE WITH SUBTYPES Term_, Formula_, Program_

  BEGIN

    c(c: Constant): c?: Term_
    m(m: Metavariable): m?: Term_
    v(v: Variable): v?: Term_
    F(f: Function_, lF:
      {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}): F?: Term_
    TRUE: TRUE?: Formula_
    FALSE: FALSE?: Formula_
    NOT(f: Formula_): NOT?: Formula_
    IMPLIES(f_0, f_1: Formula_): IMPLIES?: Formula_
    OR(f_0, f_1: Formula_): OR?: Formula_
    AND(f_0, f_1: Formula_): AND?: Formula_
    IFF(f_0, f_1: Formula_): IFF?: Formula_
    P(p: Predicate, lP:
      {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}): P?: Formula_
    =(t_0: Term_, t_1: Term_): EQ?: Formula_
    EXISTS_(x: (v?), f: Formula_): EXISTS?: Formula_
    FORALL_(x: (v?), f: Formula_): FORALL?: Formula_
    <>(P: Program_, f: Formula_): DIAMOND?: Formula_
    [](P: Program_, f: Formula_): BOX?: Formula_
    T?(f: Formula_): T??: Program_
    A(pre_post: [Formula_, Formula_]): A?: Program_
    SKIP: SKIP?: Program_
    <|(x: (v?), t: Term_): ASSIGNMENT?: Program_
    //(P_0, P_1: Program_): COMPOSITION?: Program_
    +(P_0, P_1: Program_): CHOICE?: Program_
    *(P: Program_): ITERATION?: Program_
 
  END FODL_Language

$$$wf_FODL_Language.pvs
wf_FODL_Language[Constant: TYPE, 
                 Metavariable: TYPE, 
                 Variable: TYPE, 
                 Predicate: TYPE, sigPredicate: [Predicate -> nat], 
                 Function_: TYPE, sigFunction_: [Function_ -> nat]]: THEORY

  BEGIN

    IMPORTING FODL_Language_adt[Constant, 
                                Metavariable, 
                                Variable, 
                                Predicate, sigPredicate, 
                                Function_, sigFunction_],
              list_max

    complexity(l: FODL_Language): nat =
        reduce_nat(LAMBDA (c: Constant): 0, 
                   LAMBDA (m: Metavariable): 0,
                   LAMBDA (v: Variable): 0,
                   LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 
                   0, 
                   0,
                   LAMBDA (n: nat): n + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (p: Predicate, l: list[nat]): 1 + max(l),
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat): n + 1,
                   LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2,
                   0, 
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1,
                   LAMBDA (n: nat, m: nat): n + m + 1, 
                   LAMBDA (n: nat): n + 1)(l)

    no_metavariable(l: FODL_Language): RECURSIVE boolean =
      CASES l
        OF c(c_var): TRUE,
           m(m_var): FALSE,
           v(v_var): TRUE,
           F(f_var, list_var): every(no_metavariable)(list_var),
           TRUE: TRUE,
           FALSE: TRUE,
           NOT(f_var): no_metavariable(f_var),
           IMPLIES(f1_var, f2_var):
             no_metavariable(f1_var) AND no_metavariable(f2_var),
           OR(f1_var, f2_var):
             no_metavariable(f1_var) AND no_metavariable(f2_var),
           AND(f1_var, f2_var):
             no_metavariable(f1_var) AND no_metavariable(f2_var),
           IFF(f1_var, f2_var):
             no_metavariable(f1_var) AND no_metavariable(f2_var),
           P(pred_var, list_var): every(no_metavariable)(list_var),
           =(t0_var, t1_var):
             no_metavariable(t0_var) AND no_metavariable(t1_var),
           EXISTS_(var_var, f_var): no_metavariable(f_var),
           FORALL_(var_var, f_var): no_metavariable(f_var),
           <>(P_var, f_var): no_metavariable(P_var),
           [](P_var, f_var): no_metavariable(P_var),
           T?(f_var): no_metavariable(f_var),
           A(pp): TRUE,
           SKIP: TRUE,
           <|(var_var, term_var): no_metavariable(term_var),
           //(P1_var, P2_var):
             no_metavariable(P1_var) AND no_metavariable(P2_var),
           +(P1_var, P2_var):
             no_metavariable(P1_var) AND no_metavariable(P2_var),
           *(P_var): no_metavariable(P_var)
        ENDCASES
      MEASURE complexity

    wf(l: FODL_Language): RECURSIVE boolean =
      CASES l
        OF c(c_var): TRUE,
           m(m_var): TRUE,
           v(v_var): TRUE,
           F(f_var, list_var): every(wf)(list_var),
           TRUE: TRUE,
           FALSE: TRUE,
           NOT(f_var): wf(f_var),
           IMPLIES(f1_var, f2_var): wf(f1_var) AND wf(f2_var),
           OR(f1_var, f2_var): wf(f1_var) AND wf(f2_var),
           AND(f1_var, f2_var): wf(f1_var) AND wf(f2_var),
           IFF(f1_var, f2_var): wf(f1_var) AND wf(f2_var),
           P(pred_var, list_var): every(wf)(list_var),
           =(t0_var, t1_var): wf(t0_var) AND wf(t1_var),
           EXISTS_(var_var, f_var): wf(f_var),
           FORALL_(var_var, f_var): wf(f_var),
           <>(P_var, f_var):
             (wf(P_var) AND no_metavariable(P_var)) AND wf(f_var),
           [](P_var, f_var):
             (wf(P_var) AND no_metavariable(P_var)) AND wf(f_var),
           T?(f_var): wf(f_var) AND no_metavariable(f_var),
           A(pp): wf(pp`1) AND wf(pp`2),
           SKIP: TRUE,
           <|(var_var, term_var): wf(term_var) AND no_metavariable(term_var),
           //(P1_var, P2_var):
             (wf(P1_var) AND no_metavariable(P1_var)) AND
             (wf(P2_var) AND no_metavariable(P2_var)),
           +(P1_var, P2_var):
             (wf(P1_var) AND no_metavariable(P1_var)) AND
             (wf(P2_var) AND no_metavariable(P2_var)),
           *(P_var): wf(P_var) AND no_metavariable(P_var)
        ENDCASES
      MEASURE complexity

    wf_Term_: TYPE = {t: Term_ | wf(t)}
    wf_Formula_: TYPE = {f: Formula_ | wf(f)}
    wf_Program_: TYPE = {P: Program_ | wf(P)}
    wf_FODL_Language: TYPE = {l: FODL_Language | wf(l)}

    % Judgements about lists of wf_Term_
    list_wf_Term_null: JUDGEMENT
         null HAS_TYPE list[wf_Term_]
    list_wf_Term_cons: JUDGEMENT
         cons(t: wf_Term_, l: list[wf_Term_]) HAS_TYPE list[wf_Term_]
    % Judgements about wf_Term_ type
    wf_Term_Constant: JUDGEMENT
         c(c: Constant) HAS_TYPE wf_Term_
    wf_Term_Constant_type: JUDGEMENT
         (c?) SUBTYPE_OF wf_Term_
    wf_Term_Metavariable: JUDGEMENT
         m(m: Metavariable) HAS_TYPE wf_Term_
    wf_Term_Metavariable_type: JUDGEMENT
         (m?) SUBTYPE_OF wf_Term_
    wf_Term_Variable: JUDGEMENT
         v(v: Variable) HAS_TYPE wf_Term_
    wf_Term_Variable_type: JUDGEMENT
         (v?) SUBTYPE_OF wf_Term_
    wf_Term_FunctionApp: JUDGEMENT
         F(f: Function_, l: {l: list[wf_Term_] | length(l) = sigFunction_(f)}) HAS_TYPE wf_Term_
    % Judgements about wf_Formula_ type
    wf_Formula_TRUE: JUDGEMENT
         TRUE HAS_TYPE wf_Formula_
    wf_Formula_FALSE: JUDGEMENT
         FALSE HAS_TYPE wf_Formula_
    wf_Formula_NOT: JUDGEMENT
         NOT(f: wf_Formula_) HAS_TYPE wf_Formula_
    wf_Formula_IMPLIES: JUDGEMENT
         IMPLIES(f_0, f_1: wf_Formula_) HAS_TYPE wf_Formula_
    wf_Formula_OR: JUDGEMENT
         OR(f_0, f_1: wf_Formula_) HAS_TYPE wf_Formula_
    wf_Formula_AND: JUDGEMENT
         AND(f_0, f_1: wf_Formula_) HAS_TYPE wf_Formula_
    wf_Formula_IFF: JUDGEMENT
         IFF(f_0, f_1: wf_Formula_) HAS_TYPE wf_Formula_
    wf_Formula_PredicateApp: JUDGEMENT
         P(p: Predicate, l: {l: list[wf_Term_] | length(l) = sigPredicate(p)}) HAS_TYPE wf_Formula_
    wf_Formula_EQ: JUDGEMENT
         =(t_0, t_1: wf_Term_) HAS_TYPE wf_Formula_
    wf_Formula_EXISTS_: JUDGEMENT
         EXISTS_(v: (v?), f: wf_Formula_) HAS_TYPE wf_Formula_
    wf_Formula_FORALL_: JUDGEMENT
         FORALL_(v: (v?), f: wf_Formula_) HAS_TYPE wf_Formula_
    wf_Formula_DIAMOND: JUDGEMENT
         <>(P: wf_Program_, f: wf_Formula_) HAS_TYPE wf_Formula_
    wf_Formula_BOX: JUDGEMENT
         [](P: wf_Program_, f: wf_Formula_) HAS_TYPE wf_Formula_
    % Judgements about wf_Program_ type
    wf_Program_T??: JUDGEMENT
         T?(f: {f: wf_Formula_ | no_metavariable(f)}) HAS_TYPE wf_Program_
    wf_Program_A: JUDGEMENT
         A(pre, post: wf_Formula_) HAS_TYPE wf_Program_
    wf_Program_SKIP: JUDGEMENT
         SKIP HAS_TYPE wf_Program_
    wf_Program_ASSIGNMENT: JUDGEMENT
         <|(v: (v?), t: {t: wf_Term_ | no_metavariable(t)}) HAS_TYPE wf_Program_
    wf_Program_COMPOSITION: JUDGEMENT
         //(P_0, P_1: wf_Program_) HAS_TYPE wf_Program_
    wf_Program_CHOICE: JUDGEMENT
         +(P_0, P_1: wf_Program_) HAS_TYPE wf_Program_
    wf_Program_ITERATION: JUDGEMENT
         *(P: wf_Program_) HAS_TYPE wf_Program_
    % Judgements about wf_FODL_Language type
    wf_FODL_Language_Term_: JUDGEMENT
         wf_Term_ SUBTYPE_OF wf_FODL_Language
    wf_FODL_Language_Formula_: JUDGEMENT
         wf_Formula_ SUBTYPE_OF wf_FODL_Language
    wf_FODL_Language_Program_: JUDGEMENT
         wf_Program_ SUBTYPE_OF wf_FODL_Language

    wf_P: [[p: Predicate, {l: list[wf_Term_] | length(l) = sigPredicate(p)}] -> wf_Formula_] =
         LAMBDA (p: Predicate, l: {l: list[wf_Term_] | length(l) = sigPredicate(p)}): P(p, l)
    wf_F: [[f: Function_, {lPrime: list[wf_Term_] | length(lPrime) = sigFunction_(f)}] -> wf_Term_] = 
         LAMBDA (f: Function_, l: {l: list[wf_Term_] | length(l) = sigFunction_(f)}): F(f, l)

  END wf_FODL_Language

$$$wf_FODL_Language.prf
(|wf_FODL_Language|
 (|no_metavariable_TCC1| "" (SKOLEM-TYPEPRED)
  (("" (FLATTEN)
    (("" (REPLACE -3)
      (("" (EXPAND "complexity" 1 2)
        (("" (EXPAND "reduce_nat")
          ((""
            (CASE "FORALL (l: list[FODL_Language]): every(LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(l)))(l)")
            (("1" (INST -1 "list_var!1")
              (("1" (EXPAND "complexity" -1 2)
                (("1"
                  (CASE-REPLACE "(LAMBDA (l: FODL_Language):
                          reduce_nat(LAMBDA (c: Constant): 0,
                                     LAMBDA (m: Metavariable): 0,
                                     LAMBDA (v: Variable): 0,
                                     LAMBDA
                                     (f: Function_, l: list[nat]):
                                     1 + max(l),
                                     0,
                                     0,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA
                                     (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA
                                     (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                     0,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n)
                                    (l)) = (reduce_nat(LAMBDA (c: Constant): 0,
                                   LAMBDA (m: Metavariable): 0,
                                   LAMBDA (v: Variable): 0,
                                   LAMBDA (f: Function_, l: list[nat]):
                                     1 + max(l),
                                   0, 0, LAMBDA (n: nat): 1 + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat): 1 + n,
                                   LAMBDA (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                   0, LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat): 1 + n))")
                  (("1" (HIDE-ALL-BUT 1)
                    (("1" (APPLY-EXTENSIONALITY) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (HIDE-ALL-BUT 1)
              (("2" (INDUCT "l")
                (("1" (GRIND) NIL NIL)
                 ("2" (SKOSIMP)
                  (("2" (EXPAND "every" +)
                    (("2" (ASSERT)
                      (("2" (EXPAND "map" 1 2)
                        (("2" (EXPAND "max" 1 2)
                          (("2" (SPLIT)
                            (("1" (EXPAND "max" +)
                              (("1" (EXPAND "map" +)
                                (("1" (EXPAND "max" 1 1)
                                  (("1" (ASSERT)
                                    (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2"
                              (CASE "FORALL (P, Q: PRED[FODL_Language]): (FORALL (x: FODL_Language): P(x) => Q(x)) => FORALL (l: list[FODL_Language]): every(P)(l) => every(Q)(l)")
                              (("1"
                                (INST -1
                                 "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons2_var!1))"
                                 "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons(cons1_var!1, cons2_var!1)))")
                                (("1" (PROP)
                                  (("1" (INST -1 "cons2_var!1")
                                    (("1" (PROP)
                                      (("1"
                                        (EXPAND "map" -1)
                                        (("1"
                                          (EXPAND "max" -1)
                                          (("1" (PROPAX) NIL NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (HIDE-ALL-BUT 1)
                                    (("2" (SKOSIMP)
                                      (("2"
                                        (EXPAND "map" 1)
                                        (("2"
                                          (EXPAND "max" 1)
                                          (("2" (ASSERT) NIL NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (HIDE-ALL-BUT 1)
                                (("2" (SKOSIMP)
                                  (("2" (INDUCT "l")
                                    (("1" (EXPAND "every")
                                      (("1" (PROPAX) NIL NIL)) NIL)
                                     ("2" (SKOSIMP*)
                                      (("2"
                                        (EXPAND "every" 1)
                                        (("2"
                                          (PROP)
                                          (("1"
                                            (INST -3 "cons1_var!2")
                                            (("1"
                                              (PROP)
                                              (("1"
                                                (EXPAND "every" -2)
                                                (("1" (PROP) NIL NIL))
                                                NIL))
                                              NIL))
                                            NIL)
                                           ("2"
                                            (EXPAND "every" -1)
                                            (("2" (PROP) NIL NIL))
                                            NIL)
                                           ("3"
                                            (EXPAND "every" -1)
                                            (("3" (PROP) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|no_metavariable_TCC2| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC3| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC4| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC5| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC6| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC7| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC8| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC9| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC10| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC11| "" (SKOSIMP*)
  (("" (REPLACE -1)
    (("" (HIDE -1)
      (("" (EXPAND "complexity" 1 2)
        (("" (EXPAND "reduce_nat")
          ((""
            (CASE "FORALL (l: list[FODL_Language]): every(LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(l)))(l)")
            (("1" (INST -1 "list_var!1")
              (("1" (EXPAND "complexity" -1 2)
                (("1"
                  (CASE-REPLACE "(LAMBDA (l: FODL_Language):
                          reduce_nat(LAMBDA (c: Constant): 0,
                                     LAMBDA (m: Metavariable): 0,
                                     LAMBDA (v: Variable): 0,
                                     LAMBDA
                                     (f: Function_, l: list[nat]):
                                     1 + max(l),
                                     0,
                                     0,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA
                                     (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA
                                     (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                     0,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n)
                                    (l)) = (reduce_nat(LAMBDA (c: Constant): 0,
                                   LAMBDA (m: Metavariable): 0,
                                   LAMBDA (v: Variable): 0,
                                   LAMBDA (f: Function_, l: list[nat]):
                                     1 + max(l),
                                   0, 0, LAMBDA (n: nat): 1 + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat): 1 + n,
                                   LAMBDA (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                   0, LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat, m: nat): 1 + m + n,
                                   LAMBDA (n: nat): 1 + n))")
                  (("1" (HIDE-ALL-BUT 1)
                    (("1" (APPLY-EXTENSIONALITY) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (HIDE-ALL-BUT 1)
              (("2" (INDUCT "l")
                (("1" (EXPAND "every") (("1" (PROPAX) NIL NIL)) NIL)
                 ("2" (SKOSIMP*)
                  (("2" (EXPAND "every" 1)
                    (("2" (PROP)
                      (("1" (EXPAND "map" 1)
                        (("1" (EXPAND "max" 1) (("1" (ASSERT) NIL NIL)) NIL))
                        NIL)
                       ("2"
                        (CASE "FORALL (P, Q: PRED[FODL_Language]): (FORALL (x: FODL_Language): P(x) => Q(x)) => FORALL (l: list[FODL_Language]): every(P)(l) => every(Q)(l)")
                        (("1"
                          (INST -1
                           "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons2_var!1))"
                           "LAMBDA (z: FODL_Language): complexity(z) < 1 + max(map(complexity)(cons(cons1_var!1, cons2_var!1)))")
                          (("1" (PROP)
                            (("1" (INST -1 "cons2_var!1")
                              (("1" (PROP) NIL NIL)) NIL)
                             ("2" (HIDE-ALL-BUT 1)
                              (("2" (SKOSIMP*)
                                (("2" (EXPAND "map" 1)
                                  (("2" (EXPAND "max" 1)
                                    (("2" (ASSERT) NIL NIL)) NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (HIDE-ALL-BUT 1)
                          (("2" (SKOSIMP)
                            (("2" (INDUCT "l")
                              (("1" (EXPAND "every" 1)
                                (("1" (PROPAX) NIL NIL)) NIL)
                               ("2" (SKOSIMP*)
                                (("2" (EXPAND "every" 1)
                                  (("2" (PROP)
                                    (("1" (EXPAND "every" -2)
                                      (("1"
                                        (PROP)
                                        (("1"
                                          (INST -4 "cons1_var!2")
                                          (("1" (PROP) NIL NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2" (EXPAND "every" -1)
                                      (("2" (PROP) NIL NIL)) NIL)
                                     ("3" (EXPAND "every" -1)
                                      (("3" (PROP) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|no_metavariable_TCC12| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC13| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC14| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC15| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC16| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC17| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC18| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC19| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC20| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC21| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC22| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC23| "" (TERMINATION-TCC) NIL NIL)
 (|no_metavariable_TCC24| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC1| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC2| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC3| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC4| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC5| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC6| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC7| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC8| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC9| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC10| "" (TERMINATION-TCC) NIL NIL)
 (|wf_TCC11| "" (TERMINATION-TCC) NIL NIL)
 (|wf_Term_Constant| "" (GRIND) NIL NIL)
 (|wf_Term_Constant_type| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1) (("" (PROPAX) NIL NIL)) NIL)) NIL)
 (|wf_Term_Metavariable| "" (GRIND) NIL NIL)
 (|wf_Term_Metavariable_type| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1) (("" (PROPAX) NIL NIL)) NIL)) NIL)
 (|wf_Term_Variable| "" (GRIND) NIL NIL)
 (|wf_Term_Variable_type| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1) (("" (PROPAX) NIL NIL)) NIL)) NIL)
 (|wf_Term_FunctionApp_TCC1| "" (SKOLEM-TYPEPRED)
  (("" (REPLACE -2 :DIR RL)
    (("" (HIDE -2)
      ((""
        (CASE "FORALL (l: list[wf_Term_]): length(l) = length[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]](l)")
        (("1" (INST?) NIL NIL)
         ("2" (HIDE-ALL-BUT 1)
          (("2" (INDUCT "l")
            (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)
             ("2" (SKOSIMP*)
              (("2" (EXPAND "length" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|wf_Term_FunctionApp| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1)
    ((""
      (CASE "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(LAMBDA (x: FODL_Language): P(x) AND Q(x))(l) IMPLIES every(Q)(l)")
      (("1" (INST?) (("1" (PROP) NIL NIL)) NIL)
       ("2" (HIDE-ALL-BUT 1)
        (("2" (SKOLEM!)
          (("2" (INDUCT "l")
            (("1" (EXPAND "every") (("1" (PROPAX) NIL NIL)) NIL)
             ("2" (SKOSIMP*)
              (("2" (PROP)
                (("1" (EXPAND "every" 1)
                  (("1" (EXPAND "every" -2) (("1" (PROP) NIL NIL)) NIL)) NIL)
                 ("2" (EXPAND "every" -1) (("2" (PROP) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|wf_Formula_TRUE| "" (GRIND) NIL NIL)
 (|wf_Formula_FALSE| "" (GRIND) NIL NIL) (|wf_Formula_NOT| "" (GRIND) NIL NIL)
 (|wf_Formula_IMPLIES| "" (GRIND) NIL NIL)
 (|wf_Formula_OR| "" (GRIND) NIL NIL) (|wf_Formula_AND| "" (GRIND) NIL NIL)
 (|wf_Formula_IFF| "" (GRIND) NIL NIL)
 (|wf_Formula_PredicateApp_TCC1| "" (SKOLEM-TYPEPRED)
  (("" (REPLACE -2 :DIR RL)
    (("" (HIDE -2)
      ((""
        (CASE "FORALL (l: list[wf_Term_]): length(l) = length[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]](l)")
        (("1" (INST?) NIL NIL)
         ("2" (HIDE-ALL-BUT 1)
          (("2" (INDUCT "l")
            (("1" (EXPAND "length") (("1" (PROPAX) NIL NIL)) NIL)
             ("2" (SKOSIMP*)
              (("2" (EXPAND "length" 1) (("2" (PROPAX) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|wf_Formula_PredicateApp| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1)
    ((""
      (CASE "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(LAMBDA (x: FODL_Language): P(x) AND Q(x))(l) IMPLIES every(Q)(l)")
      (("1" (INST?) (("1" (PROP) NIL NIL)) NIL)
       ("2" (HIDE-ALL-BUT 1)
        (("2" (SKOLEM!)
          (("2" (INDUCT "l")
            (("1" (EXPAND "every") (("1" (PROPAX) NIL NIL)) NIL)
             ("2" (SKOSIMP*)
              (("2" (PROP)
                (("1" (EXPAND "every" 1)
                  (("1" (EXPAND "every" -2) (("1" (PROP) NIL NIL)) NIL)) NIL)
                 ("2" (EXPAND "every" -1) (("2" (PROP) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|wf_Formula_EQ| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1) (("" (PROPAX) NIL NIL)) NIL)) NIL)
 (|wf_Formula_EXISTS_| "" (GRIND) NIL NIL)
 (|wf_Formula_FORALL_| "" (GRIND) NIL NIL)
 (|wf_Formula_DIAMOND| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1)
    (("" (HIDE -3 -4)
      (("" (SMASH)
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
         ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL)
         ("7" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|wf_Formula_BOX| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1)
    (("" (HIDE -3 -4)
      (("" (SMASH)
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
         ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL)
         ("7" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|wf_Program_T??| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1) (("" (PROPAX) NIL NIL)) NIL)) NIL)
 (|wf_Program_A| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1) (("" (PROPAX) NIL NIL)) NIL)) NIL)
 (|wf_Program_SKIP| "" (GRIND) NIL NIL)
 (|wf_Program_ASSIGNMENT| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1) (("" (PROPAX) NIL NIL)) NIL)) NIL)
 (|wf_Program_COMPOSITION| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1)
    (("" (SPLIT 1)
      (("1" (HIDE -3 -4)
        (("1" (SMASH)
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
           ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL)
           ("7" (GRIND) NIL NIL))
          NIL))
        NIL)
       ("2" (HIDE -1 -2)
        (("2" (SMASH)
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
           ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL)
           ("7" (GRIND) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|wf_Program_CHOICE| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1)
    (("" (SPLIT 1)
      (("1" (HIDE -3 -4)
        (("1" (SMASH)
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
           ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL)
           ("7" (GRIND) NIL NIL))
          NIL))
        NIL)
       ("2" (HIDE -1 -2)
        (("2" (SMASH)
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
           ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL)
           ("7" (GRIND) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (|wf_Program_ITERATION| "" (SKOLEM-TYPEPRED)
  (("" (EXPAND "wf" 1)
    (("" (SMASH)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
       ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL)
       ("7" (GRIND) NIL NIL))
      NIL))
    NIL))
  NIL))


$$$FODL_semantic.pvs
FODL_semantic[Constant: TYPE, 
              Metavariable: TYPE, 
              Variable: TYPE,
              Predicate: TYPE, sigPredicate: [Predicate -> nat], 
              Function_: TYPE, sigFunction_: [Function_ -> nat],
              TypePred: TYPE,
              TPMetavariable: [Metavariable -> TypePred], 
              TPVariable: [Variable -> TypePred],
              Carrier: TYPE+,
              mTypePred: [TypePred -> [Carrier -> bool]], 
              mConstant: [Constant -> Carrier], 
              mPredicate: [P: Predicate -> 
                             [{l: list[Carrier] | sigPredicate(P) = length(l)} -> 
                                bool]],
              mFunction_: [F: Function_ ->
                             [{l: list[Carrier] | sigFunction_(F) = length(l)} ->
                                Carrier]]]: THEORY

  BEGIN

    ASSUMING
      non_empty_types: ASSUMPTION
         FORALL (t: TypePred): EXISTS (c: (mTypePred(t))): TRUE 
    ENDASSUMING

    IMPORTING wf_FODL_Language[Constant,
                               Metavariable,
                               Variable,
                               Predicate, sigPredicate,
                               Function_, sigFunction_], 
              list_max

    World_: TYPE = [v: Variable -> (mTypePred(TPVariable(v)))]
    anyWorld_: World_ = 
       LAMBDA (v: Variable): epsilon({c: (mTypePred(TPVariable(v))) | TRUE})

    IMPORTING RTC[World_]

    AssMetavariable: TYPE = [m: Metavariable -> (mTypePred(TPMetavariable(m)))]
    anyAssMetavariable: AssMetavariable = 
       LAMBDA (m: Metavariable): epsilon({c: (mTypePred(TPMetavariable(m))) | TRUE})

    mTerm(mMetavariable: AssMetavariable, w: World_)(t: wf_Term_):
        RECURSIVE Carrier =
      CASES t
        OF c(c_var): mConstant(c_var),
           m(m_var): mMetavariable(m_var),
           v(v_var): w(v_var),
           F(f_var, list_var):
             mFunction_(f_var)(map(mTerm(mMetavariable, w))(list_var))
        ENDCASES
      MEASURE complexity(t)

    m(mMetavariable: AssMetavariable)(l: union[wf_Formula_, wf_Program_]):
        RECURSIVE {u: union[PRED[World_], PRED[[World_, World_]]] |
           CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES} =
      CASES l
        OF inl(f):
             CASES f
               OF TRUE: inl({w: World_ | TRUE}),
                  FALSE: inl({w: World_ | FALSE}),
                  NOT(f_var):
                    inl({w: World_ |
                           NOT left(m(mMetavariable)(inl(f_var)))(w)}),
                  IMPLIES(f1_var, f2_var):
                    inl({w: World_ |
                           left(m(mMetavariable)(inl(f1_var)))(w) IMPLIES
                           left(m(mMetavariable)(inl(f2_var)))(w)}),
                  OR(f1_var, f2_var):
                    inl({w: World_ |
                           left(m(mMetavariable)(inl(f1_var)))(w) OR
                           left(m(mMetavariable)(inl(f2_var)))(w)}),
                  AND(f1_var, f2_var):
                    inl({w: World_ |
                           left(m(mMetavariable)(inl(f1_var)))(w) AND
                           left(m(mMetavariable)(inl(f2_var)))(w)}),
                  IFF(f1_var, f2_var):
                    inl({w: World_ |
                           left(m(mMetavariable)(inl(f1_var)))(w) IFF
                           left(m(mMetavariable)(inl(f2_var)))(w)}),
                  P(pred_var, list_var):
                    inl({w: World_ |
                           mPredicate(pred_var)
                                   (map(mTerm(mMetavariable, w))(list_var))}),
                  =(t0_var, t1_var):
                    inl({w: World_ |
                           mTerm(mMetavariable, w)(t0_var) =
                           mTerm(mMetavariable, w)(t1_var)}),
                  EXISTS_(var_var, f_var):
                    inl({w: World_ |
                           EXISTS (t: (mTypePred(TPVariable(v(var_var))))):
                             left(m(mMetavariable)(inl(f_var)))
                                (w WITH [(v(var_var)) := t])}),
                  FORALL_(var_var, f_var):
                    inl({w: World_ |
                           FORALL (t: (mTypePred(TPVariable(v(var_var))))):
                             left(m(mMetavariable)(inl(f_var)))
                                (w WITH [(v(var_var)) := t])}),
                  <>(P_var, f_var):
                    inl({w: World_ |
                           EXISTS (wPrime: World_):
                             right(m(mMetavariable)(inr(P_var)))(w, wPrime)
                              AND
                             left(m(mMetavariable)(inl(f_var)))(wPrime)}),
                  [](P_var, f_var):
                    inl({w: World_ |
                           FORALL (wPrime: World_):
                             right(m(mMetavariable)(inr(P_var)))(w, wPrime)
                              IMPLIES
                             left(m(mMetavariable)(inl(f_var)))(wPrime)})
               ENDCASES,
           inr(P):
             CASES P
               OF T?(f_var):
                    inr({wp: [World_, World_] |
                          wp`1 = wp`2 AND
                          left(m(mMetavariable)(inl(f_var)))(wp`1)}),
                  A(pp):
                    inr({wp: [World_, World_] |
                         FORALL (mMetavariable: AssMetavariable):
                           left(m(mMetavariable)(inl(pp`1)))(wp`1) IMPLIES
                           left(m(mMetavariable)(inl(pp`2)))(wp`2)}),
                  SKIP: inr({wp: [World_, World_] | wp`1 = wp`2}),
                  <|(var_var, term_var):
                    inr({wp: [World_, World_] |
                          wp`2 = wp`1 WITH [(v(var_var)) := 
                                IF mTypePred(TPVariable(v(var_var)))(mTerm(mMetavariable, wp`1)(term_var))
                                  THEN mTerm(mMetavariable, wp`1)(term_var) 
                                  ELSE wp`1(v(var_var)) 
                                ENDIF]}),
                  //(P1_var, P2_var):
                    inr({wp: [World_, World_] |
                         EXISTS (w: World_):
                           right(m(mMetavariable)(inr(P1_var)))(wp`1, w)
                            AND
                           right(m(mMetavariable)(inr(P2_var)))(w, wp`2)}),
                  +(P1_var, P2_var):
                    inr({wp: [World_, World_] |
                         right(m(mMetavariable)(inr(P1_var)))(wp) OR
                         right(m(mMetavariable)(inr(P2_var)))(wp)}),
                  *(P_var):
                    inr({w: [World_, World_] |
                         (LAMBDA (x: [World_, World_]):
                            mu[[World_, World_]]
                                (LAMBDA (p: PRED[[World_, World_]]):
                                   {wp: [World_, World_] | 
                                     ({wpPrime: [World_, World_] | wpPrime`1 = wpPrime`2})(wp)
                                       OR
                                     ({wpPrime: [World_, World_] |
                                         EXISTS (w: World_):
                                           right(m(mMetavariable)(inr(P_var)))(wpPrime`1, w)
                                       AND
                                     p(w, wpPrime`2)})
                                   (wp)})
                                (x))
                             (w)})
               ENDCASES
        ENDCASES
      MEASURE complexity(CASES l OF inl(f): f, inr(P): P ENDCASES)

    meaningF(f: wf_Formula_): PRED[World_] =
      {w: World_ | FORALL (mMetavariable: AssMetavariable): left(m(mMetavariable)(inl(f)))(w)}
 
  END FODL_semantic

$$$FODL_semantic.prf
(FODL_semantic (anyWorld__TCC1 0 (anyWorld__TCC1-1 nil 3292689001 3292689529 ("" (skosimp*) (("" (use "non_empty_types") nil nil)) nil) proved ((TypePred formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_semantic nil) (non_empty_types formula-decl nil FODL_semantic nil)) 46 40 nil nil)) (anyAssMetavariable_TCC1 0 (anyAssMetavariable_TCC1-1 nil 3292689001 3292689529 ("" (skosimp*) (("" (use "non_empty_types") nil nil)) nil) proved ((TypePred formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_semantic nil) (non_empty_types formula-decl nil FODL_semantic nil)) 19 10 nil nil)) (mTerm_TCC1 0 (mTerm_TCC1-1 nil 3292689001 3292689533 ("" (skolem-typepred) (("" (flatten) (("" (replace -5) (("" (hide -2 -3 -5) (("" (expand "wf" -2) (("" (case "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (x: FODL_Language): P(x) AND Q(x) AND R(x))(l)") (("1" (inst?) (("1" (prop) (("1" (hide-all-but 1) (("1" (expand "complexity") (("1" (expand "reduce_nat" 1 2) (("1" (case-replace "complexity = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (case "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(l)))(l)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (induct "l") (("1" (expand "every") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (expand "every" 1) (("2" (prop) (("1" (expand "map" 1) (("1" (expand "max" 1) (("1" (expand "max" 1 1) (("1" (smash) nil nil)) nil)) nil)) nil) ("2" (expand "map" 1) (("2" (expand "max" 1) (("2" (expand "max" 1 1) (("2" (smash) (("2" (case "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1)))(l) AND complexity(cons1_var!1) >= max(map(complexity)(cons2_var!1)) IMPLIES every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1))(l)") (("1" (inst?) (("1" (prop) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "every" 1) (("1" (prop) (("1" (expand "every" -2) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "complexity") (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "every" 1) (("1" (expand "every" -2) (("1" (expand "every" -3) (("1" (expand "every" -4) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -2) (("3" (prop) nil nil)) nil) ("4" (expand "every" -3) (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (max def-decl "nat" list_max nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (list_induction formula-decl nil list_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (< const-decl "bool" reals nil) (complexity const-decl "nat" wf_FODL_Language nil) (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil) (wf_Term_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 4073 3620 nil nil)) (mTerm_TCC2 0 (mTerm_TCC2-1 nil 3292689002 3292689571 ("" (skolem-typepred) (("" (flatten) (("" (replace -2) (("" (hide -2) (("" (same-name "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}, Carrier]" "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < 1 + max(map(complexity)(list_var!1))}, Carrier]" "[[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)} -> Carrier] -> [list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}] -> list[Carrier]]]") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (l: list[wf_Term_]): (FORALL (lPrime: list[{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))}]): FORALL (f: [{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))} -> Carrier]): length(lPrime)=length(map(f)(lPrime)))") (("1" (inst?) (("1" (hide -2 -3 -4 -5) (("1" (case "list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(list_var!1) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(list_var!1))}].length(list_var!1)") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "FORALL (lPrime: list[wf_FODL_Language]): FORALL (l: list[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}]): list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(l) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}].length(l)") (("1" (inst?) (("1" (hide-all-but 1) (("1" (case "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t) AND R(t))(l)") (("1" (inst -1 "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)" "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)" "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) < 1 + max(map[FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], nat](complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_])(list_var!1))") (("1" (inst?) (("1" (prop) (("1" (hide-all-but 1) (("1" (typepred "list_var!1") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (expand "wf" -2) (("2" (reveal -9) (("2" (smash) (("2" (replace -1) (("2" (smash) (("2" (hide -1 -2) (("2" (case-replace "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]") (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (case "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(l)))(l)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (induct "l") (("1" (expand "every" 1) (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (expand "every" 1) (("2" (expand "map" 1) (("2" (expand "max" 1) (("2" (prop) (("1" (smash) nil nil) ("2" (expand "max" 1 1) (("2" (case "complexity(cons1_var!1) < max(map(complexity)(cons2_var!1))") (("1" (smash) nil nil) ("2" (smash) (("2" (case "FORALL (P, Q: PRED[FODL_Language]): (FORALL (l: FODL_Language): P(l) IMPLIES Q(l)) IMPLIES (FORALL (l: list[FODL_Language]): every(P)(l) IMPLIES every(Q)(l))") (("1" (inst -1 "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1))" "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1)") (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (skosimp*) (("2" (smash) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (prop) (("2" (induct "l") (("1" (expand "every" 1) (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (expand "every" 1) (("2" (prop) (("1" (expand "every" -2) (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -1) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "every" 1) (("1" (prop) (("1" (expand "every" -2) (("1" (prop) nil nil)) nil) ("2" (expand "every" -3) (("2" (prop) nil nil)) nil) ("3" (expand "every" -4) (("3" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -2) (("3" (prop) nil nil)) nil) ("4" (expand "every" -3) (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (reveal -6) (("2" (replace -1) (("2" (expand "wf" -3) (("2" (hide -1 -2) (("2" (case-replace "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]") (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (induct "l") (("1" (expand "length") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (expand "length" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (case "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t) AND R(t))(l)") (("1" (inst -1 "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)" "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)" "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) < 1 + max(map[FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], nat](complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_])(list_var!1))") (("1" (inst?) (("1" (prop) (("1" (hide-all-but 1) (("1" (typepred "list_var!1") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "t!1") (("2" (reveal -7) (("2" (replace -1) (("2" (hide -1) (("2" (expand "wf" -2) (("2" (case-replace "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf") (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (case "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 +max(map(complexity)(l)))(l)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (induct "l") (("1" (expand "every" 1) (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (expand "every" 1) (("2" (expand "map" 1) (("2" (expand "max" 1) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "max" 1 1) (("2" (case "complexity(cons1_var!1) < max(map(complexity)(cons2_var!1))") (("1" (smash) nil nil) ("2" (smash) (("2" (case "FORALL (P, Q: PRED[FODL_Language]): (FORALL (l: FODL_Language): P(l) IMPLIES Q(l)) IMPLIES (FORALL (l: list[FODL_Language]): every(P)(l) IMPLIES every(Q)(l))") (("1" (inst -1 "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1))" "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1)") (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (skosimp*) (("2" (smash) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (prop) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skolem!) (("2" (prop) (("1" (expand "every" 1) (("1" (prop) (("1" (expand "every" -2) (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "every" 1) (("1" (prop) (("1" (expand "every" -2) (("1" (prop) nil nil)) nil) ("2" (expand "every" -3) (("2" (prop) nil nil)) nil) ("3" (expand "every" -4) (("3" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -2) (("3" (prop) nil nil)) nil) ("4" (expand "every" -3) (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (hide-all-but 1) (("2" (skosimp*) (("2" (expand "complexity" 1 2) (("2" (expand "reduce_nat") (("2" (expand "complexity" 1 3) (("2" (case-replace "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n,LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)") (("1" (prop) nil nil) ("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "wf" -3) (("3" (smash) (("3" (hide -2) (("3" (replace -3) (("3" (hide -3) (("3" (smash) (("3" (case "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t) AND R(t))(l)") (("1" (inst -1 "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR  m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)" "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)" "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) < 1 + max(map[FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], nat](complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_])(list_var!1))") (("1" (inst?) (("1" (prop) (("1" (hide 2) (("1" (case-replace "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]") (("1" (apply-extensionality) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (case "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(l)))(l)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (induct "l") (("1" (expand "map" 1) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "every" 1) (("2" (prop) (("1" (expand "map" 1) (("1" (expand "max" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "map" 1) (("2" (expand "max" 1) (("2" (expand "max" 1 1) (("2" (case "complexity(cons1_var!1) < max(map(complexity)(cons2_var!1))") (("1" (smash) nil nil) ("2" (smash) (("2" (case "FORALL (P, Q: PRED[FODL_Language]): (FORALL (l: FODL_Language): P(l) IMPLIES Q(l)) IMPLIES (FORALL (l: list[FODL_Language]): every(P)(l) IMPLIES every(Q)(l))") (("1" (inst -1 "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1))" "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1)") (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (prop) (("2" (induct "l") (("1" (expand "every" 1) (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (expand "every" 1) (("2" (prop) (("1" (inst?) (("1" (prop) (("1" (expand "every" -2) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -1) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide-all-but 1) (("2" (skolem!) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "every" 1) (("1" (prop) (("1" (expand "every" -2) (("1" (prop) nil nil)) nil) ("2" (expand "every" -3) (("2" (prop) nil nil)) nil) ("3" (expand "every" -4) (("3" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -2) (("3" (prop) nil nil)) nil) ("4" (expand "every" -3) (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (expand "wf" -3) (("4" (smash) (("4" (replace -4) (("4" (smash) (("4" (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)") (("1" (inst -1 "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)" "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)") (("1" (inst?) (("1" (prop) (("1" (hide 2) (("1" (case-replace "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf") (("1" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "every" 1) (("1" (prop) (("1" (expand "every" -2) (("1" (prop) nil nil)) nil) ("2" (expand "every" -3) (("2" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -2) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem!) (("2" (induct "lPrime") (("1" (skosimp*) (("1" (expand "map" 1) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "map" 1) (("2" (expand "length" 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4) (("2" (hide-all-but 1) (("2" (skosimp*) (("2" (expand "complexity" 1 2) (("2" (expand "reduce_nat") (("2" (expand "complexity" 1 3) (("2" (case-replace "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)") (("1" (prop) nil nil) ("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -4) (("3" (hide-all-but 1) (("3" (prop) (("1" (skosimp*) (("1" (expand "complexity" 1 4) (("1" (expand "reduce_nat") (("1" (expand "complexity" 1 2) (("1" (case-replace "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)") (("1" (prop) nil nil) ("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "complexity" 1 4) (("2" (expand "reduce_nat") (("2" (expand "complexity" 1 2) (("2" (case-replace "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)") (("1" (prop) nil nil) ("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (list_induction formula-decl nil list_adt nil) (wf_FODL_Language type-eq-decl nil wf_FODL_Language nil) (World_ type-eq-decl nil FODL_semantic nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_semantic nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_semantic nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_semantic nil) (TypePred formal-type-decl nil FODL_semantic nil) (t!1 skolem-const-decl "wf_Term_
    [Constant, Metavariable, Variable, Predicate, sigPredicate, Function_,
     sigFunction_]" FODL_semantic nil) (list_var!1 skolem-const-decl "{lPrime:
   list
       [Term_
            [Constant, Metavariable, Variable, Predicate, sigPredicate,
             Function_, sigFunction_]] |
         sigFunction_(f_var!1) =
          length
              [Term_
                   [Constant, Metavariable, Variable, Predicate,
                    sigPredicate, Function_, sigFunction_]]
              (lPrime)}" FODL_semantic nil) (f_var!1 skolem-const-decl "Function_" FODL_semantic nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (complexity const-decl "nat" wf_FODL_Language nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (max def-decl "nat" list_max nil) (map adt-def-decl "list[T1]" list_adt_map nil) (Carrier formal-nonempty-type-decl nil FODL_semantic nil) (wf_Term_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 38395 19340 nil nil)) (mTerm_TCC3 0 (mTerm_TCC3-1 nil 3292689002 3292689573 ("" (cases-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Term_ type-eq-decl nil wf_FODL_Language nil)) 1526 1430 nil nil)) (m_TCC1 0 (m_TCC1-1 nil 3292689002 3292689574 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 891 780 nil nil)) (m_TCC2 0 (m_TCC2-1 nil 3292689002 3292689575 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 863 770 nil nil)) (m_TCC3 0 (m_TCC3-1 nil 3292689002 3292689575 ("" (skolem-typepred) (("" (flatten) (("" (replace -6 -5) (("" (replace -5 -4) (("" (expand "every" -4) (("" (expand "wf" -4) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 471 450 nil nil)) (m_TCC4 0 (m_TCC4-1 nil 3292689002 3292689579 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 3700 3540 nil nil)) (m_TCC5 0 (m_TCC5-1 nil 3292689002 3292689580 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 1159 1060 nil nil)) (m_TCC6 0 (m_TCC6-1 nil 3292689002 3292689581 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 448 420 nil nil)) (m_TCC7 0 (m_TCC7-1 nil 3292689002 3292689586 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 4986 3780 nil nil)) (m_TCC8 0 (m_TCC8-1 nil 3292689002 3292689586 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 477 450 nil nil)) (m_TCC9 0 (m_TCC9-1 nil 3292689002 3292689590 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 4069 3870 nil nil)) (m_TCC10 0 (m_TCC10-1 nil 3292689002 3292689592 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 1364 1280 nil nil)) (m_TCC11 0 (m_TCC11-1 nil 3292689002 3292689592 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 453 420 nil nil)) (m_TCC12 0 (m_TCC12-1 nil 3292689002 3292689613 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 21193 3780 nil nil)) (m_TCC13 0 (m_TCC13-1 nil 3292689002 3292689614 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 791 460 nil nil)) (m_TCC14 0 (m_TCC14-1 nil 3292689002 3292689618 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 4167 3890 nil nil)) (m_TCC15 0 (m_TCC15-1 nil 3292689002 3292689620 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 1374 1270 nil nil)) (m_TCC16 0 (m_TCC16-1 nil 3292689002 3292689620 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 446 420 nil nil)) (m_TCC17 0 (m_TCC17-1 nil 3292689002 3292689625 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 4209 3770 nil nil)) (m_TCC18 0 (m_TCC18-1 nil 3292689002 3292689625 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 484 450 nil nil)) (m_TCC19 0 (m_TCC19-1 nil 3292689002 3292689629 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 4323 3910 nil nil)) (m_TCC20 0 (m_TCC20-1 nil 3292689002 3292689631 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 1398 1280 nil nil)) (m_TCC21 0 (m_TCC21-1 nil 3292689002 3292689631 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 455 410 nil nil)) (m_TCC22 0 (m_TCC22-1 nil 3292689002 3292689636 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 4346 3800 nil nil)) (m_TCC23 0 (m_TCC23-1 nil 3292689002 3292689636 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 441 410 nil nil)) (m_TCC24 0 (m_TCC24-1 nil 3292689002 3292689657 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 21105 3790 nil nil)) (m_TCC25 0 (m_TCC25-1 nil 3292689002 3292689659 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 1358 1270 nil nil)) (m_TCC26 0 (m_TCC26-1 nil 3292689002 3292689660 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): (every(P)(l) AND every(Q)(l)) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "every" 1) (("1" (expand "every" -2) (("1" (expand "every" -3) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -2) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((list_induction formula-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 1409 1310 nil nil)) (m_TCC27 0 (m_TCC27-1 nil 3292689002 3292689662 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -4 1) (("" (case "FORALL (l: list[wf_Term_]): FORALL (f: [wf_Term_ -> Carrier]): length[Term_](l) = length[Carrier](map[wf_Term_, Carrier](f)(l))") (("1" (inst?) (("1" (hide 2) (("1" (replace -7 -6) (("1" (replace -6 -5) (("1" (expand "every" -5) (("1" (expand "wf" -5) (("1" (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): (every(P)(l) AND every(Q)(l)) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skolem!) (("2" (induct "l") (("1" (prop) (("1" (expand "every" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "every" 1) (("1" (expand "every" -2) (("1" (expand "every" -3) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (expand "every" -1) (("2" (prop) nil nil)) nil) ("3" (expand "every" -2) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "l") (("1" (skosimp*) (("1" (expand "map") (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "map" 1) (("2" (expand "length" 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((TypePred formal-type-decl nil FODL_semantic nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_semantic nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_semantic nil) (AssMetavariable type-eq-decl nil FODL_semantic nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_semantic nil) (World_ type-eq-decl nil FODL_semantic nil) (mTerm def-decl "Carrier" FODL_semantic nil) (pred_var!1 skolem-const-decl "Predicate" FODL_semantic nil) (list_var!1 skolem-const-decl "{lPrime:
   list
       [Term_
            [Constant, Metavariable, Variable, Predicate, sigPredicate,
             Function_, sigFunction_]] |
         sigPredicate(pred_var!1) =
          length
              [Term_
                   [Constant, Metavariable, Variable, Predicate,
                    sigPredicate, Function_, sigFunction_]]
              (lPrime)}" FODL_semantic nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (Carrier formal-nonempty-type-decl nil FODL_semantic nil) (wf_Term_ type-eq-decl nil wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 2072 1850 nil nil)) (m_TCC28 0 (m_TCC28-1 nil 3292689002 3292689663 ("" (skolem-typepred) (("" (hide -1) (("" (hide -2) (("" (hide -2) (("" (hide -2) (("" (flatten) (("" (replace -3) (("" (expand "wf" -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 659 610 nil nil)) (m_TCC29 0 (m_TCC29-1 nil 3292689002 3292689663 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 414 390 nil nil)) (m_TCC30 0 (m_TCC30-1 nil 3292689002 3292689664 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 414 400 nil nil)) (m_TCC31 0 (m_TCC31-1 nil 3292689002 3292689664 ("" (skolem-typepred) (("" (flatten) (("" (replace -6 1) (("" (assert 1) nil nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 128 100 nil nil)) (m_TCC32 0 (m_TCC32-1 nil 3292689002 3292689664 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 439 430 nil nil)) (m_TCC33 0 (m_TCC33-1 nil 3292689002 3292689669 ("" (grind) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (TypePred formal-type-decl nil FODL_semantic nil) (Carrier formal-nonempty-type-decl nil FODL_semantic nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_semantic nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_semantic nil) (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 4517 3680 nil nil)) (m_TCC34 0 (m_TCC34-1 nil 3292689002 3292689669 ("" (skolem-typepred) (("" (hide -1) (("" (hide -2) (("" (hide -2) (("" (hide -2) (("" (flatten) (("" (replace -3) (("" (expand "wf" -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 655 610 nil nil)) (m_TCC35 0 (m_TCC35-1 nil 3292689002 3292689670 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 450 430 nil nil)) (m_TCC36 0 (m_TCC36-1 nil 3292689002 3292689672 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (expand "complexity" 1) (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((complexity const-decl "nat" wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil)) 2173 2080 nil nil)) (m_TCC37 0 (m_TCC37-1 nil 3292689002 3292689673 ("" (skolem-typepred) (("" (hide -1) (("" (hide -1) (("" (hide -2) (("" (hide -2) (("" (flatten) (("" (replace -3) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 607 570 nil nil)) (m_TCC38 0 (m_TCC38-1 nil 3292689002 3292689673 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 453 440 nil nil)) (m_TCC39 0 (m_TCC39-1 nil 3292689002 3292689675 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (expand "complexity" 1) (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((complexity const-decl "nat" wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil)) 2210 2060 nil nil)) (m_TCC40 0 (m_TCC40-1 nil 3292689002 3292689676 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 499 450 nil nil)) (m_TCC41 0 (m_TCC41-1 nil 3292689002 3292689681 ("" (grind) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 5203 3980 nil nil)) (m_TCC42 0 (m_TCC42-1 nil 3292689002 3292689682 ("" (skolem-typepred) (("" (hide -1) (("" (hide -1) (("" (hide -2) (("" (hide -2) (("" (flatten) (("" (replace -3) (("" (expand "wf" -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 971 700 nil nil)) (m_TCC43 0 (m_TCC43-1 nil 3292689002 3292689683 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 740 480 nil nil)) (m_TCC44 0 (m_TCC44-1 nil 3292689002 3292689686 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (expand "complexity" 1) (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((complexity const-decl "nat" wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil)) 3111 2200 nil nil)) (m_TCC45 0 (m_TCC45-1 nil 3292689002 3292689687 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Program_ type-eq-decl nil wf_FODL_Language nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 643 490 nil nil)) (m_TCC46 0 (m_TCC46-1 nil 3292689002 3292689721 ("" (grind) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 34727 4200 nil nil)) (m_TCC47 0 (m_TCC47-1 nil 3292689002 3292689723 ("" (cases-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 2180 1420 nil nil)) (m_TCC48 0 (m_TCC48-1 nil 3292689002 3292689730 ("" (grind) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil)) 6395 2880 nil nil)) (m_TCC49 0 (m_TCC49-1 nil 3292689002 3292689731 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -6 -5) (("" (replace -5 -4) (("" (expand "every" -4) (("" (expand "wf" -4) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 952 500 nil nil)) (m_TCC50 0 (m_TCC50-1 nil 3292689002 3292689734 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (expand "complexity" 1) (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((complexity const-decl "nat" wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil)) 3122 2130 nil nil)) (m_TCC51 0 (m_TCC51-1 nil 3292689002 3292689736 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)) 1820 1130 nil nil)) (m_TCC52 0 (m_TCC52-1 nil 3292689002 3292689736 ("" (skolem-typepred) (("" (flatten) (("" (replace -5 -4) (("" (replace -4 -3) (("" (expand "every" -3) (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 482 410 nil nil)) (m_TCC53 0 (m_TCC53-1 nil 3292689002 3292689740 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (expand "complexity" 1) (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((complexity const-decl "nat" wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil)) 3482 2110 nil nil)) (m_TCC54 0 (m_TCC54-1 nil 3292689002 3292689740 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -5 -4) (("" (replace -4 -3) (("" (expand "every" -3) (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 633 450 nil nil)) (m_TCC55 0 (m_TCC55-1 nil 3292689002 3292689746 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 5853 3500 nil nil)) (m_TCC56 0 (m_TCC56-1 nil 3292689002 3292689747 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil) proved nil 685 380 nil nil)) (m_TCC57 0 (m_TCC57-1 nil 3292689002 3292689749 ("" (termination-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)) 1991 1720 nil nil)) (m_TCC58 0 (m_TCC58-1 nil 3292689002 3292689749 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 414 390 nil nil)) (m_TCC59 0 (m_TCC59-1 nil 3292689002 3292689750 ("" (skolem-typepred) (("" (hide -1) (("" (hide -2) (("" (hide -2) (("" (hide -2) (("" (flatten) (("" (replace -3) (("" (expand "wf" -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (Term_ type-eq-decl nil FODL_Language_adt nil) (F? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (v? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (m? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (c? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 662 600 nil nil)) (m_TCC60 0 (m_TCC60-1 nil 3292689002 3292689751 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 1311 400 nil nil)) (m_TCC61 0 (m_TCC61-1 nil 3292689002 3292689757 ("" (grind) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 5086 3660 nil nil)) (m_TCC62 0 (m_TCC62-1 nil 3292689002 3292689757 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 502 420 nil nil)) (m_TCC63 0 (m_TCC63-1 nil 3292689002 3292689759 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (expand "complexity" 1) (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((complexity const-decl "nat" wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil)) 2144 2070 nil nil)) (m_TCC64 0 (m_TCC64-1 nil 3292689002 3292689760 ("" (skolem-typepred) (("" (hide -1) (("" (hide -2) (("" (hide -2) (("" (flatten) (("" (expand "wf" -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 1179 1090 nil nil)) (m_TCC65 0 (m_TCC65-1 nil 3292689002 3292689761 ("" (skolem-typepred) (("" (flatten) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 416 400 nil nil)) (m_TCC66 0 (m_TCC66-1 nil 3292689002 3292689763 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (expand "complexity" 1) (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((complexity const-decl "nat" wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil)) 2119 2040 nil nil)) (m_TCC67 0 (m_TCC67-1 nil 3292689002 3292689763 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -7 -6) (("" (replace -6 -5) (("" (expand "every" -5) (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 449 410 nil nil)) (m_TCC68 0 (m_TCC68-1 nil 3292689002 3292689766 ("" (skosimp*) (("" (replace -2) (("" (replace -1) (("" (expand "complexity" 2) (("" (expand "reduce_nat" 2 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((complexity const-decl "nat" wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil)) 2148 2070 nil nil)) (m_TCC69 0 (m_TCC69-1 nil 3292689002 3292689768 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)) 2165 1090 nil nil)) (m_TCC70 0 (m_TCC70-1 nil 3292689002 3292689769 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (replace -6 -5) (("" (replace -5 -4) (("" (expand "every" -4) (("" (expand "wf" -4) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 898 430 nil nil)) (m_TCC71 0 (m_TCC71-1 nil 3292689002 3292689793 ("" (termination-tcc) nil nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (complexity const-decl "nat" wf_FODL_Language nil)) 24353 3490 nil nil)) (m_TCC72 0 (m_TCC72-2 "" 3292703733 3292703733 ("" (skolem-typepred) (("" (flatten) (("" (skosimp*) (("" (expand "monotonic?") (("" (skosimp*) (("" (expand "<=") (("" (skosimp*) (("" (assert) (("" (skosimp*) (("" (inst -8 "(w!2, s!1`2)") (("" (inst 2 "w!2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved nil 789669 25840 t shostak) (m_TCC72-1 nil 3292689002 3292689812 ("" (subtype-tcc) nil nil) proved ((monotonic? const-decl "bool" mucalculus nil) (<= const-decl "bool" mucalculus nil) (Carrier formal-nonempty-type-decl nil FODL_semantic nil) (TypePred formal-type-decl nil FODL_semantic nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_semantic nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_semantic nil) (World_ type-eq-decl nil FODL_semantic nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" union_adt nil) (union type-decl nil union_adt nil) (PRED type-eq-decl nil defined_types nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (wf def-decl "boolean" wf_FODL_Language nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FODL_Language type-decl nil FODL_Language_adt nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Constant formal-type-decl nil FODL_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) 18761 17220 nil nil)) (m_TCC73 0 (m_TCC73-1 nil 3292689002 3292689813 ("" (cases-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil) (<= const-decl "bool" mucalculus nil) (lfp const-decl "pred[T]" mucalculus nil) (mu const-decl "pred[T]" mucalculus nil) (member const-decl "bool" sets nil) (glb const-decl "pred[T]" mucalculus nil)) 1135 1080 nil nil)) (m_TCC74 0 (m_TCC74-1 nil 3292689002 3292689815 ("" (cases-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Constant formal-type-decl nil FODL_semantic nil) (Metavariable formal-type-decl nil FODL_semantic nil) (Variable formal-type-decl nil FODL_semantic nil) (Predicate formal-type-decl nil FODL_semantic nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic nil) (Function_ formal-type-decl nil FODL_semantic nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic nil) (FODL_Language type-decl nil FODL_Language_adt nil) (T?? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (A? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Program_ type-eq-decl nil FODL_Language_adt nil) (wf def-decl "boolean" wf_FODL_Language nil) (wf_Program_ type-eq-decl nil wf_FODL_Language nil) (PRED type-eq-decl nil defined_types nil) (union type-decl nil union_adt nil) (every adt-def-decl "boolean" union_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (NOT? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (OR? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (AND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (IFF? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (P? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EQ? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (BOX? adt-recognizer-decl "[FODL_Language -> boolean]" FODL_Language_adt nil) (Formula_ type-eq-decl nil FODL_Language_adt nil) (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)) 1805 1740 nil nil)))

$$$FODL_conversions.pvs
FODL_conversions[Constant: TYPE, 
                 Metavariable: TYPE, 
                 Variable: TYPE,
                 Predicate: TYPE, sigPredicate: [Predicate -> nat], 
                 Function_: TYPE, sigFunction_: [Function_ -> nat],
                 TypePred: TYPE,
                 TPMetavariable: [Metavariable -> TypePred], 
                 TPVariable: [Variable -> TypePred],
                 Carrier: TYPE+,
                 mTypePred: [TypePred -> [Carrier -> bool]], 
                 mConstant: [Constant -> Carrier], 
                 mPredicate: [P: Predicate -> 
                                [{l: list[Carrier] | sigPredicate(P) = length(l)} -> 
                                   bool]],
                 mFunction_: [F: Function_ ->
                                [{l: list[Carrier] | sigFunction_(F) = length(l)} ->
                                   Carrier]]]: THEORY

  BEGIN

    ASSUMING
      non_empty_types: ASSUMPTION
         FORALL (t: TypePred): EXISTS (c: (mTypePred(t))): TRUE 
    ENDASSUMING

    IMPORTING FODL_semantic[Constant,
                            Metavariable,
                            Variable,
                            Predicate, sigPredicate,
                            Function_, sigFunction_,
                            TypePred,
                            TPMetavariable, 
                            TPVariable,
                            Carrier,
                            mTypePred, 
                            mConstant, 
                            mPredicate,
                            mFunction_]
  
    meaning_conv: MACRO [wf_Formula_ -> bool] = 
       LAMBDA (f: wf_Formula_): FORALL (w: World_): meaningF(f)(w)

    CONVERSION+ meaning_conv

  END FODL_conversions

$$$FODL_conversions.prf
(|FODL_conversions| (|IMP_FODL_semantic_TCC1| "" (USE "non_empty_types") NIL NIL))


$$$FODL_axioms.pvs
FODL_axioms[Constant: TYPE, 
            Metavariable: TYPE, 
            Variable: TYPE,
            Predicate: TYPE, sigPredicate: [Predicate -> nat], 
            Function_: TYPE, sigFunction_: [Function_ -> nat],
            TypePred: TYPE,
            TPMetavariable: [Metavariable -> TypePred], 
            TPVariable: [Variable -> TypePred],
            Carrier: TYPE+, 
            mTypePred: [TypePred -> [Carrier -> bool]],
            mConstant: [Constant -> Carrier], 
            mPredicate: [P: Predicate -> 
                           [{l: list[Carrier] | sigPredicate(P) = length(l)} -> 
                              bool]],
            mFunction_: [F: Function_ ->
                           [{l: list[Carrier] | sigFunction_(F) = length(l)} ->
                              Carrier]]]: THEORY

  BEGIN

    ASSUMING
      non_empty_types: ASSUMPTION
         FORALL (t: TypePred): EXISTS (c: (mTypePred(t))): TRUE 
    ENDASSUMING

    IMPORTING FODL_semantic[Constant, 
                            Metavariable,
                            Variable, 
                            Predicate, sigPredicate,
                            Function_, sigFunction_,
                            TypePred,
                            TPMetavariable, TPVariable,
                            Carrier,
                            mTypePred,
                            mConstant, 
                            mPredicate, 
                            mFunction_],
              FODL_conversions[Constant, 
                               Metavariable,
                               Variable, 
                               Predicate, sigPredicate,
                               Function_, sigFunction_,
                               TypePred,
                               TPMetavariable, TPVariable,
                               Carrier,
                               mTypePred,
                               mConstant, 
                               mPredicate, 
                               mFunction_]

   PDL_1: LEMMA
     FORALL (f_0, f_1: wf_Formula_, P: wf_Program_):
       (<>(P, f_0) AND [](P, f_1)) IMPLIES <>(P, f_0 AND f_1)

   PDL_2: LEMMA
     FORALL (f_0, f_1: wf_Formula_, P: wf_Program_):
       <>(P, f_0 OR f_1) IFF (<>(P, f_0) OR <>(P, f_1))

   PDL_3: LEMMA
     FORALL (f: wf_Formula_, P_0, P_1: wf_Program_):
       <>(P_0 + P_1, f) IFF (<>(P_0, f) OR <>(P_1, f))

   PDL_4: LEMMA
     FORALL (f: wf_Formula_, P_0, P_1: wf_Program_):
       <>(P_0 // P_1, f) IFF <>(P_0, <>(P_1, f))

   PDL_5: LEMMA
     FORALL (f_0: {f: wf_Formula_ | no_metavariable(f)}, f_1: wf_Formula_):
       <>(T?(f_0), f_1) IFF (f_0 AND f_1)

   PDL_6: LEMMA
     FORALL (f: wf_Formula_, P: wf_Program_):
       (f OR <>(P, <>(*(P), f))) IMPLIES <>(*(P), f)

   PDL_7: LEMMA
     FORALL (f: wf_Formula_, P: wf_Program_):
       <>(*(P), f) IMPLIES (f OR <>(*(P), NOT f AND <>(P, f)))

  END FODL_axioms

$$$FODL_axioms.prf
(|FODL_axioms| (|IMP_FODL_semantic_TCC1| "" (USE "non_empty_types") NIL NIL)
 (PDL_1 "" (EXPAND-MEANING)
  (("" (SKOSIMP*)
    (("" (EXPAND-MEANING)
      (("" (PROP)
        (("" (EXPAND-MEANING)
          (("" (SKOSIMP*)
            (("" (EXPAND-MEANING -)
              (("" (SKOSIMP*)
                (("" (INST 1 "wPrime!1")
                  (("" (PROP)
                    (("" (EXPAND-MEANING 1)
                      (("" (PROP)
                        (("" (INST -3 "wPrime!1") (("" (PROP) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (PDL_2 "" (EXPAND-MEANING)
  (("" (SKOSIMP*)
    (("" (EXPAND-MEANING)
      (("" (PROP)
        (("1" (EXPAND-MEANING)
          (("1" (FLATTEN)
            (("1" (EXPAND-MEANING +)
              (("1" (SKOSIMP*)
                (("1" (EXPAND-MEANING -2)
                  (("1" (PROP)
                    (("1" (INST 1 "wPrime!1") (("1" (PROP) NIL NIL)) NIL)
                     ("2" (INST 2 "wPrime!1") (("2" (PROP) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (EXPAND-MEANING)
          (("2" (SPLIT)
            (("1" (EXPAND-MEANING -1)
              (("1" (SKOSIMP*)
                (("1" (INST?)
                  (("1" (PROP)
                    (("1" (EXPAND-MEANING 1) (("1" (PROP) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (EXPAND-MEANING -1)
              (("2" (SKOSIMP*)
                (("2" (INST?)
                  (("2" (PROP)
                    (("2" (EXPAND-MEANING 1) (("2" (PROP) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (PDL_3 "" (EXPAND-MEANING)
  (("" (SKOSIMP*)
    (("" (EXPAND-MEANING)
      (("" (PROP)
        (("1" (EXPAND-MEANING)
          (("1" (SKOSIMP*)
            (("1" (EXPAND-MEANING -1)
              (("1" (PROP)
                (("1" (EXPAND-MEANING 1)
                  (("1" (INST 1 "wPrime!1") (("1" (PROP) NIL NIL)) NIL)) NIL)
                 ("2" (EXPAND-MEANING 2)
                  (("2" (INST 2 "wPrime!1") (("2" (PROP) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (EXPAND-MEANING)
          (("2" (PROP)
            (("1" (EXPAND-MEANING -1)
              (("1" (SKOSIMP*)
                (("1" (INST 1 "wPrime!1")
                  (("1" (PROP)
                    (("1" (EXPAND-MEANING 1) (("1" (PROP) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (EXPAND-MEANING -1)
              (("2" (SKOSIMP*)
                (("2" (INST 1 "wPrime!1")
                  (("2" (PROP)
                    (("2" (EXPAND-MEANING 1) (("2" (PROP) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (PDL_4 "" (EXPAND-MEANING)
  (("" (SKOSIMP*)
    (("" (EXPAND-MEANING)
      (("" (PROP)
        (("1" (EXPAND-MEANING)
          (("1" (SKOSIMP*)
            (("1" (EXPAND-MEANING -1)
              (("1" (SKOSIMP*)
                (("1" (INST 1 "w!2")
                  (("1" (PROP)
                    (("1" (EXPAND-MEANING 1)
                      (("1" (INST 1 "wPrime!1") (("1" (PROP) NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (EXPAND-MEANING)
          (("2" (SKOSIMP*)
            (("2" (EXPAND-MEANING -2)
              (("2" (SKOSIMP*)
                (("2" (INST 1 "wPrime!2")
                  (("2" (PROP)
                    (("2" (EXPAND-MEANING 1)
                      (("2" (INST 1 "wPrime!1") (("2" (PROP) NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (PDL_5 "" (EXPAND-MEANING)
  (("" (SKOSIMP*)
    (("" (EXPAND-MEANING)
      (("" (PROP)
        (("1" (EXPAND-MEANING)
          (("1" (SKOSIMP*)
            (("1" (PROP)
              (("1" (EXPAND-MEANING -1) (("1" (PROP) NIL NIL)) NIL)
               ("2" (EXPAND-MEANING -1)
                (("2" (PROP) (("2" (REPLACE -1) (("2" (PROPAX) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (EXPAND-MEANING)
          (("2" (PROP)
            (("2" (INST 1 "w!1")
              (("2" (PROP) (("2" (EXPAND-MEANING 1) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (PDL_6 "" (SKOSIMP*)
  (("" (EXPAND-MEANING)
    (("" (SKOSIMP*)
      (("" (EXPAND-MEANING)
        (("" (PROP)
          (("" (EXPAND-MEANING)
            (("" (PROP)
              (("1" (INST 1 "w!1")
                (("1" (PROP)
                  (("1" (HIDE -1)
                    (("1" (EXPAND-MEANING)
                      (("1" (EXPAND "mu")
                        (("1" (EXPAND "lfp")
                          (("1" (EXPAND "glb")
                            (("1" (EXPAND "member")
                              (("1" (EXPAND "<=")
                                (("1" (SKOSIMP*)
                                  (("1" (INST -1 "(w!1, w!1)") NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (EXPAND-MEANING -1)
                (("2" (SKOSIMP*)
                  (("2" (EXPAND-MEANING -2)
                    (("2" (SKOSIMP*)
                      (("2" (INST 1 "wPrime!2")
                        (("2" (PROP)
                          (("2" (HIDE -3)
                            (("2" (EXPAND-MEANING -2)
                              (("2" (EXPAND-MEANING 1)
                                (("2" (EXPAND "mu")
                                  (("2" (EXPAND "lfp")
                                    (("2" (EXPAND "glb")
                                      (("2"
                                        (EXPAND "member")
                                        (("2"
                                          (EXPAND "<=")
                                          (("2"
                                            (SKOSIMP*)
                                            (("2"
                                              (INST -3 "p!1")
                                              (("2"
                                                (PROP)
                                                (("2"
                                                  (INST -2 "(w!1, wPrime!2)")
                                                  (("2"
                                                    (PROP)
                                                    (("2"
                                                      (INST 2 "wPrime!1")
                                                      (("2" (PROP) NIL NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL))
  NIL)
 (PDL_7 "" (POSTPONE) NIL NIL))


$$$FODL_lemmas.pvs
FODL_lemmas[Constant: TYPE, 
            Metavariable: TYPE, 
            Variable: TYPE,
            Predicate: TYPE, sigPredicate: [Predicate -> nat], 
            Function_: TYPE, sigFunction_: [Function_ -> nat],
            TypePred: TYPE,
            TPMetavariable: [Metavariable -> TypePred], 
            TPVariable: [Variable -> TypePred],
            Carrier: TYPE+, 
            mTypePred: [TypePred -> [Carrier -> bool]],
            mConstant: [Constant -> Carrier], 
            mPredicate: [P: Predicate -> 
                           [{l: list[Carrier] | sigPredicate(P) = length(l)} -> 
                              bool]],
            mFunction_: [F: Function_ ->
                           [{l: list[Carrier] | sigFunction_(F) = length(l)} ->
                              Carrier]]]: THEORY

  BEGIN

    ASSUMING
      non_empty_types: ASSUMPTION
         FORALL (t: TypePred): EXISTS (c: (mTypePred(t))): TRUE 
    ENDASSUMING

    IMPORTING FODL_axioms[Constant, 
                          Metavariable,
                          Variable, 
                          Predicate, sigPredicate,
                          Function_, sigFunction_,
                          TypePred,
                          TPMetavariable, TPVariable,
                          Carrier,
                          mTypePred,
                          mConstant, 
                          mPredicate, 
                          mFunction_],
              FODL_conversions[Constant, 
                               Metavariable,
                               Variable, 
                               Predicate, sigPredicate,
                               Function_, sigFunction_,
                               TypePred,
                               TPMetavariable, TPVariable,
                               Carrier,
                               mTypePred,
                               mConstant, 
                               mPredicate, 
                               mFunction_]

   PDL_2_box_form: LEMMA
     FORALL (f_0, f_1: wf_Formula_, P: wf_Program_):
       ([](P, f_0) OR [](P, f_1)) IMPLIES [](P, f_0 OR f_1)

   PDL_2_and_form: LEMMA
     FORALL (f_0, f_1: wf_Formula_, P: wf_Program_):
       <>(P, f_0 AND f_1) IMPLIES (<>(P, f_0) AND <>(P, f_1))

   PDL_2_box_and_form: LEMMA
     FORALL (f_0, f_1: wf_Formula_, P: wf_Program_):
       [](P, f_0 AND f_1) IFF ([](P, f_0) AND [](P, f_1))

   PDL_3_box_form: LEMMA
     FORALL (f: wf_Formula_, P_0, P_1: wf_Program_):
       [](P_0 + P_1, f) IFF ([](P_0, f) AND [](P_1, f))

   PDL_4_box_form: LEMMA
     FORALL (f: wf_Formula_, P_0, P_1: wf_Program_):
       [](P_0 // P_1, f) IFF [](P_0, [](P_1, f))

   PDL_5_box_form: LEMMA
     FORALL (f_0: {f: wf_Formula_ | no_metavariable(f)}, f_1: wf_Formula_):
       [](T?(f_0), f_1) IFF (f_0 IMPLIES f_1)

   PDL_6_box_form: LEMMA
     FORALL (f: wf_Formula_, P: wf_Program_):
       (f AND [](*(P), f IMPLIES [](P, f))) IMPLIES [](*(P), f)

   PDL_7_box_form: LEMMA
     FORALL (f: wf_Formula_, P: wf_Program_):
       [](*(P), f) IMPLIES (f AND [](P, [](*(P), f)))

   PDL_lemma_1: LEMMA
     FORALL (f_0, f_1: wf_Formula_, P: wf_Program_):
       [](P, f_0 AND f_1) IFF ([](P, f_0) AND [](P, f_1))

   PDL_lemma_2: LEMMA
     FORALL (f_0, f_1: wf_Formula_, P: wf_Program_):
       [](P, f_0 IMPLIES f_1) IMPLIES ([](P, f_0) IMPLIES [](P, f_1))

  END FODL_lemmas

$$$FODL_lemmas.prf
(FODL_lemmas (IMP_FODL_axioms_TCC1 0 (IMP_FODL_axioms_TCC1-1 nil 3292689035 3292689447 ("" (use "non_empty_types") nil nil) proved ((non_empty_types formula-decl nil FODL_lemmas nil)) 294 290 nil nil)) (PDL_2_box_form 0 (PDL_2_box_form-1 nil 3292689035 3292689450 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("" (expand-meaning) (("" (prop) (("1" (skosimp*) (("1" (expand-meaning 1) (("1" (prop) (("1" (expand-meaning -1) (("1" (inst -1 "wPrime!1") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand-meaning 1) (("2" (prop) (("2" (expand-meaning -1) (("2" (inst -1 "wPrime!1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((World_ type-eq-decl nil FODL_semantic nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TypePred formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (Variable formal-type-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 3588 3410 nil nil)) (PDL_2_and_form 0 (PDL_2_and_form-1 nil 3292689035 3292689455 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("" (expand-meaning) (("" (skosimp*) (("" (prop) (("1" (expand-meaning 1) (("1" (inst 1 "wPrime!1") (("1" (prop) (("1" (expand-meaning -2) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning 1) (("2" (inst 1 "wPrime!1") (("2" (prop) (("2" (expand-meaning -2) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((World_ type-eq-decl nil FODL_semantic nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TypePred formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (Variable formal-type-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 4538 3480 nil nil)) (PDL_2_box_and_form 0 (PDL_2_box_and_form-1 nil 3292689035 3292689460 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("1" (expand-meaning) (("1" (prop) (("1" (expand-meaning 1) (("1" (skosimp*) (("1" (inst -2 "wPrime!1") (("1" (prop) (("1" (expand-meaning -1) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning 1) (("2" (skosimp*) (("2" (inst -2 "wPrime!1") (("2" (prop) (("2" (expand-meaning -1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning) (("2" (skosimp*) (("2" (expand-meaning 1) (("2" (prop) (("1" (expand-meaning -1) (("1" (inst -1 "wPrime!1") (("1" (prop) nil nil)) nil)) nil) ("2" (expand-meaning -2) (("2" (inst -2 "wPrime!1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((World_ type-eq-decl nil FODL_semantic nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TypePred formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (Variable formal-type-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 5039 4830 nil nil)) (PDL_3_box_form 0 (PDL_3_box_form-1 nil 3292689035 3292689465 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("1" (expand-meaning) (("1" (prop) (("1" (expand-meaning 1) (("1" (skosimp*) (("1" (inst -2 "wPrime!1") (("1" (prop) (("1" (expand-meaning 1) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning 1) (("2" (skosimp*) (("2" (inst -2 "wPrime!1") (("2" (prop) (("2" (expand-meaning 1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning) (("2" (skosimp*) (("2" (expand-meaning -3) (("2" (prop) (("1" (expand-meaning -2) (("1" (inst -2 "wPrime!1") (("1" (prop) nil nil)) nil)) nil) ("2" (expand-meaning -3) (("2" (inst -3 "wPrime!1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((World_ type-eq-decl nil FODL_semantic nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TypePred formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (Variable formal-type-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 5091 4790 nil nil)) (PDL_4_box_form 0 (PDL_4_box_form-1 nil 3292689035 3292689470 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("1" (expand-meaning) (("1" (skosimp*) (("1" (expand-meaning 1) (("1" (skosimp*) (("1" (inst -1 "wPrime!2") (("1" (prop) (("1" (expand-meaning 1) (("1" (inst 1 "wPrime!1") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning) (("2" (skosimp*) (("2" (expand-meaning -2) (("2" (skosimp*) (("2" (inst -1 "w!2") (("2" (prop) (("2" (expand-meaning -1) (("2" (inst -1 "wPrime!1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((World_ type-eq-decl nil FODL_semantic nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TypePred formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (Variable formal-type-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 4507 3950 nil nil)) (PDL_5_box_form 0 (PDL_5_box_form-1 nil 3292689035 3292689489 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("1" (expand-meaning) (("1" (prop) (("1" (inst -1 "w!1") (("1" (prop) (("1" (expand-meaning 1) nil nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning) (("2" (skosimp*) (("2" (expand-meaning -2) (("2" (prop) (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((World_ type-eq-decl nil FODL_semantic nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TypePred formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (Variable formal-type-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 19237 3380 nil nil)) (PDL_6_box_form 0 (PDL_6_box_form-1 nil 3292689035 3292692808 ("" (skosimp*) (("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("" (expand-meaning) (("" (prop) (("" (skosimp*) (("" (expand-meaning -3) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished nil 605989 23230 t nil)) (PDL_7_box_form 0 (PDL_7_box_form-1 nil 3292689035 3292689493 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("" (expand-meaning) (("" (prop) (("1" (inst -1 "w!1") (("1" (prop) (("1" (hide 2) (("1" (expand-meaning) (("1" (expand "mu") (("1" (expand "lfp") (("1" (expand "glb") (("1" (expand "member") (("1" (expand "<=") (("1" (skosimp*) (("1" (inst -1 "(w!1, w!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning 1) (("2" (skosimp*) (("2" (expand-meaning 1) (("2" (skosimp*) (("2" (inst -3 "wPrime!2") (("2" (prop) (("2" (hide 2) (("2" (expand-meaning -2) (("2" (expand-meaning 1) (("2" (expand "mu") (("2" (expand "lfp") (("2" (expand "glb") (("2" (expand "member") (("2" (expand "<=") (("2" (skosimp*) (("2" (inst -3 "p!1") (("2" (prop) (("2" (inst -2 "(w!1, wPrime!2)") (("2" (prop) (("2" (inst 2 "wPrime!1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((lfp const-decl "pred[T]" mucalculus nil) (member const-decl "bool" sets nil) (<= const-decl "bool" mucalculus nil) (glb const-decl "pred[T]" mucalculus nil) (mu const-decl "pred[T]" mucalculus nil) (World_ type-eq-decl nil FODL_semantic nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TypePred formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (Variable formal-type-decl nil FODL_lemmas nil) (pred type-eq-decl nil defined_types nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 4141 3940 nil nil)) (PDL_lemma_1 0 (PDL_lemma_1-1 nil 3292689035 3292689498 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("1" (expand-meaning) (("1" (prop) (("1" (expand-meaning 1) (("1" (skosimp*) (("1" (inst -2 "wPrime!1") (("1" (prop) (("1" (expand-meaning -1) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning 1) (("2" (skosimp*) (("2" (inst -2 "wPrime!1") (("2" (prop) (("2" (expand-meaning -1) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand-meaning) (("2" (skosimp*) (("2" (expand-meaning 1) (("2" (prop) (("1" (expand-meaning -1) (("1" (inst -1 "wPrime!1") (("1" (prop) nil nil)) nil)) nil) ("2" (expand-meaning -2) (("2" (inst -2 "wPrime!1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((World_ type-eq-decl nil FODL_semantic nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Predicate formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TypePred formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (Variable formal-type-decl nil FODL_lemmas nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 4969 4750 nil nil)) (PDL_lemma_2 0 (PDL_lemma_2-1 nil 3292689036 3292689501 ("" (expand-meaning) (("" (skosimp*) (("" (expand-meaning) (("" (prop) (("" (expand-meaning) (("" (prop) (("" (expand-meaning -2) (("" (expand-meaning 1) (("" (skosimp*) (("" (inst -2 "wPrime!1") (("" (prop) (("" (inst -2 "wPrime!1") (("" (prop) (("" (expand-meaning -1) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((Variable formal-type-decl nil FODL_lemmas nil) (Carrier formal-nonempty-type-decl nil FODL_lemmas nil) (TypePred formal-type-decl nil FODL_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]" FODL_lemmas nil) (TPVariable formal-const-decl "[Variable -> TypePred]" FODL_lemmas nil) (Constant formal-type-decl nil FODL_lemmas nil) (Metavariable formal-type-decl nil FODL_lemmas nil) (Predicate formal-type-decl nil FODL_lemmas nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_lemmas nil) (Function_ formal-type-decl nil FODL_lemmas nil) (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_lemmas nil) (TPMetavariable formal-const-decl "[Metavariable -> TypePred]" FODL_lemmas nil) (mConstant formal-const-decl "[Constant -> Carrier]" FODL_lemmas nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (mPredicate formal-const-decl "[P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]]" FODL_lemmas nil) (mFunction_ formal-const-decl "[F: Function_ ->
   [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]]" FODL_lemmas nil) (World_ type-eq-decl nil FODL_semantic nil) (m def-decl "{u: union[PRED[World_], PRED[[World_, World_]]] |
         CASES l OF inl(f): inl?(u), inr(P): inr?(u) ENDCASES}" FODL_semantic nil) (meaningF const-decl "PRED[World_]" FODL_semantic nil)) 3315 3190 nil nil)))

$$$FA_Element.pvs
FA_Element[T: TYPE]: DATATYPE

  BEGIN
    element(t: T): element?
    pair(el0, el1: FA_Element): pair?
  END FA_Element

$$$FA_Language.pvs
FA_Language: THEORY

  BEGIN
  
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Especificación Ag.                                                            %
    % Ag specification.                                                             %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                                                                               %
    % Addr: TYPE                                                                    %
    % Data: TYPE                                                                    %
    % Memory: TYPE = Addr -> Data                                                   %
    % Cache: TYPE = Addr -> Data                                                    %
    % Dirty: TYPE = set[Addr]                                                       %
    % DirtyCache: TYPE = {dc: Cache +_circ Dirty |                                  %
    %                          Dirty(dc) <= Dom(Cache(dc))}                         %
    % DirtyCacheSystem: TYPE = {cs: Memory +_circ DirtyCache |                      %
    %                                Dom(Cache(DirtyCache(cs)) <= Dom(Memory(cs))}  %
    %                                                                               %

    % Declaración de los símbolos que denotan constantes.
    % Declaration of the constants symbols.
    Constant: TYPE = {%% Constantes de la fork algebra. %% Obligatorio.
                      %% Fork algebra constants. %% Mandatory.
                      zero, one, one_prime, C_0, C_1, inl, inr, 
                      Pi_1, Pi_2, one_prime_C_0, one_prime_C_1,
                      %% Identidades parciales. %% Dependientes de la especificación.
                      %% Partial identities. %% Specification dependent.   
                      one_prime_Addr, one_prime_Data}

    %% Declaración de los símbolos que denotan metavariables.
    %% Declaration of the metavariables symbols.
    Metavariable: TYPE = {cs0}

    %% Declaración de los símbolos que denotan variables.
    %% Declaration of the variables symbols.
    Variable: TYPE = {cs, addr, data}

    %% Declaración de los símbolos de denotan predicados.
    %% Declaration of the predicate symbols.
    Predicate: TYPE = {%% Predicados de la fork algebra. %% Obligatorio. 
                       %% Fork algebra predicates. %% Mandatory.
                       Leq, Functional, OneToOne, Pair}
    %% Definición de la función que retorna la aridad de los predicados.
    %% Definition of the function that yields the arity of the predicates.
    sigPredicate: [Predicate -> nat] =
            LAMBDA (P: Predicate): CASES P 
                                     OF Leq: 2,
                                        Functional: 1,
                                        OneToOne: 1,
                                        Pair: 1
                                      ENDCASES

    %% Declaración de los símbolos de denotan funciones.
    %% Declaration of the function symbols.
    Function_: TYPE = {%% Funciones de la fork algebra. %% Obligatorio. 
                       %% Fork algebra functions. %% Mandatory.
                       sum, product, complement, composition, converse, fork,
                       Dom, FunctionUpdate, FunctionUndef, Neg,
                       %% Funciones de la especificación.
                         %% Dependientes de la especificación.
                       %% Specification functions.
                         %% Specification dependent.   
                       Memory, DirtyCache, Cache, Dirty}
    %% Definición de la función que retorna la aridad de las functiones.
    %% Definition of the function that yields the arity of the functions.
    sigFunction_: [Function_ -> nat] =
            LAMBDA (F: Function_): CASES F 
                                     OF sum: 2,
                                        product: 2,
                                        complement: 1, 
                                        composition: 2, 
                                        converse: 1, 
                                        fork: 2,
                                        Dom: 1,
                                        FunctionUpdate: 2,
                                        FunctionUndef: 2,
                                        Neg: 1,
                                        Memory: 1,
                                        DirtyCache: 1,
                                        Cache: 1,
                                        Dirty: 1
                                     ENDCASES

  END FA_Language

$$$FA_semantic.pvs
FA_semantic: THEORY

  BEGIN

    IMPORTING FA_Language
  
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Especificación Ag.                                                            %
    % Ag specification.                                                             %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %                                                                               %
    % Addr: TYPE                                                                    %
    % Data: TYPE                                                                    %
    % Memory: TYPE = Addr -> Data                                                   %
    % Cache: TYPE = Addr -> Data                                                    %
    % Dirty: TYPE = set[Addr]                                                       %
    % DirtyCache: TYPE = {dc: Cache +_circ Dirty |                                  %
    %                          Dirty(dc) <= Dom(Cache(dc))}                         %
    % DirtyCacheSystem: TYPE = {cs: Memory +_circ DirtyCache |                      %
    %                                Dom(Cache(DirtyCache(cs)) <= Dom(Memory(cs))}  %
    %                                                                               %

    TypePred: TYPE = {%% Predicados característicos de los tipos de la especificación.
                        %% Dependientes de la especificación.
                      %% Predicates that characterices the specification types.
                        %% Specification dependent.   
                      Carrier, Addr, Data, Memory, 
                      Cache, Dirty, DirtyCache,
                      DirtyCacheSystem}

    %% Construcción del dominio de la fork algebra.
    %% Fork algebra domain construction.
    Element: TYPE+
    c_0: Element
    c_1: Element
    Addr_Element: PRED[Element]
    Data_Element: PRED[Element]

    non_empty_Addr: AXIOM
             EXISTS (e: (Addr_Element)): TRUE

    non_empty_Data: AXIOM
             EXISTS (e: (Data_Element)): TRUE

    empty_intersection_of_types: AXIOM 
             FORALL (e: Element): 
               (e = c_0 AND NOT e = c_1 AND NOT Addr_Element(e) AND NOT Data_Element(e)) OR
               (NOT e = c_0 AND e = c_1 AND NOT Addr_Element(e) AND NOT Data_Element(e)) OR
               (NOT e = c_0 AND NOT e = c_1 AND Addr_Element(e) AND NOT Data_Element(e)) OR
               (NOT e = c_0 AND NOT e = c_1 AND NOT Addr_Element(e) AND Data_Element(e))

    IMPORTING FA_Element_adt[Element]
    Carrier: TYPE = PRED[[FA_Element, FA_Element]]

    %% Predicados característicos de los objetos de los tipos primitivos.
    %% Characteristic predicates of the objects of the primitive types.
    Addr: PRED[FA_Element] = LAMBDA (w: FA_Element):
                               EXISTS (e: Element): 
                                 Addr_Element(e) AND w = element(e)
    Data: PRED[FA_Element] = LAMBDA (w: FA_Element): 
                               EXISTS (e: Element): 
                                 Data_Element(e) AND w = element(e)

    %% Definición de las constantes declaradas (fork algebra).
    %% Definition of the declared constants (fork algebra).
    zero: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): FALSE
    one: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): TRUE
    one_prime: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): wp`1 = wp`2
    C_0: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): wp`2 = element(c_0)
    C_1: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): wp`2 = element(c_1)
    one_prime_C_0: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): one_prime(wp) AND wp`1 = element(c_0)
    one_prime_C_1: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): one_prime(wp) AND wp`1 = element(c_1)
    %% Definición de las funciones declaradas (fork algebra).
    %% Definition of the declared functions (fork algebra).
    sum(c0, c1: Carrier): Carrier = LAMBDA (wp: [FA_Element, FA_Element]): c0(wp) OR c1(wp)
    product(c0, c1: Carrier): Carrier = LAMBDA (wp: [FA_Element, FA_Element]): c0(wp) AND c1(wp)
    complement(c: Carrier): Carrier = LAMBDA (wp: [FA_Element, FA_Element]): NOT c(wp)
    composition(c0, c1: Carrier): Carrier = LAMBDA (wp: [FA_Element, FA_Element]): 
                                              EXISTS (x: FA_Element): c0((wp`1, x)) AND c1((x, wp`2)) 
    converse(c: Carrier): Carrier = LAMBDA (wp: [FA_Element, FA_Element]): c((wp`2, wp`1))
    fork(c0, c1: Carrier): Carrier = LAMBDA (wp: [FA_Element, (pair?)]): 
                                       c0((wp`1, el0(wp`2))) AND c1((wp`1, el1(wp`2)))
    %% Definición de los predicados declarados (fork algebra).
    %% Definition of the declared predicates (fork algebra).
    Leq(c0, c1: Carrier): bool = sum(c0, c1) = c1
    Functional(c: Carrier): bool = Leq(composition(converse(c), c), one_prime)
    OneToOne(c: Carrier): bool = Functional(converse(c))
    Pair(c: Carrier): bool = NOT (c = zero) AND Functional(c) AND OneToOne(c) AND
                             composition(composition(c, one), c) = c
    %% Más constantes, predicados y funciones (fork algebra).
    %% More constants, predicates and functiones (fork algebra).
    %% Constantes.
    %% Constants.
    inl: Carrier = fork(C_0, one_prime)
    inr: Carrier = fork(C_1, one_prime)
    Pi_1: Carrier = converse(fork(one_prime, one))
    Pi_2: Carrier = converse(fork(one, one_prime))
    %% Funciones.
    %% Functions.
    Dom(c: Carrier): Carrier = product(composition(c, converse(c)), one_prime)
    FunctionUndef(c0, c1: Carrier): Carrier = product(c0, complement(composition(c1, one)))
    FunctionUpdate(c0, c1: Carrier): Carrier = sum(FunctionUndef(c0, c1), c1)
    Neg(c: Carrier): Carrier = product(complement(c), one_prime)

    %% Identidades parciales.
    %% Partial identities.
    one_prime_Addr: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): 
                                one_prime(wp) AND Addr(wp`1)
    one_prime_Data: Carrier = LAMBDA (wp: [FA_Element, FA_Element]): 
                                one_prime(wp) AND Data(wp`1)

    %% Predicados característicos de los tipos de la especificación.
      %% Dependientes de la especificación.
    %% Predicates that characterices the specification types.
      %% Specification dependent.   
    Carrier: PRED[Carrier] = LAMBDA (c: Carrier): TRUE
    Addr: PRED[Carrier] = LAMBDA (c: Carrier): 
                                      Pair(c) AND Leq(c, one_prime_Addr)  
    Data: PRED[Carrier] = LAMBDA (c: Carrier): 
                                      Pair(c) AND Leq(c, one_prime_Data)   
    Memory: PRED[Carrier] = LAMBDA (c: Carrier): 
                                        Leq(c, composition(composition(one_prime_Addr, 
                                                                       one), 
                                                           one_prime_Data)) AND 
                                        Functional(c)
    Cache: PRED[Carrier] = LAMBDA (c: Carrier): 
                                        Leq(c, composition(composition(one_prime_Addr, 
                                                                       one), 
                                                           one_prime_Data)) AND 
                                        Functional(c)
    Dirty: PRED[Carrier] = LAMBDA (c: Carrier): 
                                        Leq(c, one_prime_Addr)
    Cache(c: Carrier): Carrier = composition(composition(inl, c), converse(inl))
    Dirty(c: Carrier): Carrier = composition(composition(inr, c), converse(inr))
    DirtyCache: PRED[Carrier] = LAMBDA (c: Carrier): 
                                  EXISTS (ca: (Cache), d: (Dirty)):
                                 c = sum(composition(fork(composition(Pi_1, one_prime_C_0), 
                                                          composition(Pi_2, composition(ca, inl))), 
                                                     Pi_2), 
                                         composition(fork(composition(Pi_1, one_prime_C_1), 
                                                          composition(Pi_2, composition(d, inr))), 
                                                     Pi_2)) AND
                                 Leq(Dirty(c), Dom(Cache(c)))
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    Cache_Dirty_DirtyCache: LEMMA
       FORALL (dc: (DirtyCache), c: (Cache), d: (Dirty)):
         dc = sum(composition(fork(composition(Pi_1, one_prime_C_0), 
                                                     composition(Pi_2, composition(c, inl))), 
                                               Pi_2), 
                                   composition(fork(composition(Pi_1, one_prime_C_1), 
                                                    composition(Pi_2, composition(d, inr))), 
                                               Pi_2)) IMPLIES
         c = Cache(dc) AND d = Dirty(dc)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    Memory(c: Carrier): Carrier = composition(composition(inl, c), converse(inl)) 
    DirtyCache(c: Carrier): Carrier = composition(composition(inr, c), converse(inr))
    DirtyCacheSystem: PRED[Carrier] = LAMBDA (c: Carrier): 
                                        EXISTS (mem: (Memory), dca: (DirtyCache)):
                                      c = sum(composition(fork(composition(Pi_1, one_prime_C_0), 
                                                               composition(Pi_2, composition(mem, inl))),
                                                          Pi_2), 
                                              composition(fork(composition(Pi_1, one_prime_C_1), 
                                                               composition(Pi_2, composition(dca, inr))),
                                                          Pi_2)) AND
                                      Leq(Dom(Cache(DirtyCache(c))), Dom(Memory(c)))
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    Memory_DirtyCache_DirtyCacheSystem: LEMMA
       FORALL (dcs: (DirtyCacheSystem), mem: (Memory), dca: (DirtyCache)):
         dcs = sum(composition(fork(composition(Pi_1, one_prime_C_0), 
                                                      composition(Pi_2, composition(mem, inl))), 
                                                Pi_2), 
                                    composition(fork(composition(Pi_1, one_prime_C_1), 
                                                     composition(Pi_2, composition(dca, inr))), 
                                                Pi_2)) IMPLIES
         mem = Memory(dcs) AND dca = DirtyCache(dcs)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %% Definición de la "meaning function" para los predicados característicos 
    %%     de los tipos de la especificación.
      %% Dependientes de la especificación.
    %% Definition of the meaning function for predicates that characterices the
    %%     types of the specification.
      %% Specification dependant.
    mTypePred: [TypePred -> [Carrier -> bool]] =
          LAMBDA (t: TypePred): CASES t
                                  OF Carrier: Carrier,
                                     Addr: Addr,
                                     Data: Data,
                                     Memory: Memory,
                                     Cache: Cache,
                                     Dirty: Dirty,
                                     DirtyCache: DirtyCache,
                                     DirtyCacheSystem: DirtyCacheSystem
                                  ENDCASES

    %% Definición de las funciones que asigna tipos a las metavariables y variables.
      %% Dependientes de la especificación.
    %% Definition of the functions that assigns types to metavariables and variables.
      %% Specification dependant.
    TPMetavariable: [Metavariable -> TypePred] = 
          LAMBDA (m: Metavariable): CASES m
                                      OF cs0: DirtyCacheSystem
                                      ENDCASES
    TPVariable: [Variable -> TypePred] =
          LAMBDA (v: Variable): CASES v
                                  OF cs: DirtyCacheSystem,
                                     addr: Addr,
                                     data: Data
                                  ENDCASES

    %% Definición de la "meaning function" para constantes, predicados y funciones.
    %% Definition of the meaning function for constants, predicates and functions.
    %% Definición de la "meaning function" para las constantes.
    %% Definition of the meaning function for constants.
    mConstant: [Constant -> Carrier] = 
          LAMBDA (c: Constant): CASES c 
                                  OF zero: zero,
                                     one: one,
                                     one_prime: one_prime,
                                     C_0: C_0, 
                                     C_1: C_1, 
                                     inl: inl, 
                                     inr: inr, 
                                     Pi_1: Pi_1, 
                                     Pi_2: Pi_2,
                                     one_prime_C_0: one_prime_C_0,
                                     one_prime_C_1: one_prime_C_1,
                                     one_prime_Addr: one_prime_Addr,
                                     one_prime_Data: one_prime_Data
                                  ENDCASES
    %% Definición de la "meaning function" para los predicados.
    %% Definition of the meaning function for predicates.
    mPredicate: [P: Predicate -> [{l: list[Carrier] | sigPredicate(P) = length(l)} -> bool]] = 
          LAMBDA (P: Predicate): CASES P 
                                   OF Leq: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 2}): 
                                          Leq(nth(l, 0), nth(l, 1)),
                                      Functional: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          Functional(nth(l, 0)),
                                      OneToOne: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          OneToOne(nth(l, 0)),
                                      Pair: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          Pair(nth(l, 0))
                                    ENDCASES
    %% Definición de la "meaning function" para las funciones.
    %% Definition of the meaning function for functions.
    mFunction_: [F: Function_ -> [{l: list[Carrier] | sigFunction_(F) = length(l)} -> Carrier]] = 
          LAMBDA (F: Function_): CASES F 
                                   OF sum: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 2}): 
                                          sum(nth(l, 0), nth(l, 1)), 
                                      product: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 2}): 
                                          product(nth(l, 0), nth(l, 1)), 
                                      complement: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          complement(nth(l, 0)), 
                                      composition: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 2}):
                                          composition(nth(l, 0), nth(l, 1)), 
                                      converse: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          converse(nth(l, 0)), 
                                      fork: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 2}): 
                                          fork(nth(l, 0), nth(l, 1)),
                                      Dom: 
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          Dom(nth(l, 0)),
                                      FunctionUpdate:
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 2}): 
                                          FunctionUpdate(nth(l, 0), nth(l, 1)),
                                      FunctionUndef:
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 2}): 
                                          FunctionUndef(nth(l, 0), nth(l, 1)),
                                      Neg:
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          Neg(nth(l, 0)),
                                      Memory:
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          Memory(nth(l, 0)),
                                      DirtyCache:
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          DirtyCache(nth(l, 0)),
                                      Cache:
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          Cache(nth(l, 0)),
                                      Dirty:
                                        LAMBDA (l: {lPrime: list[Carrier] | length(lPrime) = 1}): 
                                          Dirty(nth(l, 0))
                                   ENDCASES

  END FA_semantic

$$$FA_semantic.prf
(FA_semantic (Cache_Dirty_DirtyCache 0 (Cache_Dirty_DirtyCache-2 "" 3292691938 3292691938 ("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (prop) (("1" (purify-fa 1 t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (expand "extend") (("1" (inst 1 "pair(element(c_0), x!2)") (("1" (smash :quant-simp? t) (("1" (inst 1 "pair(element(c_0), x!1)") (("1" (smash :quant-simp? t) (("1" (hide 2) (("1" (inst 1 "pair(element(c_0), pair(element(c_0), x!2))") (("1" (smash :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skosimp*) (("2" (smash :quant-simp? t) (("1" (skosimp*) (("1" (smash :quant-simp? t) nil nil)) nil) ("2" (skosimp*) (("2" (smash :quant-simp? t) (("2" (replace -2 -6) (("2" (decompose-equality -6) (("2" (lemma "empty_intersection_of_types") (("2" (inst -1 "c_1") (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (expand "extend") (("1" (inst 1 "pair(element(c_1), x!2)") (("1" (smash :quant-simp? t) (("1" (inst 1 "pair(element(c_1), x!1)") (("1" (smash :quant-simp? t) (("1" (hide 1) (("1" (inst 1 "pair(element(c_1), pair(element(c_1), x!2))") (("1" (smash :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skosimp*) (("2" (smash :quant-simp? t) (("1" (skosimp*) (("1" (smash :quant-simp? t) (("1" (replace -2 -6) (("1" (decompose-equality -6) (("1" (lemma "empty_intersection_of_types") (("1" (inst -1 "c_0") (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (smash :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved nil 803407 28630 t shostak) (Cache_Dirty_DirtyCache-1 nil 3292688942 3292689439 ("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (prop) (("1" (purify-fa 1 t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (expand "extend") (("1" (inst 1 "pair(element(c_0), x!2)") (("1" (smash) (("1" (inst 1 "pair(element(c_0), x!1)") (("1" (smash) (("1" (hide 2) (("1" (inst 1 "pair(element(c_0), pair(element(c_0), x!2))") (("1" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skosimp*) (("2" (smash) (("1" (skosimp*) (("1" (smash) nil nil)) nil) ("2" (skosimp*) (("2" (smash) (("2" (replace -2 -5) (("2" (replace -6 -5) (("2" (decompose-equality -5) (("2" (lemma "empty_intersection_of_types") (("2" (inst -1 "c_1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (expand "extend") (("1" (inst 1 "pair(element(c_1), x!2)") (("1" (smash) (("1" (inst 1 "pair(element(c_1), x!1)") (("1" (smash) (("1" (hide 1) (("1" (inst 1 "pair(element(c_1), pair(element(c_1), x!2))") (("1" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skosimp*) (("2" (smash) (("1" (skosimp*) (("1" (smash) (("1" (replace -2 -5) (("1" (replace -6 -5) (("1" (decompose-equality -5) (("1" (lemma "empty_intersection_of_types") (("1" (inst -1 "c_0") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((Carrier type-eq-decl nil FA_semantic nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (Dirty const-decl "PRED[Carrier]" FA_semantic nil) (c_1 const-decl "Element" FA_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (el1 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (c_0 const-decl "Element" FA_semantic nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (el0 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (pair? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Cache const-decl "PRED[Carrier]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (pair adt-constructor-decl "[[FA_Element, FA_Element] -> (pair?)]" FA_Element_adt nil) (empty_intersection_of_types formula-decl nil FA_semantic nil) (t adt-accessor-decl "[(element?) -> T]" FA_Element_adt nil) (C_1 const-decl "Carrier" FA_semantic nil) (inr const-decl "Carrier" FA_semantic nil) (one_prime_C_1 const-decl "Carrier" FA_semantic nil) (C_0 const-decl "Carrier" FA_semantic nil) (inl const-decl "Carrier" FA_semantic nil) (Pi_2 const-decl "Carrier" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (one_prime_C_0 const-decl "Carrier" FA_semantic nil) (Pi_1 const-decl "Carrier" FA_semantic nil) (fork const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (Cache const-decl "Carrier" FA_semantic nil) (Dirty const-decl "Carrier" FA_semantic nil)) 4644 4440 nil nil)) (Memory_DirtyCache_DirtyCacheSystem 0 (Memory_DirtyCache_DirtyCacheSystem-2 "" 3292692171 3292692171 ("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (prop) (("1" (purify-fa 1 t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (expand "extend") (("1" (inst 1 "pair(element(c_0), x!2)") (("1" (smash :quant-simp? t) (("1" (inst 1 "pair(element(c_0), x!1)") (("1" (smash :quant-simp? t) (("1" (hide 2) (("1" (inst 1 "pair(element(c_0), pair(element(c_0), x!2))") (("1" (smash :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skosimp*) (("2" (smash :quant-simp? t) (("1" (skosimp*) (("1" (smash :quant-simp? t) nil nil)) nil) ("2" (skosimp*) (("2" (smash :quant-simp? t) (("2" (replace -2 -6) (("2" (decompose-equality -6) (("2" (lemma "empty_intersection_of_types") (("2" (inst -1 "c_1") (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (expand "extend") (("1" (inst 1 "pair(element(c_1), x!2)") (("1" (smash :quant-simp? t) (("1" (inst 1 "pair(element(c_1), x!1)") (("1" (smash :quant-simp? t) (("1" (hide 1) (("1" (inst 1 "pair(element(c_1), pair(element(c_1), x!2))") (("1" (smash :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skosimp*) (("2" (smash :quant-simp? t) (("1" (skosimp*) (("1" (smash :quant-simp? t) (("1" (replace -2 -6) (("1" (decompose-equality -6) (("1" (lemma "empty_intersection_of_types") (("1" (inst -1 "c_0") (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (smash :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved nil 212502 19430 t shostak) (Memory_DirtyCache_DirtyCacheSystem-1 nil 3292688942 3292689443 ("" (skosimp*) (("" (replace -1) (("" (hide -1) (("" (prop) (("1" (purify-fa 1 t) (("1" (apply-extensionality 1) (("1" (hide 2) (("1" (bddsimp) (("1" (expand "extend") (("1" (inst 1 "pair(element(c_0), x!2)") (("1" (smash) (("1" (inst 1 "pair(element(c_0), x!1)") (("1" (smash) (("1" (hide 2) (("1" (inst 1 "pair(element(c_0), pair(element(c_0), x!2))") (("1" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skosimp*) (("2" (smash) (("1" (skosimp*) (("1" (smash) nil nil)) nil) ("2" (skosimp*) (("2" (smash) (("2" (replace -2 -5) (("2" (replace -6 -5) (("2" (decompose-equality -5) (("2" (lemma "empty_intersection_of_types") (("2" (inst -1 "c_1") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (purify-fa 1 t) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (bddsimp) (("1" (expand "extend") (("1" (inst 1 "pair(element(c_1), x!2)") (("1" (smash) (("1" (inst 1 "pair(element(c_1), x!1)") (("1" (smash) (("1" (hide 1) (("1" (inst 1 "pair(element(c_1), pair(element(c_1), x!2))") (("1" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (skosimp*) (("2" (smash) (("1" (skosimp*) (("1" (smash) (("1" (replace -2 -5) (("1" (replace -6 -5) (("1" (decompose-equality -5) (("1" (lemma "empty_intersection_of_types") (("1" (inst -1 "c_0") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((Carrier type-eq-decl nil FA_semantic nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (DirtyCache const-decl "PRED[Carrier]" FA_semantic nil) (c_1 const-decl "Element" FA_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (el1 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (c_0 const-decl "Element" FA_semantic nil) (element adt-constructor-decl "[T -> (element?)]" FA_Element_adt nil) (element? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (el0 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (pair? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Memory const-decl "PRED[Carrier]" FA_semantic nil) (PRED type-eq-decl nil defined_types nil) (pair adt-constructor-decl "[[FA_Element, FA_Element] -> (pair?)]" FA_Element_adt nil) (empty_intersection_of_types formula-decl nil FA_semantic nil) (t adt-accessor-decl "[(element?) -> T]" FA_Element_adt nil) (C_1 const-decl "Carrier" FA_semantic nil) (inr const-decl "Carrier" FA_semantic nil) (one_prime_C_1 const-decl "Carrier" FA_semantic nil) (C_0 const-decl "Carrier" FA_semantic nil) (inl const-decl "Carrier" FA_semantic nil) (Pi_2 const-decl "Carrier" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (one_prime_C_0 const-decl "Carrier" FA_semantic nil) (Pi_1 const-decl "Carrier" FA_semantic nil) (fork const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (Memory const-decl "Carrier" FA_semantic nil) (DirtyCache const-decl "Carrier" FA_semantic nil)) 4810 4540 nil nil)) (mPredicate_TCC1 0 (mPredicate_TCC1-1 nil 3292688942 3292689443 ("" (subtype-tcc) nil nil) proved nil 17 20 nil nil)) (mPredicate_TCC2 0 (mPredicate_TCC2-1 nil 3292688942 3292689443 ("" (subtype-tcc) nil nil) proved nil 17 20 nil nil)) (mPredicate_TCC3 0 (mPredicate_TCC3-1 nil 3292688942 3292689443 ("" (subtype-tcc) nil nil) proved ((sigPredicate const-decl "[Predicate -> nat]" FA_Language nil)) 111 70 nil nil)) (mPredicate_TCC4 0 (mPredicate_TCC4-1 nil 3292688942 3292689443 ("" (subtype-tcc) nil nil) proved nil 17 20 nil nil)) (mPredicate_TCC5 0 (mPredicate_TCC5-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved ((sigPredicate const-decl "[Predicate -> nat]" FA_Language nil)) 83 80 nil nil)) (mPredicate_TCC6 0 (mPredicate_TCC6-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 16 10 nil nil)) (mPredicate_TCC7 0 (mPredicate_TCC7-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved ((sigPredicate const-decl "[Predicate -> nat]" FA_Language nil)) 115 90 nil nil)) (mPredicate_TCC8 0 (mPredicate_TCC8-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 17 20 nil nil)) (mPredicate_TCC9 0 (mPredicate_TCC9-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved ((sigPredicate const-decl "[Predicate -> nat]" FA_Language nil)) 82 80 nil nil)) (mFunction__TCC1 0 (mFunction__TCC1-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 24 30 nil nil)) (mFunction__TCC2 0 (mFunction__TCC2-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 23 20 nil nil)) (mFunction__TCC3 0 (mFunction__TCC3-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 133 110 nil nil)) (mFunction__TCC4 0 (mFunction__TCC4-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 22 20 nil nil)) (mFunction__TCC5 0 (mFunction__TCC5-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 24 30 nil nil)) (mFunction__TCC6 0 (mFunction__TCC6-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 126 120 nil nil)) (mFunction__TCC7 0 (mFunction__TCC7-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 22 20 nil nil)) (mFunction__TCC8 0 (mFunction__TCC8-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 114 110 nil nil)) (mFunction__TCC9 0 (mFunction__TCC9-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 22 20 nil nil)) (mFunction__TCC10 0 (mFunction__TCC10-1 nil 3292688942 3292689444 ("" (subtype-tcc) nil nil) proved nil 24 20 nil nil)) (mFunction__TCC11 0 (mFunction__TCC11-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 129 120 nil nil)) (mFunction__TCC12 0 (mFunction__TCC12-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved nil 23 20 nil nil)) (mFunction__TCC13 0 (mFunction__TCC13-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 114 110 nil nil)) (mFunction__TCC14 0 (mFunction__TCC14-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved nil 24 20 nil nil)) (mFunction__TCC15 0 (mFunction__TCC15-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved nil 22 20 nil nil)) (mFunction__TCC16 0 (mFunction__TCC16-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 123 120 nil nil)) (mFunction__TCC17 0 (mFunction__TCC17-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved nil 21 20 nil nil)) (mFunction__TCC18 0 (mFunction__TCC18-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 115 110 nil nil)) (mFunction__TCC19 0 (mFunction__TCC19-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved nil 22 20 nil nil)) (mFunction__TCC20 0 (mFunction__TCC20-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved nil 22 20 nil nil)) (mFunction__TCC21 0 (mFunction__TCC21-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 127 110 nil nil)) (mFunction__TCC22 0 (mFunction__TCC22-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved nil 23 20 nil nil)) (mFunction__TCC23 0 (mFunction__TCC23-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved nil 22 20 nil nil)) (mFunction__TCC24 0 (mFunction__TCC24-1 nil 3292688942 3292689445 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 115 110 nil nil)) (mFunction__TCC25 0 (mFunction__TCC25-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved nil 24 20 nil nil)) (mFunction__TCC26 0 (mFunction__TCC26-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 128 120 nil nil)) (mFunction__TCC27 0 (mFunction__TCC27-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved nil 24 20 nil nil)) (mFunction__TCC28 0 (mFunction__TCC28-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 115 110 nil nil)) (mFunction__TCC29 0 (mFunction__TCC29-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved nil 23 20 nil nil)) (mFunction__TCC30 0 (mFunction__TCC30-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 122 110 nil nil)) (mFunction__TCC31 0 (mFunction__TCC31-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved nil 23 20 nil nil)) (mFunction__TCC32 0 (mFunction__TCC32-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 114 110 nil nil)) (mFunction__TCC33 0 (mFunction__TCC33-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved nil 23 20 nil nil)) (mFunction__TCC34 0 (mFunction__TCC34-1 nil 3292688942 3292689446 ("" (subtype-tcc) nil nil) proved ((sigFunction_ const-decl "[Function_ -> nat]" FA_Language nil)) 126 110 nil nil)))

$$$FA_axioms.pvs
FA_axioms: THEORY

  BEGIN

    %% Construcción de la semántica de la fork algebra de la especificación Ag.
    %% Construction of the fork algebra corresponding to the Ag specification.
    IMPORTING FA_semantic

    %% Definición de los axiomas de la fork algebra como lemmas.
    %% Definition of the fork algebra axioms as lemmas.
    BA_1: LEMMA 
        FORALL (x: Carrier): sum(x, x) = x
    BA_2: LEMMA 
        FORALL (x: Carrier): product(x, x) = x
    BA_3: LEMMA 
        FORALL (x, y: Carrier): sum(x, y) = sum(y, x)
    BA_4: LEMMA 
        FORALL (x, y: Carrier): product(x, y) = product(y, x)
    BA_5: LEMMA 
        FORALL (x, y, z: Carrier): sum(x, sum(y, z)) = sum(sum(x, y), z)
    BA_6: LEMMA 
        FORALL (x, y, z: Carrier): product(x, product(y, z)) = product(product(x, y), z)
    BA_7: LEMMA 
        FORALL (x, y: Carrier): sum(x, product(x, y)) = x
    BA_8: LEMMA 
        FORALL (x, y: Carrier): product(x, sum(x, y)) = x
    BA_9: LEMMA 
        FORALL (x, y, z: Carrier): product(x, sum(y, z)) = sum(product(x, y), product(x, z))
    BA_10: LEMMA 
        FORALL (x, y, z: Carrier): sum(x, product(y, z)) = product(sum(x, y), sum(x, z))
    BA_11: LEMMA 
        FORALL (x: Carrier): product(x, zero) = zero
    BA_12: LEMMA 
        FORALL (x: Carrier): sum(x, one) = one
    BA_13: LEMMA 
        FORALL (x: Carrier): product(x, complement(x)) = zero
    BA_14: LEMMA 
        FORALL (x: Carrier): sum(x, complement(x)) = one
    RA_1: LEMMA 
        FORALL (x, y, z: Carrier): composition(x, composition(y, z)) = 
                                     composition(composition(x, y), z)
    RA_2: LEMMA 
        FORALL (x, y, z: Carrier): composition(sum(x, y), z) = 
                                     sum(composition(x, z), composition(y, z))
    RA_3: LEMMA 
        FORALL (x, y: Carrier): converse(sum(x, y)) = 
                                  sum(converse(x), converse(y))
    RA_4: LEMMA 
        FORALL (x, y: Carrier): converse(composition(x, y)) = 
                                  composition(converse(y), converse(x))
    RA_5: LEMMA 
        FORALL (x: Carrier): converse(converse(x)) = x
    RA_6: LEMMA 
        FORALL (x: Carrier): composition(x, one_prime) = x
    RA_7: LEMMA 
        FORALL (x, y, z: Carrier): ((product(composition(x, y), z) = zero) IFF 
                                      (product(composition(z, converse(y)), x) = zero)) 
                                     AND 
                                   ((product(composition(z, converse(y)), x) = zero) IFF
                                      (product(composition(converse(x), z), y) = zero))
    FA_1: LEMMA 
        FORALL (x, y: Carrier): fork(x, y) = product(composition(x, fork(one_prime, one)), 
                                                     composition(y, fork(one, one_prime)))
    FA_2: LEMMA 
        FORALL (w, x, y, z: Carrier): composition(fork(w, x), converse(fork(y, z))) =
                                        product(composition(w, converse(y)), 
                                                composition(x, converse(z)))
    FA_3: LEMMA 
        sum(fork(converse(fork(one_prime, one)), 
                 converse(fork(one, one_prime))), 
            one_prime) = one_prime 

  END FA_axioms

$$$FA_axioms.prf
(FA_axioms (BA_1 0 (BA_1-1 nil 3292688942 3292689429 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil)) 123 110 nil nil)) (BA_2 0 (BA_2-1 nil 3292688942 3292689429 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (product const-decl "Carrier" FA_semantic nil)) 146 120 nil nil)) (BA_3 0 (BA_3-1 nil 3292688942 3292689429 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil)) 134 110 nil nil)) (BA_4 0 (BA_4-1 nil 3292688942 3292689429 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (product const-decl "Carrier" FA_semantic nil)) 133 120 nil nil)) (BA_5 0 (BA_5-1 nil 3292688942 3292689429 ("" (purify-fa :strong t) nil nil) proved ((sum const-decl "Carrier" FA_semantic nil)) 77 70 nil nil)) (BA_6 0 (BA_6-1 nil 3292688942 3292689429 ("" (purify-fa :strong t) nil nil) proved ((product const-decl "Carrier" FA_semantic nil)) 62 60 nil nil)) (BA_7 0 (BA_7-1 nil 3292688942 3292689430 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil)) 133 110 nil nil)) (BA_8 0 (BA_8-1 nil 3292688942 3292689430 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil)) 132 110 nil nil)) (BA_9 0 (BA_9-1 nil 3292688942 3292689430 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil)) 178 150 nil nil)) (BA_10 0 (BA_10-1 nil 3292688942 3292689430 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil)) 170 140 nil nil)) (BA_11 0 (BA_11-1 nil 3292688942 3292689430 ("" (purify-fa :strong t) nil nil) proved ((product const-decl "Carrier" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil)) 58 50 nil nil)) (BA_12 0 (BA_12-1 nil 3292688942 3292689430 ("" (purify-fa :strong t) nil nil) proved ((sum const-decl "Carrier" FA_semantic nil) (one const-decl "Carrier" FA_semantic nil)) 70 50 nil nil)) (BA_13 0 (BA_13-1 nil 3292688942 3292689430 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (bddsimp) nil nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (NOT const-decl "[bool -> bool]" booleans nil) (FALSE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil)) 141 120 nil nil)) (BA_14 0 (BA_14-1 nil 3292688942 3292689430 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) nil nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (one const-decl "Carrier" FA_semantic nil) (complement const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil)) 134 110 nil nil)) (RA_1 0 (RA_1-1 nil 3292688942 3292689431 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil)) 252 200 nil nil)) (RA_2 0 (RA_2-1 nil 3292688942 3292689431 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) (("1" (skosimp*) (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (inst?) (("2" (prop) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst?) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil)) 243 200 nil nil)) (RA_3 0 (RA_3-1 nil 3292688942 3292689431 ("" (purify-fa :strong t) nil nil) proved ((converse const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil)) 61 60 nil nil)) (RA_4 0 (RA_4-1 nil 3292688942 3292689431 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) (("1" (skosimp*) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil)) 235 160 nil nil)) (RA_5 0 (RA_5-1 nil 3292688942 3292689431 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) nil nil)) nil)) nil) proved ((boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (Carrier type-eq-decl nil FA_semantic nil) (bool nonempty-type-eq-decl nil booleans nil) (converse const-decl "Carrier" FA_semantic nil)) 94 90 nil nil)) (RA_6 0 (RA_6-2 "" 3292690869 3292690869 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (assert :quant-simp? t) nil nil)) nil)) nil)) nil) proved nil 73141 1710 t shostak) (RA_6-1 nil 3292688942 3292689431 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) nil nil)) nil)) nil) proved ((bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil)) 130 110 nil nil)) (RA_7 0 (RA_7-1 nil 3292688942 3292689432 ("" (purify-fa :strong t) (("" (skosimp*) (("" (prop) (("1" (apply-extensionality) (("1" (decompose-equality -2) (("1" (skosimp*) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality) (("2" (decompose-equality -2) (("2" (skosimp*) (("2" (inst?) (("2" (prop) (("2" (inst?) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (apply-extensionality) (("3" (decompose-equality -2) (("3" (skosimp*) (("3" (inst?) (("3" (prop) (("3" (inst?) (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (apply-extensionality) (("4" (decompose-equality -2) (("4" (skosimp*) (("4" (inst?) (("4" (prop) (("4" (inst?) (("4" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (FALSE const-decl "bool" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (converse const-decl "Carrier" FA_semantic nil) (zero const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil)) 680 590 nil nil)) (FA_1 0 (FA_1-2 "" 3292691098 3292691098 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) (("1" (expand "extend") (("1" (case "pair?(x!3)") (("1" (smash :quant-simp? t) nil nil) ("2" (smash :quant-simp? t) nil nil)) nil)) nil) ("2" (expand "extend") (("2" (case "pair?(x!3)") (("1" (smash :quant-simp? t) nil nil) ("2" (smash :quant-simp? t) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (expand "extend") (("3" (case "pair?(x!3)") (("1" (smash :quant-simp? t) nil nil) ("2" (smash :quant-simp? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved nil 120191 6050 t shostak) (FA_1-1 nil 3292688942 3292689433 ("" (purify-fa :strong t) (("" (skosimp*) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) (("1" (expand "extend") (("1" (case "pair?(x!3)") (("1" (smash) nil nil) ("2" (smash) nil nil)) nil)) nil) ("2" (expand "extend") (("2" (case "pair?(x!3)") (("1" (smash) nil nil) ("2" (smash) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (expand "extend") (("3" (case "pair?(x!3)") (("1" (smash) nil nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((pair? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Carrier type-eq-decl nil FA_semantic nil) (el0 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (el1 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (Element nonempty-type-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (boolean nonempty-type-decl nil booleans nil) (one const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (composition const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (fork const-decl "Carrier" FA_semantic nil)) 629 440 nil nil)) (FA_2 0 (FA_2-1 nil 3292688942 3292689433 ("" (skosimp*) (("" (purify-fa :strong t) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) (("1" (skosimp*) (("1" (expand "extend") (("1" (case "pair?(x!4)") (("1" (smash) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "extend") (("2" (case "pair?(x!4)") (("1" (smash) (("1" (inst?) (("1" (prop) nil nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (inst 1 "pair(x!4, x!5)") (("3" (expand "extend") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((composition const-decl "Carrier" FA_semantic nil) (fork const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (product const-decl "Carrier" FA_semantic nil) (pair adt-constructor-decl "[[FA_Element, FA_Element] -> (pair?)]" FA_Element_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pair? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (Carrier type-eq-decl nil FA_semantic nil) (el0 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (el1 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (FA_Element type-decl nil FA_Element_adt nil) (boolean nonempty-type-decl nil booleans nil)) 537 460 nil nil)) (FA_3 0 (FA_3-1 nil 3292688942 3292689434 ("" (purify-fa :strong t) (("" (apply-extensionality) (("" (hide 2) (("" (bddsimp) (("" (expand "extend") (("" (case "pair?(x!2)") (("1" (smash) (("1" (case-replace "x!1 = pair(el0(x!1), el1(x!1))") (("1" (case-replace "x!2 = pair(el0(x!2), el1(x!2))") (("1" (assert) nil nil) ("2" (apply-extensionality) nil nil)) nil) ("2" (apply-extensionality) nil nil)) nil)) nil) ("2" (smash) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((boolean nonempty-type-decl nil booleans nil) (FA_Element type-decl nil FA_Element_adt nil) (Element nonempty-type-decl nil FA_semantic nil) (el1 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (el0 adt-accessor-decl "[(pair?) -> FA_Element]" FA_Element_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (pair? adt-recognizer-decl "[FA_Element -> boolean]" FA_Element_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pair adt-constructor-decl "[[FA_Element, FA_Element] -> (pair?)]" FA_Element_adt nil) (FA_Element_pair_extensionality formula-decl nil FA_Element_adt nil) (one const-decl "Carrier" FA_semantic nil) (one_prime const-decl "Carrier" FA_semantic nil) (converse const-decl "Carrier" FA_semantic nil) (fork const-decl "Carrier" FA_semantic nil) (sum const-decl "Carrier" FA_semantic nil)) 515 470 nil nil)))

$$$FA_lemmas.pvs
FA_lemmas: THEORY

  BEGIN

    IMPORTING FA_axioms

  END FA_lemmas

$$$SpecActions.pvs
SpecActions: THEORY

  BEGIN

    IMPORTING FA_Language,
              wf_FODL_Language[Constant, 
                               Metavariable,
                               Variable, 
                               Predicate, sigPredicate,
                               Function_, sigFunction_]

    %% Definición de las acciones atómicas de la especificación Ag.
    %% Definition of the atomic actions of the Ag specification.
    %                                                                               %
    % DirtyCacheWrite: Ag Action[cs: DirtyCacheSystem]                              %
    % cs = cs0 => [DirtyCacheWrite] EXISTS (a: Addr, d: Data):                      %
    %           Cache(DirtyCache(cs)) =                                             %         
    %              FunctionUpdate(Cache(DirtyCache(cs0)), <a, d>) AND               %  
    %           Dirty(DirtyCache(cs)) = Dirty(DirtyCache(cs0)) U a) AND             %
    %           Memory(cs) = Memory(cs0)                                            %
    pre_DirtyCacheWrite: [(v?) -> wf_Formula_] = 
       LAMBDA (v: (v?)): v = m(cs0)
    post_DirtyCacheWrite: [(v?) -> wf_Formula_] = 
       LAMBDA (v: (v?)): 
         EXISTS_(v(addr), 
           (EXISTS_(v(data), 
              (wf_F(Cache, (:wf_F(DirtyCache, (:v:)):)) = 
                 wf_F(FunctionUpdate, (:wf_F(Cache, (:wf_F(DirtyCache, (:m(cs0):)):)), 
                                        wf_F(composition, (:wf_F(composition, (:v(addr), c(one):)), 
                                                            v(data):)):)) AND 
               wf_F(Dirty, (:wf_F(DirtyCache, (:v:)):)) = 
                 wf_F(sum, (:wf_F(Dirty, (:wf_F(DirtyCache, (:m(cs0):)):)), v(addr):)) AND
               wf_F(Memory, (:v:)) = wf_F(Memory, (:m(cs0):))))))
    DirtyCacheWrite: [(v?) -> wf_Program_] = 
       LAMBDA (v: (v?)): A(pre_DirtyCacheWrite(v), post_DirtyCacheWrite(v))
    %                                                                               %
    % DirtyFlush: Ag Action[DirtyCacheSystem -> DirtyCacheSystem]                   % 
    % cs = cs0 => [DirtyFlush] EXISTS (a: Addr):                                    %
    %           Cache(DirtyCache(cs)) =                                             %
    %              FunctionUndef(Cache(DirtyCache(cs0)), a;1) AND                   %
    %           Dirty(DirtyCache(cs)) = Dirty(DirtyCache(cs0)) / a                  %
    %           Memory(cs) =                                                        %
    %              FunctionUpdate(Memory(cs0), <a, a;Cache(DirtyCache(cs0))>)       %
    pre_DirtyFlush: [(v?) -> wf_Formula_] = 
       LAMBDA (v: (v?)): v = m(cs0)
    post_DirtyFlush: [(v?) -> wf_Formula_] = 
       LAMBDA (v: (v?)): 
         EXISTS_(v(addr),
           (wf_F(Cache, (:wf_F(DirtyCache, (:v:)):)) = 
              wf_F(FunctionUndef, (:wf_F(Cache, (:wf_F(DirtyCache, (:m(cs0):)):)), 
                                    wf_F(composition, (:v(addr), c(one):)):)) AND 
            wf_F(Dirty, (:wf_F(DirtyCache, (:v:)):)) = 
              wf_F(product, (:wf_F(Dirty, (:wf_F(DirtyCache, (:m(cs0):)):)), 
                              wf_F(complement, (:v(addr):)):)) AND
            wf_F(Memory, (:v:)) = wf_F(FunctionUpdate, (:wf_F(Memory, (:m(cs0):)), 
                      wf_F(composition, 
                           (:wf_F(composition, (:v(addr), c(one):)), 
                             wf_F(composition, (:v(addr), 
                                                 wf_F(Cache, 
                                                      (:wf_F(DirtyCache, (:m(cs0):)):)):)):)):))))
    DirtyFlush: [(v?) -> wf_Program_] =  
       LAMBDA (v: (v?)): A(pre_DirtyFlush(v), post_DirtyFlush(v))
    %                                                                               %
    % DirtyLoad: Ag Action[DirtyCacheSystem -> DirtyCacheSystem]                    %
    % cs = cs0 => [DirtyLoad] EXISTS (a: Addr):                                     %
    %           Cache(DirtyCache(cs)) =                                             %
    %              FunctionUpdate(Cache(DirtyCache(cs0)), <a, a;Memory(cs0)>) AND   %
    %           Dirty(DirtyCache(cs)) = Dirty(DirtyCache(cs0)) AND                  %
    %           Memory(cs) = Memory(cs0)                                            %
    pre_DirtyLoad: [(v?) -> wf_Formula_] = 
       LAMBDA (v: (v?)): v = m(cs0)
    post_DirtyLoad: [(v?) -> wf_Formula_] = 
       LAMBDA (v: (v?)): 
         EXISTS_(v(addr), 
           (wf_F(Cache, (:wf_F(DirtyCache, (:v:)):)) =  
              wf_F(FunctionUpdate, (:wf_F(Cache, (:wf_F(DirtyCache, (:m(cs0):)):)), 
                                     wf_F(composition, (:wf_F(composition, (:v(addr), c(one):)), 
                                          wf_F(composition, (:v(addr), 
                                                              wf_F(Memory, (:m(cs0):)):)):)):)) AND
            wf_F(Dirty, (:wf_F(DirtyCache, (:v:)):)) = 
              wf_F(Dirty, (:wf_F(DirtyCache, (:m(cs0):)):)) AND
            wf_F(Memory, (:v:)) = wf_F(Memory, (:m(cs0):))))
    DirtyLoad: [(v?) -> wf_Program_] =   
       LAMBDA (v: (v?)): A(pre_DirtyLoad(v), post_DirtyLoad(v))
    %                                                                               %
    % DirtySetFlush: Ag Action[DirtyCacheSystem -> DirtyCacheSystem]                %
    % cs = cs0 => [DirtySetFlush]                                                   %
    %           Cache(DirtyCache(cs)) = Cache(DirtyCache(cs0)) AND                  %
    %           Dirty(DirtyCache(cs)) = emptyset AND                                %
    %           Memory(cs) = FunctionUpdate(Memory(cs0),                            %
    %                               Dirty(DirtyCache(cs0));Cache(DirtyCache(cs0)))  %
    pre_DirtySetFlush: [(v?) -> wf_Formula_] = 
       LAMBDA (v: (v?)): v = m(cs0)
    post_DirtySetFlush: [(v?) -> wf_Formula_] =
       LAMBDA (v: (v?)): 
         wf_F(Cache, (:wf_F(DirtyCache, (:v:)):)) = wf_F(Cache, (:wf_F(DirtyCache, (:m(cs0):)):)) AND
         wf_F(Dirty, (:wf_F(DirtyCache, (:v:)):)) = c(zero) AND
         wf_F(Memory, (:v:)) = wf_F(FunctionUpdate, 
                                    (:wf_F(Memory, (:m(cs0):)),   
                                      wf_F(composition, 
                                           (:wf_F(Dirty, (:wf_F(DirtyCache, (:m(cs0):)):)), 
                                             wf_F(Cache, (:wf_F(DirtyCache, (:m(cs0):)):)):)):))
    DirtySetFlush: [(v?) -> wf_Program_] =    
       LAMBDA (v: (v?)): A(pre_DirtySetFlush(v), post_DirtySetFlush(v))

 END SpecActions

$$$SpecActions.prf
(|SpecActions| (|pre_DirtyCacheWrite_TCC1| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC1| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC2| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC3| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC4| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC5| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC6| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC7| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC8| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC9| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC10| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC11| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC12| "" (GRIND) NIL NIL)
 (|post_DirtyCacheWrite_TCC13| "" (GRIND) NIL NIL)
 (|post_DirtyFlush_TCC1| "" (GRIND) NIL NIL)
 (|post_DirtyFlush_TCC2| "" (GRIND) NIL NIL)
 (|post_DirtyFlush_TCC3| "" (GRIND) NIL NIL)
 (|post_DirtyFlush_TCC4| "" (GRIND) NIL NIL)
 (|post_DirtyFlush_TCC5| "" (GRIND) NIL NIL)
 (|post_DirtyFlush_TCC6| "" (GRIND) NIL NIL)
 (|post_DirtyFlush_TCC7| "" (GRIND) NIL NIL)
 (|post_DirtyLoad_TCC1| "" (GRIND) NIL NIL)
 (|post_DirtyLoad_TCC2| "" (GRIND) NIL NIL)
 (|post_DirtyLoad_TCC3| "" (GRIND) NIL NIL)
 (|post_DirtyLoad_TCC4| "" (GRIND) NIL NIL)
 (|post_DirtySetFlush_TCC1| "" (GRIND) NIL NIL)
 (|post_DirtySetFlush_TCC2| "" (GRIND) NIL NIL)
 (|post_DirtySetFlush_TCC3| "" (GRIND) NIL NIL))


$$$SpecPredicates.pvs
SpecPredicates: THEORY

  BEGIN

    IMPORTING FA_Language, 
              wf_FODL_Language[Constant, 
                               Metavariable,
                               Variable, 
                               Predicate, sigPredicate,
                               Function_, sigFunction_]

    %                                                                               %
    % DirtyCacheConsistent: PRED[DirtyCacheSystem]                                  %
    % DirtyCacheConsistent(cs) = Cache(DirtyCache(cs)) <= Memory(cs)                %
    DirtyCacheConsistent: [wf_Term_ -> wf_Formula_] = 
       LAMBDA (t: wf_Term_): wf_P(Leq, (:wf_F(Cache, (:wf_F(DirtyCache, (:t:)):)), 
                                         wf_F(Memory, (:t:)):))
    %                                                                               %
    % NonDirtyCache: PRED[DirtyCacheSystem]                                         %
    % NonDirtyCache(cs) = (Neg Dirty(DirtyCache(cs)));Cache(DirtyCache(cs)) <=      %
    %                       Memory(cs)                                              %
    NonDirtyCache: [wf_Term_ -> wf_Formula_] =  
       LAMBDA (t: wf_Term_): wf_P(Leq, 
                                  (:wf_F(composition, 
                                         (:wf_F(Neg, 
                                                (:wf_F(Dirty, 
                                                       (:wf_F(DirtyCache, 
                                                              (:t:)):)):)), 
                                           wf_F(Cache, (:wf_F(DirtyCache, (:t:)):)):)),
                                    wf_F(Memory, (:t:)):))

 END SpecPredicates

$$$SpecPredicates.prf
(|SpecPredicates| (|DirtyCacheConsistent_TCC1| "" (GRIND) NIL NIL)
 (|DirtyCacheConsistent_TCC2| "" (GRIND) NIL NIL)
 (|DirtyCacheConsistent_TCC3| "" (GRIND) NIL NIL)
 (|DirtyCacheConsistent_TCC4| "" (GRIND) NIL NIL)
 (|DirtyCacheConsistent_TCC5| "" (GRIND) NIL NIL)
 (|NonDirtyCache_TCC1| "" (GRIND) NIL NIL)
 (|NonDirtyCache_TCC2| "" (GRIND) NIL NIL)
 (|NonDirtyCache_TCC3| "" (GRIND) NIL NIL)
 (|NonDirtyCache_TCC4| "" (GRIND) NIL NIL)
 (|NonDirtyCache_TCC5| "" (GRIND) NIL NIL))

