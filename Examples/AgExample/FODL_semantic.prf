(FODL_semantic
 (anyWorld__TCC1 0
  (anyWorld__TCC1-1 nil 3267007475
   ("" (skosimp*) (("" (use "non_empty_types") nil nil)) nil)
   ((TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (non_empty_types formula-decl nil FODL_semantic nil))
   nil
   (anyWorld_ existence ""
    "(FODL_semantic.mTypePred(FODL_semantic.TPVariable(FODL_semantic.v)))")))
 (anyAssMetavariable_TCC1 0
  (anyAssMetavariable_TCC1-1 nil 3267007475
   ("" (skosimp*) (("" (use "non_empty_types") nil nil)) nil)
   ((TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (non_empty_types formula-decl nil FODL_semantic nil))
   nil
   (anyAssMetavariable existence ""
    "(FODL_semantic.mTypePred(FODL_semantic.TPMetavariable(FODL_semantic.m)))")))
 (mTerm_TCC1 0
  (mTerm_TCC1-7 "" 3651374885
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (rewrite "every_conjunct2")
        (("" (replace -5 :hide? t)
          (("" (expand "wf" -1)
            (("" (rewrite "every_nth")
              (("" (rewrite "every_nth") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" FODL_semantic
     nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (mTerm_TCC1-6 "" 3594692059
   ("" (skolem-typepred)
    (("" (hide -1 -2)
      (("" (flatten)
        (("" (hide -1 -4)
          (("" (rewrite "every_conjunct2")
            (("" (hide -2 2)
              (("" (replace -2 :hide? t)
                (("" (expand "wf" -1)
                  (("" (rewrite "every_nth")
                    (("" (rewrite "every_nth") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_nth formula-decl nil list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (mTerm_TCC1-5 "" 3594049898
   ("" (skolem-typepred)
    (("" (hide -1 -2 -3 -6)
      (("" (flatten)
        (("" (replace -3 :hide? t)
          (("" (expand "wf" -1)
            (("" (rewrite "every_conjunct2") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every_nth formula-decl nil list_props nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (mTerm_TCC1-4 "" 3583525611
   ("" (skolem-typepred)
    (("" (hide -1 -3 -4)
      (("" (flatten)
        (("" (replace -2 :hide? t)
          (("" (expand "wf" -1)
            (("" (rewrite "every_conjunct2")
              (("" (reveal -3) (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (mTerm_TCC1-3 "" 3355172363
   ("" (skolem-typepred)
    (("" (hide -1 -3 -4)
      (("" (flatten)
        (("" (replace -2 :hide? t)
          (("" (expand "wf" -1)
            ((""
              (case "FORALL (P, Q: PRED[Term_]): FORALL (l: list[Term_]): every(P)(l) AND every(Q)(l) IMPLIES every(LAMBDA (x: Term_): P(x) AND Q(x))(l)")
              (("1" (inst?)
                (("1" (assert)
                  (("1" (hide 2)
                    (("1" (prop)
                      (("1"
                        (case "FORALL (l: list[Term_]): every(wf)(l) implies every(lambda (x:
Term_): wf(x))(l)")
                        (("1" (inst?) (("1" (assert) nil nil)) nil)
                         ("2" (hide -1 2)
                          (("2" (induct "l")
                            (("1" (grind) nil nil)
                             ("2" (skosimp)
                              (("2"
                                (expand "every" (-2 1))
                                (("2"
                                  (flatten)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide -1)
                        (("2"
                          (case "FORALL (l: list[Term_]): every(LAMBDA (x1: Term_): complexity(x1) < 1 + max(map(complexity)(l)))(l)")
                          (("1" (inst?)
                            (("1" (expand "complexity" 1 2)
                              (("1"
                                (expand "reduce_nat")
                                (("1"
                                  (case-replace
                                   "(reduce_nat(LAMBDA (c: Constant): 0,
                                    LAMBDA (m: Metavariable): 0,
                                    LAMBDA (v: Variable): 0,
                                    LAMBDA
                                    (f: Function_, l: list[nat]):
                                    1 + max(l),
                                    0,
                                    0,
                                    LAMBDA (n: nat): 1 + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA
                                    (p: Predicate, l: list[nat]):
                                    1 + max(l),
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat): 1 + n,
                                    LAMBDA
                                    (pre_post: [nat, nat]):
                                    1 + pre_post`1 + pre_post`2,
                                    0,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat, m: nat): 1 + m + n,
                                    LAMBDA (n: nat): 1 + n)) = complexity")
                                  (("1"
                                    (hide -1 2)
                                    (("1"
                                      (expand "complexity")
                                      (("1"
                                        (apply-extensionality)
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide 2)
                            (("2" (induct "l")
                              (("1" (grind) nil nil)
                               ("2"
                                (skosimp)
                                (("2"
                                  (expand "every" 1)
                                  (("2"
                                    (prop)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (expand "map" 1)
                                      (("2"
                                        (expand "max" 1)
                                        (("2"
                                          (expand "max" 1 1)
                                          (("2"
                                            (lift-if)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (prop)
                                                (("2"
                                                  (case
                                                   "forall (l: list[Term_]): every(LAMBDA (x1: Term_):
              complexity(x1) < 1 + max(map(complexity)(cons2_var!1)))
           (cons2_var!1) AND NOT complexity(cons1_var!1) <
max(map(complexity)(l)) IMPLIES every(LAMBDA (x1: Term_):
              complexity(x1) < 1 + complexity(cons1_var!1))
           (l)")
                                                  (("1"
                                                    (inst?)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (induct "l")
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (skosimp)
                                                        (("2"
                                                          (expand
                                                           "map"
                                                           1)
                                                          (("2"
                                                            (expand
                                                             "max"
                                                             1)
                                                            (("2"
                                                              (expand
                                                               "max"
                                                               1
                                                               1)
                                                              (("2"
                                                                (lift-if)
                                                                (("2"
                                                                  (expand
                                                                   "every"
                                                                   2)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (split
                                                                       2)
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide -1 2)
                (("2" (skosimp)
                  (("2" (induct "l")
                    (("1" (grind) nil nil)
                     ("2" (skosimp*)
                      (("2" (expand "every" (-2 -3 1))
                        (("2" (flatten) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_conjunct2 formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (mTerm_TCC1-2 "TCC changes" 3325270900
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -5)
        (("" (hide -4 -1 -5)
          (("" (expand "wf" -1)
            ((""
              (case "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (x: FODL_Language): P(x) AND Q(x) AND R(x))(l)")
              (("1" (inst?)
                (("1" (prop)
                  (("1" (hide-all-but 1)
                    (("1" (expand "complexity")
                      (("1" (expand "reduce_nat" 1 2)
                        (("1"
                          (case-replace
                           "complexity = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                          (("1" (replace -1 :dir rl)
                            (("1" (hide -1)
                              (("1"
                                (case
                                 "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(l)))(l)")
                                (("1" (inst?) nil nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (induct "l")
                                    (("1"
                                      (expand "every")
                                      (("1" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (skosimp*)
                                      (("2"
                                        (expand "every" 1)
                                        (("2"
                                          (prop)
                                          (("1"
                                            (expand "map" 1)
                                            (("1"
                                              (expand "max" 1)
                                              (("1"
                                                (expand "max" 1 1)
                                                (("1" (smash) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "map" 1)
                                            (("2"
                                              (expand "max" 1)
                                              (("2"
                                                (expand "max" 1 1)
                                                (("2"
                                                  (smash)
                                                  (("2"
                                                    (case
                                                     "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1)))(l) AND complexity(cons1_var!1) >= max(map(complexity)(cons2_var!1)) IMPLIES every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1))(l)")
                                                    (("1"
                                                      (inst?)
                                                      (("1"
                                                        (prop)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide-all-but 1)
                                                      (("2"
                                                        (induct "l")
                                                        (("1"
                                                          (prop)
                                                          (("1"
                                                            (expand
                                                             "every"
                                                             1)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (skosimp*)
                                                          (("2"
                                                            (prop)
                                                            (("1"
                                                              (expand
                                                               "every"
                                                               1)
                                                              (("1"
                                                                (prop)
                                                                (("1"
                                                                  (expand
                                                                   "every"
                                                                   -2)
                                                                  (("1"
                                                                    (prop)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (expand
                                                               "every"
                                                               -1)
                                                              (("2"
                                                                (prop)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (expand "complexity")
                              (("2" (apply-extensionality) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (skolem!)
                  (("2" (induct "l")
                    (("1" (prop)
                      (("1" (expand "every" 1) (("1" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (skosimp*)
                      (("2" (prop)
                        (("1" (expand "every" 1)
                          (("1" (expand "every" -2)
                            (("1" (expand "every" -3)
                              (("1"
                                (expand "every" -4)
                                (("1" (prop) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "every" -1)
                          (("2" (prop) nil nil)) nil)
                         ("3" (expand "every" -2)
                          (("3" (prop) nil nil)) nil)
                         ("4" (expand "every" -3)
                          (("4" (prop) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (max def-decl "nat" list_max nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (mTerm_TCC1-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -5)
        (("" (hide -2 -3 -5)
          (("" (expand "wf" -2)
            ((""
              (case "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (x: FODL_Language): P(x) AND Q(x) AND R(x))(l)")
              (("1" (inst?)
                (("1" (prop)
                  (("1" (hide-all-but 1)
                    (("1" (expand "complexity")
                      (("1" (expand "reduce_nat" 1 2)
                        (("1"
                          (case-replace
                           "complexity = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                          (("1" (replace -1 :dir rl)
                            (("1" (hide -1)
                              (("1"
                                (case
                                 "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(l)))(l)")
                                (("1" (inst?) nil nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (induct "l")
                                    (("1"
                                      (expand "every")
                                      (("1" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (skosimp*)
                                      (("2"
                                        (expand "every" 1)
                                        (("2"
                                          (prop)
                                          (("1"
                                            (expand "map" 1)
                                            (("1"
                                              (expand "max" 1)
                                              (("1"
                                                (expand "max" 1 1)
                                                (("1" (smash) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "map" 1)
                                            (("2"
                                              (expand "max" 1)
                                              (("2"
                                                (expand "max" 1 1)
                                                (("2"
                                                  (smash)
                                                  (("2"
                                                    (case
                                                     "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1)))(l) AND complexity(cons1_var!1) >= max(map(complexity)(cons2_var!1)) IMPLIES every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1))(l)")
                                                    (("1"
                                                      (inst?)
                                                      (("1"
                                                        (prop)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide-all-but 1)
                                                      (("2"
                                                        (induct "l")
                                                        (("1"
                                                          (prop)
                                                          (("1"
                                                            (expand
                                                             "every"
                                                             1)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (skosimp*)
                                                          (("2"
                                                            (prop)
                                                            (("1"
                                                              (expand
                                                               "every"
                                                               1)
                                                              (("1"
                                                                (prop)
                                                                (("1"
                                                                  (expand
                                                                   "every"
                                                                   -2)
                                                                  (("1"
                                                                    (prop)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (expand
                                                               "every"
                                                               -1)
                                                              (("2"
                                                                (prop)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (expand "complexity")
                              (("2" (apply-extensionality) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (skolem!)
                  (("2" (induct "l")
                    (("1" (prop)
                      (("1" (expand "every" 1) (("1" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (skosimp*)
                      (("2" (prop)
                        (("1" (expand "every" 1)
                          (("1" (expand "every" -2)
                            (("1" (expand "every" -3)
                              (("1"
                                (expand "every" -4)
                                (("1" (prop) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "every" -1)
                          (("2" (prop) nil nil)) nil)
                         ("3" (expand "every" -2)
                          (("3" (prop) nil nil)) nil)
                         ("4" (expand "every" -3)
                          (("4" (prop) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max def-decl "nat" list_max nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (list_induction formula-decl nil list_adt nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (mTerm subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]")))
 (mTerm_TCC2 0
  (mTerm_TCC2-8 "" 3712855468
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (rewrite "every_conjunct2")
        (("" (hide 2)
          (("" (rewrite "every_conjunct2")
            (("1" (hide 2)
              (("1" (hide -1)
                (("1" (replace -4 :hide? t)
                  (("1" (rewrite "every_nth")
                    (("1" (rewrite "every_nth")
                      (("1" (skosimp)
                        (("1" (inst -2 "i!1")
                          (("1" (expand "wf" -1)
                            (("1" (rewrite "every_nth")
                              (("1" (inst -1 "i!1") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (hide -1)
                (("2" (replace -4 :hide? t)
                  (("2" (rewrite "every_nth")
                    (("2" (rewrite "every_nth")
                      (("2" (skosimp)
                        (("2" (expand "complexity" 1)
                          (("2" (expand "reduce_nat" 1 2)
                            (("2" (expand "restrict")
                              (("2"
                                (name-replace
                                 "rn"
                                 "reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,
                           LAMBDA (v: Variable): 0,
                           LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0,
                           LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (p: Predicate, l: list[nat]): 1 + max(l),
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n,
                           LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0,
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n,
                           LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)"
                                 :hide?
                                 t)
                                (("2"
                                  (assert)
                                  (("2"
                                    (lemma
                                     "max_map[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate,
                                Function_, sigFunction_]]")
                                    (("2"
                                      (inst
                                       -1
                                       "LAMBDA (s:
                         Term_
                             [Constant, Metavariable, Variable,
                              Predicate, sigPredicate, Function_,
                              sigFunction_]):
                 rn(s)"
                                       "list_var!1"
                                       "i!1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_map formula-decl nil list_max_map nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max def-decl "nat" list_max nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (every_nth formula-decl nil list_props nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" FODL_semantic
     nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](z1) < complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](t)}]"))
  (mTerm_TCC2-7 "" 3651375333
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (rewrite "every_conjunct2")
        (("" (hide 2)
          (("" (rewrite "every_conjunct2")
            (("1" (hide 2)
              (("1" (hide -1)
                (("1" (replace -4 :hide? t)
                  (("1" (rewrite "every_nth")
                    (("1" (rewrite "every_nth")
                      (("1" (skosimp)
                        (("1" (inst -2 "i!1")
                          (("1" (expand "wf" -1)
                            (("1" (rewrite "every_nth")
                              (("1" (inst -1 "i!1") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (hide -1)
                (("2" (replace -4 :hide? t)
                  (("2" (rewrite "every_nth")
                    (("2" (rewrite "every_nth")
                      (("2" (skosimp)
                        (("2" (expand "complexity" 1)
                          (("2" (expand "reduce_nat" 1 2)
                            (("2" (expand "restrict")
                              (("2"
                                (name-replace
                                 "rn"
                                 "reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,
                       LAMBDA (v: Variable): 0,
                       LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0,
                       LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (p: Predicate, l: list[nat]): 1 + max(l),
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n,
                       LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0,
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n,
                       LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)"
                                 :hide?
                                 t)
                                (("2"
                                  (assert)
                                  (("2"
                                    (lemma
                                     "max_map[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate,
                            Function_, sigFunction_]]")
                                    (("2"
                                      (inst?)
                                      (("2"
                                        (inst -1 "i!1")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (name-replace
                                             "mm"
                                             "max(map(LAMBDA (s:
                             Term_[Constant, Metavariable, Variable, Predicate,
                                   sigPredicate, Function_, sigFunction_]):
                     rn(s))
                  (list_var!1))")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (assert :flush? t)
                                                (("2"
                                                  (name-replace
                                                   "rnn"
                                                   "rn(nth(list_var!1, i!1))")
                                                  (("2"
                                                    (assert :flush? t)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_map formula-decl nil list_max_map nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max def-decl "nat" list_max nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (every_nth formula-decl nil list_props nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](z1) < complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](t)}]"))
  (mTerm_TCC2-6 "" 3594706469
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (hide -1 -2 -6)
        (("" (rewrite "every_conjunct2")
          (("" (hide 2)
            (("" (rewrite "every_conjunct2")
              (("1" (hide 2)
                (("1" (hide -1)
                  (("1" (replace -3 :hide? t)
                    (("1" (rewrite "every_nth")
                      (("1" (rewrite "every_nth")
                        (("1" (skosimp)
                          (("1" (inst -2 "i!1")
                            (("1" (expand "wf" -1)
                              (("1"
                                (rewrite "every_nth")
                                (("1" (inst -1 "i!1") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (hide -1)
                  (("2" (replace -3 :hide? t)
                    (("2" (rewrite "every_nth")
                      (("2" (rewrite "every_nth")
                        (("2" (skosimp)
                          (("2" (expand "complexity" 1)
                            (("2" (expand "reduce_nat" 1 2)
                              (("2"
                                (expand "restrict")
                                (("2"
                                  (name-replace
                                   "rn"
                                   "reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,
                   LAMBDA (v: Variable): 0,
                   LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0,
                   LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (p: Predicate, l: list[nat]): 1 + max(l),
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n,
                   LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n,
                   LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)"
                                   :hide?
                                   t)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (lemma
                                       "max_map[Term_[Constant, Metavariable, Variable, Predicate, sigPredicate,
                        Function_, sigFunction_]]")
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (inst -1 "i!1")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (name-replace
                                               "mm"
                                               "max(map(LAMBDA (s:
                         Term_[Constant, Metavariable, Variable, Predicate,
                               sigPredicate, Function_, sigFunction_]):
                 rn(s))
              (list_var!1))")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (hide -2 -3)
                                                  (("2"
                                                    (assert :flush? t)
                                                    (("2"
                                                      (name-replace
                                                       "rnn"
                                                       "rn(nth(list_var!1, i!1))")
                                                      (("2"
                                                        (assert
                                                         :flush?
                                                         t)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (max_map formula-decl nil list_max_map nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max def-decl "nat" list_max nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (every_nth formula-decl nil list_props nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](z1) < complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](t)}]"))
  (mTerm_TCC2-5 "" 3385441473
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (rewrite "map_length")
        (("" (replace -4)
          (("" (hide-all-but 1)
            ((""
              (generalize "list_var!1" "l1"
               "list[{z1: wf_Term_ | complexity(z1) < complexity(t!1)}]")
              (("" (induct "l1")
                (("1" (grind) nil nil)
                 ("2" (skosimp)
                  (("2" (expand "length" +) (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every_conjunct2 formula-decl nil list_props nil)
    (every_nth formula-decl nil list_props nil)
    (F adt-constructor-decl "[[f: Function_,
  {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}] ->
   (F?)]" FODL_Language_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (max def-decl "nat" list_max nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (max_map formula-decl nil list_max_map nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (restrict const-decl "R" restrict nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](z1) < complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](t)}]"))
  (mTerm_TCC2-4 "" 3355364317
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -5 :hide? t)
        ((""
          (same-name "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}, Carrier]"
                     "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < 1 + max(map(complexity)(list_var!1))}, Carrier]"
                     "[[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)} -> Carrier] -> [list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}] -> list[Carrier]]]")
          (("1" (replace -1)
            (("1" (hide -1)
              (("1"
                (case "FORALL (l: list[wf_Term_]): (FORALL (lPrime: list[{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))}]): FORALL (f: [{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))} -> Carrier]): length(lPrime)=length(map(f)(lPrime)))")
                (("1" (inst?)
                  (("1"
                    (case "list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(list_var!1) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(list_var!1))}].length(list_var!1)")
                    (("1" (replace -1) (("1" (assert) nil nil)) nil)
                     ("2" (hide-all-but 1)
                      (("2"
                        (case "FORALL (lPrime: list[wf_FODL_Language]): FORALL (l: list[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}]): list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(l) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}].length(l)")
                        (("1" (inst?)
                          (("1" (hide-all-but 1)
                            (("1" (typepred "t!1")
                              (("1"
                                (reveal -11)
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (expand "wf" -3)
                                    (("1"
                                      (hide -1 -2)
                                      (("1"
                                        (case-replace
                                         "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")
                                        (("1"
                                          (hide -1)
                                          (("1"
                                            (case
                                             "FORALL (l: list[Term_]): every[FODL_Language](wf)(l)
IMPLIES every[Term_](wf)(l)")
                                            (("1"
                                              (inst?)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "restrict")
                                                  (("1"
                                                    (hide -2)
                                                    (("1"
                                                      (postpone)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (postpone) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (apply-extensionality)
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2" (skolem!)
                            (("2" (induct "l")
                              (("1"
                                (expand "length")
                                (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (skosimp*)
                                (("2"
                                  (expand "length" 1)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (expand "wf" -2)
                      (("2" (smash)
                        (("2" (hide -3)
                          (("2" (hide -1 -3)
                            (("2"
                              (case "FORALL (l: list[Term_]): every(wf)(l) = every({t: Term_ | wf(t)})(l)")
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (hide -1 2)
                                (("2"
                                  (induct-and-simplify "l")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but 1)
                  (("2" (skolem!)
                    (("2" (skosimp*)
                      (("2" (rewrite "map_length") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (replace -4)
            (("2" (hide-all-but 1)
              (("2" (reveal -5)
                (("2" (replace -1 :hide? t)
                  (("2" (skosimp*)
                    (("2" (expand "complexity" 1 2)
                      (("2" (expand "reduce_nat")
                        (("2" (expand "complexity" 1 3)
                          (("2"
                            (case-replace
                             "(reduce_nat(LAMBDA (c: Constant): 0,
                            LAMBDA (m: Metavariable): 0,
                            LAMBDA (v: Variable): 0,
                            LAMBDA (f: Function_, l: list[nat]):
                              1 + max(l),
                            0, 0, LAMBDA (n: nat): 1 + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (p: Predicate, l: list[nat]):
                              1 + max(l),
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat): 1 + n,
                            LAMBDA (pre_post: [nat, nat]):
                              1 + pre_post`1 + pre_post`2,
                            0, LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat): 1 + n)) = (LAMBDA (l:
                            FODL_Language
                                [Constant, Metavariable, Variable,
                                 Predicate, sigPredicate, Function_,
                                 sigFunction_]):
                    reduce_nat(LAMBDA (c: Constant): 0,
                               LAMBDA (m: Metavariable): 0,
                               LAMBDA (v: Variable): 0,
                               LAMBDA (f: Function_, l: list[nat]):
                                 1 + max(l),
                               0, 0, LAMBDA (n: nat): 1 + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (p: Predicate, l: list[nat]):
                                 1 + max(l),
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat): 1 + n,
                               LAMBDA (pre_post: [nat, nat]):
                                 1 + pre_post`1 + pre_post`2,
                               0, LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat): 1 + n)
                              (l))")
                            (("1" (prop)
                              (("1" (assert) nil nil)
                               ("2" (assert) nil nil))
                              nil)
                             ("2" (apply-extensionality) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (hide-all-but 1)
            (("3" (prop)
              (("1" (skosimp*)
                (("1" (reveal -5)
                  (("1" (replace -1 :hide? t)
                    (("1" (expand "complexity" 1 4)
                      (("1" (expand "reduce_nat")
                        (("1" (expand "complexity" 1 2)
                          (("1"
                            (case-replace
                             "(reduce_nat(LAMBDA (c: Constant): 0,
                            LAMBDA (m: Metavariable): 0,
                            LAMBDA (v: Variable): 0,
                            LAMBDA (f: Function_, l: list[nat]):
                              1 + max(l),
                            0, 0, LAMBDA (n: nat): 1 + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (p: Predicate, l: list[nat]):
                              1 + max(l),
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat): 1 + n,
                            LAMBDA (pre_post: [nat, nat]):
                              1 + pre_post`1 + pre_post`2,
                            0, LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat, m: nat): 1 + m + n,
                            LAMBDA (n: nat): 1 + n)) = (LAMBDA (l:
                            FODL_Language
                                [Constant, Metavariable, Variable,
                                 Predicate, sigPredicate, Function_,
                                 sigFunction_]):
                    reduce_nat(LAMBDA (c: Constant): 0,
                               LAMBDA (m: Metavariable): 0,
                               LAMBDA (v: Variable): 0,
                               LAMBDA (f: Function_, l: list[nat]):
                                 1 + max(l),
                               0, 0, LAMBDA (n: nat): 1 + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (p: Predicate, l: list[nat]):
                                 1 + max(l),
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat): 1 + n,
                               LAMBDA (pre_post: [nat, nat]):
                                 1 + pre_post`1 + pre_post`2,
                               0, LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat, m: nat): 1 + m + n,
                               LAMBDA (n: nat): 1 + n)
                              (l))")
                            (("1" (assert) nil nil)
                             ("2" (apply-extensionality) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skosimp)
                (("2" (prop)
                  (("1" (assert)
                    (("1"
                      (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)")
                      (("1" (inst? :where 1)
                        (("1" (assert)
                          (("1" (hide 2)
                            (("1" (reveal -7)
                              (("1"
                                (replace -1 :hide? t)
                                (("1"
                                  (lemma
                                   "every_conjunct[FODL_Language]")
                                  (("1"
                                    (inst? :where -2)
                                    (("1"
                                      (replace -2)
                                      (("1"
                                        (hide -2)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (replace -1)
                                            (("1"
                                              (hide -1)
                                              (("1"
                                                (expand
                                                 "complexity"
                                                 1
                                                 2)
                                                (("1"
                                                  (expand "reduce_nat")
                                                  (("1"
                                                    (expand
                                                     "complexity"
                                                     -1
                                                     2)
                                                    (("1"
                                                      (case-replace
                                                       "(LAMBDA (l:
                                    FODL_Language
                                    [Constant,
                                     Metavariable,
                                     Variable,
                                     Predicate,
                                     sigPredicate,
                                     Function_,
                                     sigFunction_]):
                            reduce_nat(LAMBDA (c: Constant): 0,
                                       LAMBDA (m: Metavariable): 0,
                                       LAMBDA (v: Variable): 0,
                                       LAMBDA
                                       (f: Function_, l: list[nat]):
                                       1 + max(l),
                                       0,
                                       0,
                                       LAMBDA (n: nat): 1 + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA
                                       (p: Predicate, l: list[nat]):
                                       1 + max(l),
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat): 1 + n,
                                       LAMBDA
                                       (pre_post: [nat, nat]):
                                       1 + pre_post`1 + pre_post`2,
                                       0,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat): 1 + n)
                                      (l)) = (reduce_nat(LAMBDA (c: Constant): 0,
                                     LAMBDA (m: Metavariable): 0,
                                     LAMBDA (v: Variable): 0,
                                     LAMBDA
                                     (f: Function_, l: list[nat]):
                                     1 + max(l),
                                     0,
                                     0,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA
                                     (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA
                                     (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                     0,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n))")
                                                      (("1"
                                                        (apply-extensionality)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (skosimp)
                          (("2" (induct-and-simplify "l") nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (reveal -5)
                    (("2" (replace -1 :hide? t)
                      (("2"
                        (case-replace "1 +
                 max(map
                         [FODL_Language
                              [Constant, Metavariable, Variable, Predicate,
                               sigPredicate, Function_, sigFunction_],
                          nat]
                         (complexity
                              [Constant, Metavariable, Variable, Predicate,
                               sigPredicate, Function_, sigFunction_])
                         (list_var!1)) = complexity
                    [Constant, Metavariable, Variable, Predicate,
                     sigPredicate, Function_, sigFunction_]
                    (F(f_var!1, list_var!1))")
                        (("2" (hide-all-but 1)
                          (("2" (expand "complexity")
                            (("2" (expand "reduce_nat" 1 2)
                              (("2"
                                (case-replace
                                 "(LAMBDA (l:
                                    FODL_Language
                                    [Constant,
                                     Metavariable,
                                     Variable,
                                     Predicate,
                                     sigPredicate,
                                     Function_,
                                     sigFunction_]):
                            reduce_nat(LAMBDA (c: Constant): 0,
                                       LAMBDA (m: Metavariable): 0,
                                       LAMBDA (v: Variable): 0,
                                       LAMBDA
                                       (f: Function_, l: list[nat]):
                                       1 + max(l),
                                       0,
                                       0,
                                       LAMBDA (n: nat): 1 + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA
                                       (p: Predicate, l: list[nat]):
                                       1 + max(l),
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat): 1 + n,
                                       LAMBDA
                                       (pre_post: [nat, nat]):
                                       1 + pre_post`1 + pre_post`2,
                                       0,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat, m: nat): 1 + m + n,
                                       LAMBDA (n: nat): 1 + n)
                                      (l)) = (reduce_nat(LAMBDA (c: Constant): 0,
                                     LAMBDA (m: Metavariable): 0,
                                     LAMBDA (v: Variable): 0,
                                     LAMBDA
                                     (f: Function_, l: list[nat]):
                                     1 + max(l),
                                     0,
                                     0,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA
                                     (p: Predicate, l: list[nat]):
                                     1 + max(l),
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n,
                                     LAMBDA
                                     (pre_post: [nat, nat]):
                                     1 + pre_post`1 + pre_post`2,
                                     0,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat, m: nat): 1 + m + n,
                                     LAMBDA (n: nat): 1 + n))")
                                (("2" (apply-extensionality) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (map_length formula-decl nil more_map_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](z1) < complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](t)}]"))
  (mTerm_TCC2-3 "TCC changes" 3325276123
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -5 :hide? t)
        ((""
          (same-name "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}, Carrier]"
                     "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < 1 + max(map(complexity)(list_var!1))}, Carrier]"
                     "[[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)} -> Carrier] -> [list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}] -> list[Carrier]]]")
          (("1" (replace -1)
            (("1" (hide -1)
              (("1"
                (case "FORALL (l: list[wf_Term_]): (FORALL (lPrime: list[{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))}]): FORALL (f: [{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))} -> Carrier]): length(lPrime)=length(map(f)(lPrime)))")
                (("1" (inst?)
                  (("1"
                    (case "list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(list_var!1) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(list_var!1))}].length(list_var!1)")
                    (("1" (replace -1) (("1" (assert) nil nil)) nil)
                     ("2" (hide-all-but 1)
                      (("2"
                        (case "FORALL (lPrime: list[wf_FODL_Language]): FORALL (l: list[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}]): list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(l) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}].length(l)")
                        (("1" (inst?)
                          (("1" (hide-all-but 1)
                            (("1" (typepred "t!1")
                              (("1"
                                (reveal -11)
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (expand "wf" -3)
                                    (("1"
                                      (hide -1 -2)
                                      (("1"
                                        (case-replace
                                         "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")
                                        (("1"
                                          (apply-extensionality)
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2" (skolem!)
                            (("2" (induct "l")
                              (("1"
                                (expand "length")
                                (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (skosimp*)
                                (("2"
                                  (expand "length" 1)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (expand "wf" -2)
                      (("2" (smash)
                        (("2" (hide -3)
                          (("2"
                            (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)")
                            (("1"
                              (inst -1
                               "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                               "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)")
                              (("1"
                                (inst?)
                                (("1"
                                  (prop)
                                  (("1"
                                    (hide 2)
                                    (("1"
                                      (case-replace
                                       "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (apply-extensionality)
                                        nil
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (case-replace
                                     "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf")
                                    (("2"
                                      (apply-extensionality)
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (skolem!)
                                (("2"
                                  (induct "l")
                                  (("1"
                                    (prop)
                                    (("1"
                                      (expand "every" 1)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (skosimp*)
                                    (("2"
                                      (prop)
                                      (("1"
                                        (expand "every" 1)
                                        (("1"
                                          (prop)
                                          (("1"
                                            (expand "every" -2)
                                            (("1" (prop) nil nil))
                                            nil)
                                           ("2"
                                            (expand "every" -3)
                                            (("2" (prop) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "every" -1)
                                        (("2" (prop) nil nil))
                                        nil)
                                       ("3"
                                        (expand "every" -2)
                                        (("3" (prop) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (skolem!)
                    (("2" (induct "lPrime")
                      (("1" (skosimp*)
                        (("1" (expand "map" 1)
                          (("1" (expand "length" 1)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (skosimp*)
                        (("2" (expand "map" 1)
                          (("2" (expand "length" 1)
                            (("2" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (replace -4)
            (("2" (hide-all-but 1)
              (("2" (skosimp*)
                (("2" (expand "complexity" 1 2)
                  (("2" (expand "reduce_nat")
                    (("2" (assert)
                      (("2" (reveal -5)
                        (("2" (replace -1 :hide? t)
                          (("2" (assert)
                            (("2" (expand "complexity" 1 3)
                              (("2"
                                (case-replace
                                 "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                                (("1" (prop) nil nil)
                                 ("2" (apply-extensionality) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (replace -4)
            (("3" (hide-all-but 1)
              (("3" (prop)
                (("1" (skosimp*)
                  (("1" (expand "complexity" 1 4)
                    (("1" (reveal -5)
                      (("1" (replace -1 :hide? t)
                        (("1" (expand "reduce_nat")
                          (("1" (expand "complexity" 1 2)
                            (("1"
                              (case-replace
                               "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                              (("1" (prop) nil nil)
                               ("2" (apply-extensionality) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp*)
                  (("2" (expand "complexity" 1 4)
                    (("2" (reveal -5)
                      (("2" (replace -1 :hide? t)
                        (("2" (expand "reduce_nat")
                          (("2" (expand "complexity" 1 2)
                            (("2"
                              (case-replace
                               "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                              (("1" (prop) nil nil)
                               ("2" (apply-extensionality) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](z1) < complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](t)}]"))
  (mTerm_TCC2-2 "" 3306522450
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -2)
        (("" (hide -2)
          ((""
            (same-name "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}, Carrier]"
                       "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < 1 + max(map(complexity)(list_var!1))}, Carrier]"
                       "[[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)} -> Carrier] -> [list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}] -> list[Carrier]]]")
            (("1" (replace -1)
              (("1" (hide -1)
                (("1"
                  (case "FORALL (l: list[wf_Term_]): (FORALL (lPrime: list[{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))}]): FORALL (f: [{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))} -> Carrier]): length(lPrime)=length(map(f)(lPrime)))")
                  (("1" (inst?)
                    (("1" (hide -2 -3 -4 -5)
                      (("1"
                        (case "list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(list_var!1) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(list_var!1))}].length(list_var!1)")
                        (("1" (replace -1) (("1" (propax) nil nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2"
                            (case "FORALL (lPrime: list[wf_FODL_Language]): FORALL (l: list[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}]): list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(l) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}].length(l)")
                            (("1" (inst?)
                              (("1"
                                (hide-all-but 1)
                                (("1"
                                  (typepred "t!1")
                                  (("1"
                                    (reveal -6)
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (expand "wf" -3)
                                        (("1"
                                          (hide -1 -2)
                                          (("1"
                                            (case-replace
                                             "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")
                                            (("1"
                                              (apply-extensionality)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (skolem!)
                                (("2"
                                  (induct "l")
                                  (("1"
                                    (expand "length")
                                    (("1" (propax) nil nil))
                                    nil)
                                   ("2"
                                    (skosimp*)
                                    (("2"
                                      (expand "length" 1)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 2)
                      (("2" (expand "wf" -3)
                        (("2" (smash)
                          (("2" (hide -2)
                            (("2" (replace -3)
                              (("2"
                                (smash)
                                (("2"
                                  (case
                                   "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)")
                                  (("1"
                                    (inst
                                     -1
                                     "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                                     "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)")
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (prop)
                                        (("1"
                                          (hide 2)
                                          (("1"
                                            (case-replace
                                             "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf")
                                            (("1"
                                              (apply-extensionality)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (skolem!)
                                      (("2"
                                        (induct "l")
                                        (("1"
                                          (prop)
                                          (("1"
                                            (expand "every" 1)
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (prop)
                                            (("1"
                                              (expand "every" 1)
                                              (("1"
                                                (prop)
                                                (("1"
                                                  (expand "every" -2)
                                                  (("1"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand "every" -3)
                                                  (("2"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "every" -1)
                                              (("2" (prop) nil nil))
                                              nil)
                                             ("3"
                                              (expand "every" -2)
                                              (("3" (prop) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (skolem!)
                      (("2" (induct "lPrime")
                        (("1" (skosimp*)
                          (("1" (expand "map" 1)
                            (("1" (expand "length" 1)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (skosimp*)
                          (("2" (expand "map" 1)
                            (("2" (expand "length" 1)
                              (("2" (inst?) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (replace -4)
              (("2" (hide-all-but 1)
                (("2" (skosimp*)
                  (("2" (expand "complexity" 1 2)
                    (("2" (expand "reduce_nat")
                      (("2" (expand "complexity" 1 3)
                        (("2"
                          (case-replace
                           "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                          (("1" (prop) nil nil)
                           ("2" (apply-extensionality) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (replace -4)
              (("3" (hide-all-but 1)
                (("3" (prop)
                  (("1" (skosimp*)
                    (("1" (expand "complexity" 1 4)
                      (("1" (expand "reduce_nat")
                        (("1" (expand "complexity" 1 2)
                          (("1"
                            (case-replace
                             "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                            (("1" (prop) nil nil)
                             ("2" (apply-extensionality) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp*)
                    (("2" (expand "complexity" 1 4)
                      (("2" (expand "reduce_nat")
                        (("2" (expand "complexity" 1 2)
                          (("2"
                            (case-replace
                             "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                            (("1" (prop) nil nil)
                             ("2" (apply-extensionality) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (max def-decl "nat" list_max nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (list_induction formula-decl nil list_adt nil)
    (wf_FODL_Language type-eq-decl nil wf_FODL_Language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm subtype "FODL_semantic.list_var"
    "list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](z1) < complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](t)}]"))
  (mTerm_TCC2-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -2)
        (("" (hide -2)
          ((""
            (same-name "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}, Carrier]"
                       "map[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < 1 + max(map(complexity)(list_var!1))}, Carrier]"
                       "[[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)} -> Carrier] -> [list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity(z1) < complexity(t!1)}] -> list[Carrier]]]")
            (("1" (replace -1)
              (("1" (hide -1)
                (("1"
                  (case "FORALL (l: list[wf_Term_]): (FORALL (lPrime: list[{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))}]): FORALL (f: [{t: wf_Term_ | complexity(t) < 1 + max(map(complexity)(l))} -> Carrier]): length(lPrime)=length(map(f)(lPrime)))")
                  (("1" (inst?)
                    (("1" (hide -2 -3 -4 -5)
                      (("1"
                        (case "list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(list_var!1) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(list_var!1))}].length(list_var!1)")
                        (("1" (replace -1) (("1" (propax) nil nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2"
                            (case "FORALL (lPrime: list[wf_FODL_Language]): FORALL (l: list[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}]): list_props[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].Term_].length(l) = list_props[{t: wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].wf_Term_ | wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity(t) < 1 + list_max.max(list_adt_map[FODL_Language_adt[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].FODL_Language, nat].map(wf_FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_].complexity)(lPrime))}].length(l)")
                            (("1" (inst?)
                              (("1"
                                (hide-all-but 1)
                                (("1"
                                  (case
                                   "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t) AND R(t))(l)")
                                  (("1"
                                    (inst
                                     -1
                                     "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                                     "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                                     "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) < 1 + max(map[FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], nat](complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_])(list_var!1))")
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (prop)
                                        (("1"
                                          (hide-all-but 1)
                                          (("1"
                                            (typepred "list_var!1")
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide-all-but 1)
                                          (("2"
                                            (typepred "t!1")
                                            (("2"
                                              (expand "wf" -2)
                                              (("2"
                                                (reveal -9)
                                                (("2"
                                                  (smash)
                                                  (("2"
                                                    (replace -1)
                                                    (("2"
                                                      (smash)
                                                      (("2"
                                                        (hide -1 -2)
                                                        (("2"
                                                          (case-replace
                                                           "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")
                                                          (("2"
                                                            (apply-extensionality)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (hide-all-but 1)
                                          (("3"
                                            (case
                                             "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(l)))(l)")
                                            (("1" (inst?) nil nil)
                                             ("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (induct "l")
                                                (("1"
                                                  (expand "every" 1)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (expand "every" 1)
                                                    (("2"
                                                      (expand "map" 1)
                                                      (("2"
                                                        (expand
                                                         "max"
                                                         1)
                                                        (("2"
                                                          (prop)
                                                          (("1"
                                                            (smash)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "max"
                                                             1
                                                             1)
                                                            (("2"
                                                              (case
                                                               "complexity(cons1_var!1) < max(map(complexity)(cons2_var!1))")
                                                              (("1"
                                                                (smash)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (smash)
                                                                (("2"
                                                                  (case
                                                                   "FORALL (P, Q: PRED[FODL_Language]): (FORALL (l: FODL_Language): P(l) IMPLIES Q(l)) IMPLIES (FORALL (l: list[FODL_Language]): every(P)(l) IMPLIES every(Q)(l))")
                                                                  (("1"
                                                                    (inst
                                                                     -1
                                                                     "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1))"
                                                                     "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1)")
                                                                    (("1"
                                                                      (prop)
                                                                      (("1"
                                                                        (inst?)
                                                                        (("1"
                                                                          (prop)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (skosimp*)
                                                                        (("2"
                                                                          (smash)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (hide-all-but
                                                                     1)
                                                                    (("2"
                                                                      (skolem!)
                                                                      (("2"
                                                                        (prop)
                                                                        (("2"
                                                                          (induct
                                                                           "l")
                                                                          (("1"
                                                                            (expand
                                                                             "every"
                                                                             1)
                                                                            (("1"
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (skosimp*)
                                                                            (("2"
                                                                              (expand
                                                                               "every"
                                                                               1)
                                                                              (("2"
                                                                                (prop)
                                                                                (("1"
                                                                                  (expand
                                                                                   "every"
                                                                                   -2)
                                                                                  (("1"
                                                                                    (prop)
                                                                                    (("1"
                                                                                      (inst?)
                                                                                      (("1"
                                                                                        (prop)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (expand
                                                                                   "every"
                                                                                   -1)
                                                                                  (("2"
                                                                                    (prop)
                                                                                    nil
                                                                                    nil))
                                                                                  nil)
                                                                                 ("3"
                                                                                  (expand
                                                                                   "every"
                                                                                   -1)
                                                                                  (("3"
                                                                                    (prop)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (skolem!)
                                      (("2"
                                        (induct "l")
                                        (("1"
                                          (prop)
                                          (("1"
                                            (expand "every" 1)
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (prop)
                                            (("1"
                                              (expand "every" 1)
                                              (("1"
                                                (prop)
                                                (("1"
                                                  (expand "every" -2)
                                                  (("1"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand "every" -3)
                                                  (("2"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (expand "every" -4)
                                                  (("3"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "every" -1)
                                              (("2" (prop) nil nil))
                                              nil)
                                             ("3"
                                              (expand "every" -2)
                                              (("3" (prop) nil nil))
                                              nil)
                                             ("4"
                                              (expand "every" -3)
                                              (("4" (prop) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but 1)
                                (("2"
                                  (typepred "t!1")
                                  (("2"
                                    (reveal -6)
                                    (("2"
                                      (replace -1)
                                      (("2"
                                        (expand "wf" -3)
                                        (("2"
                                          (hide -1 -2)
                                          (("2"
                                            (case-replace
                                             "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")
                                            (("2"
                                              (apply-extensionality)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (skolem!)
                                (("2"
                                  (induct "l")
                                  (("1"
                                    (expand "length")
                                    (("1" (propax) nil nil))
                                    nil)
                                   ("2"
                                    (skosimp*)
                                    (("2"
                                      (expand "length" 1)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (hide-all-but 1)
                          (("3"
                            (case "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t) AND R(t))(l)")
                            (("1"
                              (inst -1
                               "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                               "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                               "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) < 1 + max(map[FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], nat](complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_])(list_var!1))")
                              (("1"
                                (inst?)
                                (("1"
                                  (prop)
                                  (("1"
                                    (hide-all-but 1)
                                    (("1"
                                      (typepred "list_var!1")
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (typepred "t!1")
                                      (("2"
                                        (reveal -7)
                                        (("2"
                                          (replace -1)
                                          (("2"
                                            (hide -1)
                                            (("2"
                                              (expand "wf" -2)
                                              (("2"
                                                (case-replace
                                                 "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf")
                                                (("2"
                                                  (apply-extensionality)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (hide-all-but 1)
                                    (("3"
                                      (case
                                       "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 +max(map(complexity)(l)))(l)")
                                      (("1" (inst?) nil nil)
                                       ("2"
                                        (hide-all-but 1)
                                        (("2"
                                          (induct "l")
                                          (("1"
                                            (expand "every" 1)
                                            (("1" (propax) nil nil))
                                            nil)
                                           ("2"
                                            (skosimp*)
                                            (("2"
                                              (expand "every" 1)
                                              (("2"
                                                (expand "map" 1)
                                                (("2"
                                                  (expand "max" 1)
                                                  (("2"
                                                    (prop)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       "max"
                                                       1
                                                       1)
                                                      (("2"
                                                        (case
                                                         "complexity(cons1_var!1) < max(map(complexity)(cons2_var!1))")
                                                        (("1"
                                                          (smash)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (smash)
                                                          (("2"
                                                            (case
                                                             "FORALL (P, Q: PRED[FODL_Language]): (FORALL (l: FODL_Language): P(l) IMPLIES Q(l)) IMPLIES (FORALL (l: list[FODL_Language]): every(P)(l) IMPLIES every(Q)(l))")
                                                            (("1"
                                                              (inst
                                                               -1
                                                               "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1))"
                                                               "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1)")
                                                              (("1"
                                                                (prop)
                                                                (("1"
                                                                  (inst?)
                                                                  (("1"
                                                                    (prop)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (skosimp*)
                                                                  (("2"
                                                                    (smash)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (hide-all-but
                                                               1)
                                                              (("2"
                                                                (skolem!)
                                                                (("2"
                                                                  (prop)
                                                                  (("2"
                                                                    (induct
                                                                     "l")
                                                                    (("1"
                                                                      (prop)
                                                                      (("1"
                                                                        (expand
                                                                         "every"
                                                                         1)
                                                                        (("1"
                                                                          (propax)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (skolem!)
                                                                      (("2"
                                                                        (prop)
                                                                        (("1"
                                                                          (expand
                                                                           "every"
                                                                           1)
                                                                          (("1"
                                                                            (prop)
                                                                            (("1"
                                                                              (expand
                                                                               "every"
                                                                               -2)
                                                                              (("1"
                                                                                (prop)
                                                                                (("1"
                                                                                  (inst?)
                                                                                  (("1"
                                                                                    (prop)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (expand
                                                                           "every"
                                                                           -1)
                                                                          (("2"
                                                                            (prop)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (skolem!)
                                (("2"
                                  (induct "l")
                                  (("1"
                                    (prop)
                                    (("1"
                                      (expand "every" 1)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (skosimp*)
                                    (("2"
                                      (prop)
                                      (("1"
                                        (expand "every" 1)
                                        (("1"
                                          (prop)
                                          (("1"
                                            (expand "every" -2)
                                            (("1" (prop) nil nil))
                                            nil)
                                           ("2"
                                            (expand "every" -3)
                                            (("2" (prop) nil nil))
                                            nil)
                                           ("3"
                                            (expand "every" -4)
                                            (("3" (prop) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "every" -1)
                                        (("2" (prop) nil nil))
                                        nil)
                                       ("3"
                                        (expand "every" -2)
                                        (("3" (prop) nil nil))
                                        nil)
                                       ("4"
                                        (expand "every" -3)
                                        (("4" (prop) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (replace -4)
                      (("2" (hide-all-but 1)
                        (("2" (skosimp*)
                          (("2" (expand "complexity" 1 2)
                            (("2" (expand "reduce_nat")
                              (("2"
                                (expand "complexity" 1 3)
                                (("2"
                                  (case-replace
                                   "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n,LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                                  (("1" (prop) nil nil)
                                   ("2"
                                    (apply-extensionality)
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (hide 2)
                      (("3" (expand "wf" -3)
                        (("3" (smash)
                          (("3" (hide -2)
                            (("3" (replace -3)
                              (("3"
                                (hide -3)
                                (("3"
                                  (smash)
                                  (("3"
                                    (case
                                     "FORALL (P, Q, R: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) AND every(R)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t) AND R(t))(l)")
                                    (("1"
                                      (inst
                                       -1
                                       "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR  m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                                       "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                                       "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) < 1 + max(map[FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], nat](complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_])(list_var!1))")
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (prop)
                                          (("1"
                                            (hide 2)
                                            (("1"
                                              (case-replace
                                               "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")
                                              (("1"
                                                (apply-extensionality)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide 2)
                                            (("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (case
                                                 "FORALL (l: list[FODL_Language]): every(LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(l)))(l)")
                                                (("1" (inst?) nil nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (induct "l")
                                                    (("1"
                                                      (expand "map" 1)
                                                      (("1"
                                                        (expand
                                                         "every"
                                                         1)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (expand
                                                         "every"
                                                         1)
                                                        (("2"
                                                          (prop)
                                                          (("1"
                                                            (expand
                                                             "map"
                                                             1)
                                                            (("1"
                                                              (expand
                                                               "max"
                                                               1)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "map"
                                                             1)
                                                            (("2"
                                                              (expand
                                                               "max"
                                                               1)
                                                              (("2"
                                                                (expand
                                                                 "max"
                                                                 1
                                                                 1)
                                                                (("2"
                                                                  (case
                                                                   "complexity(cons1_var!1) < max(map(complexity)(cons2_var!1))")
                                                                  (("1"
                                                                    (smash)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (smash)
                                                                    (("2"
                                                                      (case
                                                                       "FORALL (P, Q: PRED[FODL_Language]): (FORALL (l: FODL_Language): P(l) IMPLIES Q(l)) IMPLIES (FORALL (l: list[FODL_Language]): every(P)(l) IMPLIES every(Q)(l))")
                                                                      (("1"
                                                                        (inst
                                                                         -1
                                                                         "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + max(map(complexity)(cons2_var!1))"
                                                                         "LAMBDA (x1: FODL_Language): complexity(x1) < 1 + complexity(cons1_var!1)")
                                                                        (("1"
                                                                          (prop)
                                                                          (("1"
                                                                            (inst?)
                                                                            (("1"
                                                                              (prop)
                                                                              nil
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (skosimp*)
                                                                            (("2"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (hide-all-but
                                                                         1)
                                                                        (("2"
                                                                          (skolem!)
                                                                          (("2"
                                                                            (prop)
                                                                            (("2"
                                                                              (induct
                                                                               "l")
                                                                              (("1"
                                                                                (expand
                                                                                 "every"
                                                                                 1)
                                                                                (("1"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (skosimp*)
                                                                                (("2"
                                                                                  (expand
                                                                                   "every"
                                                                                   1)
                                                                                  (("2"
                                                                                    (prop)
                                                                                    (("1"
                                                                                      (inst?)
                                                                                      (("1"
                                                                                        (prop)
                                                                                        (("1"
                                                                                          (expand
                                                                                           "every"
                                                                                           -2)
                                                                                          (("1"
                                                                                            (prop)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil)
                                                                                     ("2"
                                                                                      (expand
                                                                                       "every"
                                                                                       -1)
                                                                                      (("2"
                                                                                        (prop)
                                                                                        nil
                                                                                        nil))
                                                                                      nil)
                                                                                     ("3"
                                                                                      (expand
                                                                                       "every"
                                                                                       -1)
                                                                                      (("3"
                                                                                        (prop)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 2)
                                      (("2"
                                        (hide-all-but 1)
                                        (("2"
                                          (skolem!)
                                          (("2"
                                            (induct "l")
                                            (("1"
                                              (prop)
                                              (("1"
                                                (expand "every" 1)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (skosimp*)
                                              (("2"
                                                (prop)
                                                (("1"
                                                  (expand "every" 1)
                                                  (("1"
                                                    (prop)
                                                    (("1"
                                                      (expand
                                                       "every"
                                                       -2)
                                                      (("1"
                                                        (prop)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       "every"
                                                       -3)
                                                      (("2"
                                                        (prop)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("3"
                                                      (expand
                                                       "every"
                                                       -4)
                                                      (("3"
                                                        (prop)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand "every" -1)
                                                  (("2"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (expand "every" -2)
                                                  (("3"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (expand "every" -3)
                                                  (("4"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("4" (hide 2)
                      (("4" (expand "wf" -3)
                        (("4" (smash)
                          (("4" (replace -4)
                            (("4" (smash)
                              (("4"
                                (case
                                 "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): every(P)(l) AND every(Q)(l) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)")
                                (("1"
                                  (inst
                                   -1
                                   "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): c?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR m?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR v?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1) OR F?[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)"
                                   "LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)")
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (prop)
                                      (("1"
                                        (hide 2)
                                        (("1"
                                          (case-replace
                                           "(LAMBDA (x1: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): wf[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](x1)) = wf")
                                          (("1"
                                            (apply-extensionality)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (skolem!)
                                    (("2"
                                      (induct "l")
                                      (("1"
                                        (prop)
                                        (("1"
                                          (expand "every" 1)
                                          (("1" (propax) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (skosimp*)
                                        (("2"
                                          (prop)
                                          (("1"
                                            (expand "every" 1)
                                            (("1"
                                              (prop)
                                              (("1"
                                                (expand "every" -2)
                                                (("1" (prop) nil nil))
                                                nil)
                                               ("2"
                                                (expand "every" -3)
                                                (("2" (prop) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "every" -1)
                                            (("2" (prop) nil nil))
                                            nil)
                                           ("3"
                                            (expand "every" -2)
                                            (("3" (prop) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (skolem!)
                      (("2" (induct "lPrime")
                        (("1" (skosimp*)
                          (("1" (expand "map" 1)
                            (("1" (expand "length" 1)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (skosimp*)
                          (("2" (expand "map" 1)
                            (("2" (expand "length" 1)
                              (("2" (inst?) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (replace -4)
              (("2" (hide-all-but 1)
                (("2" (skosimp*)
                  (("2" (expand "complexity" 1 2)
                    (("2" (expand "reduce_nat")
                      (("2" (expand "complexity" 1 3)
                        (("2"
                          (case-replace
                           "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                          (("1" (prop) nil nil)
                           ("2" (apply-extensionality) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (replace -4)
              (("3" (hide-all-but 1)
                (("3" (prop)
                  (("1" (skosimp*)
                    (("1" (expand "complexity" 1 4)
                      (("1" (expand "reduce_nat")
                        (("1" (expand "complexity" 1 2)
                          (("1"
                            (case-replace
                             "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0,LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                            (("1" (prop) nil nil)
                             ("2" (apply-extensionality) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp*)
                    (("2" (expand "complexity" 1 4)
                      (("2" (expand "reduce_nat")
                        (("2" (expand "complexity" 1 2)
                          (("2"
                            (case-replace
                             "(LAMBDA (l: FODL_Language[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]): reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)(l)) = reduce_nat(LAMBDA (c: Constant): 0, LAMBDA (m: Metavariable): 0, LAMBDA (v: Variable): 0, LAMBDA (f: Function_, l: list[nat]): 1 + max(l), 0, 0, LAMBDA (n: nat): 1 + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (p: Predicate, l: list[nat]): 1 + max(l), LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n, LAMBDA (pre_post: [nat, nat]): 1 + pre_post`1 + pre_post`2, 0, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat, m: nat): 1 + m + n, LAMBDA (n: nat): 1 + n)")
                            (("1" (prop) nil nil)
                             ("2" (apply-extensionality) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (wf_FODL_Language type-eq-decl nil wf_FODL_Language nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max def-decl "nat" list_max nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (mTerm subtype "FODL_semantic.list_var"
    "list[{z1: wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_] | complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](z1) < complexity[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_](t)}]")))
 (mTerm_TCC3 0
  (mTerm_TCC3-3 "" 3651375432
   ("" (skolem-typepred)
    (("" (flatten) (("" (rewrite "map_length") nil nil)) nil)) nil)
   ((Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (map_length formula-decl nil more_map_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" FODL_semantic
     nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (mTerm termination-subtype
    "list_adt_map[{z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))}, FODL_semantic.Carrier].map(LAMBDA (x1: {z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))}): FODL_semantic.mTerm(FODL_semantic.mMetavariable, FODL_semantic.w)(x1))(FODL_semantic.list_var)"
    "[[AssMetavariable, World_] -> [{z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))} -> FODL_semantic.Carrier]]"))
  (mTerm_TCC3-2 "" 3594706661
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (hide -1 -2 -3 -4)
        (("" (hide -1) (("" (rewrite "map_length") nil nil)) nil))
        nil))
      nil))
    nil)
   ((Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (map_length formula-decl nil more_map_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (mTerm termination-subtype
    "list_adt_map[{z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))}, FODL_semantic.Carrier].map(LAMBDA (x1: {z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))}): FODL_semantic.mTerm(FODL_semantic.mMetavariable, FODL_semantic.w)(x1))(FODL_semantic.list_var)"
    "[[AssMetavariable, World_] -> [{z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))} -> FODL_semantic.Carrier]]"))
  (mTerm_TCC3-1 nil 3583274950 ("" (termination-tcc) nil nil)
   ((map_length formula-decl nil more_map_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (mTerm termination-subtype
    "list_adt_map[{z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))}, FODL_semantic.Carrier].map(LAMBDA (x1: {z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))}): FODL_semantic.mTerm(FODL_semantic.mMetavariable, FODL_semantic.w)(x1))(FODL_semantic.list_var)"
    "[[AssMetavariable, World_] -> [{z1: wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].wf_Term_ | reals.<(wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(z1), wf_FODL_Language[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].complexity(FODL_semantic.t))} -> FODL_semantic.Carrier]]")))
 (mTerm_TCC4 0
  (mTerm_TCC4-1 nil 3583274950 ("" (cases-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (mTerm cases "FODL_semantic.t"
    "FODL_Language[Constant: TYPE, Metavariable: TYPE, Variable: TYPE, Predicate: TYPE, sigPredicate: [FODL_Language_adt.Predicate -> naturalnumbers.nat], Function_: TYPE, sigFunction_: [FODL_Language_adt.Function_ -> naturalnumbers.nat]]: DATATYPE WITH SUBTYPES Term_, Formula_, Program_
 BEGIN
  c(c: Constant): c?: Term_
  m(m: Metavariable): m?: Term_
  v(v: Variable): v?: Term_
  F(f: Function_, lF: {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}): F?: Term_
  TRUE: TRUE?: Formula_
  FALSE: FALSE?: Formula_
  NOT(f: Formula_): NOT?: Formula_
  IMPLIES(f_0, f_1: Formula_): IMPLIES?: Formula_
  OR(f_0, f_1: Formula_): OR?: Formula_
  AND(f_0, f_1: Formula_): AND?: Formula_
  IFF(f_0, f_1: Formula_): IFF?: Formula_
  P(p: Predicate, lP: {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}): P?: Formula_
  =(t_0: Term_, t_1: Term_): EQ?: Formula_
  EXISTS_(x: (v?), f: Formula_): EXISTS?: Formula_
  FORALL_(x: (v?), f: Formula_): FORALL?: Formula_
  ◇(P: Program_, f: Formula_): DIAMOND?: Formula_
  □(P: Program_, f: Formula_): BOX?: Formula_
  T?(f: Formula_): T??: Program_
  A(pre_post: [Formula_, Formula_]): A?: Program_
  SKIP: SKIP?: Program_
  <|(x: (v?), t: Term_): ASSIGNMENT?: Program_
  //(P_0, P_1: Program_): COMPOSITION?: Program_
  +(P_0, P_1: Program_): CHOICE?: Program_
  *(P: Program_): ITERATION?: Program_
 END FODL_Language")))
 (m_TCC1 0
  (m_TCC1-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | booleans.TRUE})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC2 0
  (m_TCC2-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | booleans.FALSE})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC3 0
  (m_TCC3-5 "" 3770096435
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -5 :hide? t)
            (("" (expand "wf" -4) (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC3-4 "" 3651375502
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -6 :hide? t)
            (("" (replace -5 :hide? t)
              (("" (skolem-typepred)
                (("" (expand "wf" -4) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC3-3 "" 3594707377
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 :hide? t)
            (("" (replace -6 :hide? t)
              (("" (skolem-typepred)
                (("" (expand "wf" -6) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC3-2 "TCC changes" 3325345205
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -6 -5)
            (("" (replace -5 -2)
              (("" (expand "every" -2)
                (("" (expand "wf" -2) (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC3-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -6 -5)
        (("" (replace -5 -4)
          (("" (expand "every" -4)
            (("" (expand "wf" -4) (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC4 0
  (m_TCC4-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var))"
    "nil")))
 (m_TCC5 0
  (m_TCC5-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | (booleans.NOT)(union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(w))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC6 0
  (m_TCC6-4 "" 3770096517
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -6 :hide? t)
            (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC6-3 "" 3651375996
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (replace -7 :hide? t)
              (("" (replace -6 :hide? t)
                (("" (expand "wf" -5) (("" (assert :flush? t) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC6-2 "" 3594707573
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (replace -9 :hide? t)
              (("" (replace -8 :hide? t)
                (("" (expand "wf" -7) (("" (assert :flush? t) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC6-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC7 0
  (m_TCC7-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f1_var))"
    "nil")))
 (m_TCC8 0
  (m_TCC8-5 "" 3770096582
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -6 :hide? t)
            (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC8-4 "" 3651376056
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (replace -7 :hide? t)
                (("" (replace -6 :hide? t)
                  (("" (expand "wf" -5)
                    (("" (assert :flush? t) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC8-3 "" 3594707624
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (replace -10 :hide? t)
                (("" (replace -9 :hide? t)
                  (("" (expand "wf" -8)
                    (("" (assert :flush? t) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC8-2 "TCC changes" 3325345620
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skosimp*)
            (("" (replace -7 -6)
              (("" (replace -6 -3)
                (("" (expand "every" -3)
                  (("" (expand "wf" -3) (("" (prop) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (inr adt-constructor-decl "[T2 -> (inr?)]" union_adt nil)
    (inr? adt-recognizer-decl "[union -> boolean]" union_adt nil)
    (inl adt-constructor-decl "[T1 -> (inl?)]" union_adt nil)
    (inl? adt-recognizer-decl "[union -> boolean]" union_adt nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC8-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC9 0
  (m_TCC9-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f2_var))"
    "nil")))
 (m_TCC10 0
  (m_TCC10-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | booleans.IMPLIES(union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f1_var)))(w), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f2_var)))(w))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC11 0
  (m_TCC11-5 "" 3770096709
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -6 :hide? t)
            (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC11-4 "" 3651376096
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (replace -7 :hide? t)
              (("" (expand "wf" -5) (("" (assert :flush? t) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC11-3 "" 3594707657
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (replace -9 :hide? t)
              (("" (expand "wf" -7) (("" (assert :flush? t) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC11-2 "TCC Changes" 3325345689
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC11-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC12 0
  (m_TCC12-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f1_var))"
    "nil")))
 (m_TCC13 0
  (m_TCC13-5 "" 3770096789
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -6 :hide? t)
            (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC13-4 "" 3651376171
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (replace -7 :hide? t)
                (("" (expand "wf" -5) (("" (assert :flush? t) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC13-3 "" 3594707695
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (replace -10 :hide? t)
                (("" (expand "wf" -8) (("" (assert :flush? t) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC13-2 "TCC changes" 3325345762
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skosimp*)
            (("" (replace -7 -6)
              (("" (replace -6 -3)
                (("" (expand "every" -3)
                  (("" (expand "wf" -3) (("" (prop) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (inr adt-constructor-decl "[T2 -> (inr?)]" union_adt nil)
    (inr? adt-recognizer-decl "[union -> boolean]" union_adt nil)
    (inl adt-constructor-decl "[T1 -> (inl?)]" union_adt nil)
    (inl? adt-recognizer-decl "[union -> boolean]" union_adt nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC13-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC14 0
  (m_TCC14-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f2_var))"
    "nil")))
 (m_TCC15 0
  (m_TCC15-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | booleans.OR(union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f1_var)))(w), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f2_var)))(w))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC16 0
  (m_TCC16-5 "" 3770096844
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -6 :hide? t)
            (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC16-4 "" 3651376298
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (replace -7 :hide? t)
              (("" (expand "wf" -5) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC16-3 "" 3594707725
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (replace -9 :hide? t)
              (("" (expand "wf" -7) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC16-2 "TCC changes" 3325345839
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC16-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC17 0
  (m_TCC17-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f1_var))"
    "nil")))
 (m_TCC18 0
  (m_TCC18-5 "" 3770096913
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -6 :hide? t)
            (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC18-4 "" 3651376332
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (replace -7 :hide? t)
              (("" (flatten)
                (("" (expand "wf" -5) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC18-3 "" 3594707767
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (replace -10 :hide? t)
              (("" (flatten)
                (("" (expand "wf" -8) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC18-2 "TCC changes" 3325345899
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skosimp*)
            (("" (replace -7 -6)
              (("" (replace -6 -3)
                (("" (expand "every" -3)
                  (("" (expand "wf" -3) (("" (prop) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (inr adt-constructor-decl "[T2 -> (inr?)]" union_adt nil)
    (inr? adt-recognizer-decl "[union -> boolean]" union_adt nil)
    (inl adt-constructor-decl "[T1 -> (inl?)]" union_adt nil)
    (inl? adt-recognizer-decl "[union -> boolean]" union_adt nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC18-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC19 0
  (m_TCC19-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f2_var))"
    "nil")))
 (m_TCC20 0
  (m_TCC20-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f1_var)))(w), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f2_var)))(w))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC21 0
  (m_TCC21-5 "" 3770096951
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -6 :hide? t)
            (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC21-4 "" 3651376361
   ("" (skosimp* :preds? t)
    (("" (replace -7 :hide? t)
      (("" (expand "wf" -5) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC21-3 "" 3594707844
   ("" (skosimp* :preds? t)
    (("" (replace -9 :hide? t)
      (("" (expand "wf" -7) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC21-2 "TCC changes" 3325345967
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC21-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f1_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC22 0
  (m_TCC22-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f1_var))"
    "nil")))
 (m_TCC23 0
  (m_TCC23-5 "" 3770096988
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (skeep :preds? t)
        (("" (replace -6 :hide? t)
          (("" (replace -6 :hide? t)
            (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC23-4 "" 3651376391
   ("" (skosimp* :preds? t)
    (("" (replace -7 :hide? t)
      (("" (expand "wf" -5) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC23-3 "" 3594707864
   ("" (skosimp* :preds? t)
    (("" (replace -9 :hide? t)
      (("" (expand "wf" -7) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC23-2 "TCC changes" 3325346026
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC23-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.f2_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC24 0
  (m_TCC24-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f2_var))"
    "nil")))
 (m_TCC25 0
  (m_TCC25-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | booleans.IFF(union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f1_var)))(w), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f2_var)))(w))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC26 0
  (m_TCC26-6 "" 3770097284
   ("" (skeep* :preds? t)
    (("" (rewrite "every_conjunct2")
      (("" (hide 2)
        (("" (replace -6 :hide? t)
          (("" (replace -5 :hide? t)
            (("" (rewrite "every_nth")
              (("" (hide -1)
                (("" (skeep)
                  (("" (expand "wf" -3)
                    (("" (rewrite "every_nth")
                      (("" (inst -3 "i") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_conjunct2 formula-decl nil list_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (every_nth formula-decl nil list_props nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" FODL_semantic
     nil))
   shostak
   (m subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (m_TCC26-5 "" 3651378055
   ("" (skosimp* :preds? t)
    (("" (rewrite "every_conjunct2")
      (("" (hide 2)
        (("" (replace -7 :hide? t)
          (("" (replace -5 :hide? t)
            (("" (rewrite "every_nth")
              (("" (hide -1)
                (("" (skosimp)
                  (("" (expand "wf" -3)
                    (("" (rewrite "every_nth")
                      (("" (inst -3 "i!1") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_conjunct2 formula-decl nil list_props nil)
    (every_nth formula-decl nil list_props nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (m_TCC26-4 "" 3594708270
   ("" (skosimp* :preds? t)
    (("" (rewrite "every_conjunct2")
      (("" (hide 2)
        (("" (hide -1 -3 -4 -6)
          (("" (replace -5 :hide? t)
            (("" (replace -4 :hide? t)
              (("" (rewrite "every_nth")
                (("" (hide -1)
                  (("" (skosimp)
                    (("" (expand "wf" -2)
                      (("" (rewrite "every_nth")
                        (("" (inst -2 "i!1") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_conjunct2 formula-decl nil list_props nil)
    (every_nth formula-decl nil list_props nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (m_TCC26-3 "" 3385435730
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3)
                  (("" (hide-all-but (-3 1))
                    (("" (generalize "list_var!1" "l1" "list[Term_]")
                      (("" (induct "l1")
                        (("1" (grind) nil nil)
                         ("2" (skosimp*)
                          (("2" (expand "every" -2)
                            (("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (expand "every" 1)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_conjunct2 formula-decl nil list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (complexity const-decl "nat" wf_FODL_Language nil)
    (P adt-constructor-decl "[[p: Predicate,
  {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}] ->
   (P?)]" FODL_Language_adt nil)
    (every_nth formula-decl nil list_props nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (m_TCC26-2 "TCC changes" 3325346152
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3)
                  ((""
                    (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): (every(P)(l) AND every(Q)(l)) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)")
                    (("1" (inst?) (("1" (assert) nil nil)) nil)
                     ("2" (hide-all-but 1)
                      (("2" (skolem!)
                        (("2" (induct "l")
                          (("1" (prop)
                            (("1" (expand "every" 1)
                              (("1" (propax) nil nil)) nil))
                            nil)
                           ("2" (skosimp*)
                            (("2" (prop)
                              (("1"
                                (expand "every" 1)
                                (("1"
                                  (expand "every" -2)
                                  (("1"
                                    (expand "every" -3)
                                    (("1" (prop) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "every" -1)
                                (("2" (prop) nil nil))
                                nil)
                               ("3"
                                (expand "every" -2)
                                (("3" (prop) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (list type-decl nil list_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak
   (m subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]"))
  (m_TCC26-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5)
              ((""
                (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): (every(P)(l) AND every(Q)(l)) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)")
                (("1" (inst?) (("1" (assert) nil nil)) nil)
                 ("2" (hide-all-but 1)
                  (("2" (skolem!)
                    (("2" (induct "l")
                      (("1" (prop)
                        (("1" (expand "every" 1)
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (skosimp*)
                        (("2" (prop)
                          (("1" (expand "every" 1)
                            (("1" (expand "every" -2)
                              (("1"
                                (expand "every" -3)
                                (("1" (prop) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "every" -1)
                            (("2" (prop) nil nil)) nil)
                           ("3" (expand "every" -2)
                            (("3" (prop) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.list_var"
    "list[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]]")))
 (m_TCC27 0
  (m_TCC27-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -4 1)
          ((""
            (case "FORALL (l: list[wf_Term_]): FORALL (f: [wf_Term_ -> Carrier]): length[Term_](l) = length[Carrier](map[wf_Term_, Carrier](f)(l))")
            (("1" (inst?)
              (("1" (hide 2)
                (("1" (replace -7 -6)
                  (("1" (replace -6 -5)
                    (("1" (expand "every" -5)
                      (("1" (expand "wf" -5)
                        (("1"
                          (case "FORALL (P, Q: PRED[FODL_Language]): FORALL (l: list[FODL_Language]): (every(P)(l) AND every(Q)(l)) IMPLIES every(LAMBDA (t: FODL_Language): P(t) AND Q(t))(l)")
                          (("1" (inst?) (("1" (assert) nil nil)) nil)
                           ("2" (hide-all-but 1)
                            (("2" (skolem!)
                              (("2"
                                (induct "l")
                                (("1"
                                  (prop)
                                  (("1"
                                    (expand "every" 1)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (skosimp*)
                                  (("2"
                                    (prop)
                                    (("1"
                                      (expand "every" 1)
                                      (("1"
                                        (expand "every" -2)
                                        (("1"
                                          (expand "every" -3)
                                          (("1" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "every" -1)
                                      (("2" (prop) nil nil))
                                      nil)
                                     ("3"
                                      (expand "every" -2)
                                      (("3" (prop) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (induct "l")
                (("1" (skosimp*)
                  (("1" (expand "map")
                    (("1" (expand "length") (("1" (propax) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp*)
                  (("2" (expand "map" 1)
                    (("2" (expand "length" 1) (("2" (inst?) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Term_ type-eq-decl nil wf_FODL_Language nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (list_induction formula-decl nil list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (mTerm def-decl "Carrier" FODL_semantic nil)
    (list_wf_Term_null name-judgement "list[wf_Term_]" FODL_semantic
     nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" union_adt nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   nil
   (m subtype
    "list_adt_map[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], FODL_semantic.Carrier].map(FODL_semantic.mTerm(FODL_semantic.mMetavariable, FODL_semantic.w))(FODL_semantic.list_var)"
    "{l: list_adt[FODL_semantic.Carrier].list | FODL_semantic.sigPredicate(FODL_semantic.pred_var) = list_props[FODL_semantic.Carrier].length(l)}")))
 (m_TCC28 0
  (m_TCC28-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (hide -1)
      (("" (hide -2)
        (("" (hide -2)
          (("" (hide -2)
            (("" (flatten)
              (("" (replace -3)
                (("" (expand "wf" -1) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" union_adt nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | FODL_semantic.mPredicate(FODL_semantic.pred_var)(list_adt_map[wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], FODL_semantic.Carrier].map(FODL_semantic.mTerm(FODL_semantic.mMetavariable, w))(FODL_semantic.list_var))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC29 0
  (m_TCC29-5 "" 3770097321
   ("" (skeep* :preds? t)
    (("" (replace -6 :hide? t)
      (("" (replace -6 :hide? t)
        (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.t0_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC29-4 "" 3651378089
   ("" (skosimp* :preds? t)
    (("" (replace -7 :hide? t)
      (("" (expand "wf" -5) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.t0_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC29-3 "" 3594708303
   ("" (skosimp* :preds? t)
    (("" (replace -9 :hide? t)
      (("" (expand "wf" -7) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.t0_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC29-2 "TCC changes" 3325346380
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.t0_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC29-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.t0_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC30 0
  (m_TCC30-5 "" 3770097352
   ("" (skeep* :preds? t)
    (("" (replace -6 :hide? t)
      (("" (replace -6 :hide? t)
        (("" (expand "wf" -5) (("" (flatten) nil nil)) nil)) nil))
      nil))
    nil)
   ((wf def-decl "boolean" wf_FODL_Language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   shostak
   (m subtype "FODL_semantic.t1_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC30-4 "" 3651378112
   ("" (skosimp* :preds? t)
    (("" (replace -7 :hide? t)
      (("" (expand "wf" -5) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.t1_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC30-3 "" 3594708324
   ("" (skosimp* :preds? t)
    (("" (replace -9 :hide? t)
      (("" (expand "wf" -7) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.t1_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC30-2 "TCC changes" 3325346444
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -7 -6)
            (("" (replace -6 -3)
              (("" (expand "every" -3)
                (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.t1_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC30-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype "FODL_semantic.t1_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC31 0
  (m_TCC31-3 "" 3594708356
   ("" (skosimp* :preds? t)
    (("" (replace -7 :hide? t) (("" (assert) nil nil)) nil)) nil)
   ((Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | FODL_semantic.mTerm(FODL_semantic.mMetavariable, w)(FODL_semantic.t0_var) = FODL_semantic.mTerm(FODL_semantic.mMetavariable, w)(FODL_semantic.t1_var)})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC31-2 "TCC changes" 3325346495
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (replace -6 1) (("" (assert 1) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((Term_ type-eq-decl nil FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPMetavariable formal-const-decl "[Metavariable -> TypePred]"
     FODL_semantic nil)
    (AssMetavariable type-eq-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | FODL_semantic.mTerm(FODL_semantic.mMetavariable, w)(FODL_semantic.t0_var) = FODL_semantic.mTerm(FODL_semantic.mMetavariable, w)(FODL_semantic.t1_var)})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC31-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten) (("" (replace -6 1) (("" (assert 1) nil nil)) nil))
      nil))
    nil)
   ((c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | FODL_semantic.mTerm(FODL_semantic.mMetavariable, w)(FODL_semantic.t0_var) = FODL_semantic.mTerm(FODL_semantic.mMetavariable, w)(FODL_semantic.t1_var)})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC32 0
  (m_TCC32-2 "TCC changes" 3325346600
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC32-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil))
   nil
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC33 0
  (m_TCC33-1 nil 3267007475 ("" (grind) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var))"
    "nil")))
 (m_TCC34 0
  (m_TCC34-2 "TCC changes" 3325346655
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | EXISTS (t: (FODL_semantic.mTypePred(FODL_semantic.TPVariable(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var))))): union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(w WITH [(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var)) := t])})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC34-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (hide -1)
      (("" (hide -2)
        (("" (hide -2)
          (("" (hide -2)
            (("" (flatten)
              (("" (replace -3)
                (("" (expand "wf" -1) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | EXISTS (t: (FODL_semantic.mTypePred(FODL_semantic.TPVariable(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var))))): union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(w WITH [(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var)) := t])})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC35 0
  (m_TCC35-2 "TCC changes" 3325346765
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC35-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil))
   nil
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC36 0
  (m_TCC36-2 "TCC changes" 3325346798
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   shostak
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var))"
    "nil"))
  (m_TCC36-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2)
      (("" (replace -1)
        (("" (expand "complexity" 1)
          (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var))"
    "nil")))
 (m_TCC37 0
  (m_TCC37-2 "TCC changes" 3325346823
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | FORALL (t: (FODL_semantic.mTypePred(FODL_semantic.TPVariable(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var))))): union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(w WITH [(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var)) := t])})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC37-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (hide -1)
      (("" (hide -1)
        (("" (hide -2)
          (("" (hide -2)
            (("" (flatten)
              (("" (replace -3) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | FORALL (t: (FODL_semantic.mTypePred(FODL_semantic.TPVariable(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var))))): union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(w WITH [(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var)) := t])})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC38 0
  (m_TCC38-2 "TCC changes" 3325346967
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.P_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC38-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v adt-accessor-decl "[(v?) -> Variable]" FODL_Language_adt nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.P_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC39 0
  (m_TCC39-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2)
      (("" (replace -1)
        (("" (expand "complexity" 1)
          (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((complexity const-decl "nat" wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var))"
    "nil")))
 (m_TCC40 0
  (m_TCC40-2 "TCC changes" 3325347005
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC40-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC41 0
  (m_TCC41-1 nil 3267007475 ("" (grind) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var))"
    "nil")))
 (m_TCC42 0
  (m_TCC42-2 "TCC changes" 3325347039
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | EXISTS (wPrime: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(w, wPrime), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(wPrime))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC42-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (hide -1)
      (("" (hide -1)
        (("" (hide -2)
          (("" (hide -2)
            (("" (flatten)
              (("" (replace -3)
                (("" (expand "wf" -1) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | EXISTS (wPrime: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(w, wPrime), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(wPrime))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC43 0
  (m_TCC43-2 "TCC changes" 3325347077
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.P_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC43-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.P_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC44 0
  (m_TCC44-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2)
      (("" (replace -1)
        (("" (expand "complexity" 1)
          (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((complexity const-decl "nat" wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var))"
    "nil")))
 (m_TCC45 0
  (m_TCC45-2 "TCC changes" 3325365681
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC45-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC46 0
  (m_TCC46-1 nil 3267007475 ("" (grind) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var))"
    "nil")))
 (m_TCC47 0
  (m_TCC47-2 "TCC changes" 3325365716
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | FORALL (wPrime: FODL_semantic.World_): booleans.IMPLIES(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(w, wPrime), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(wPrime))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC47-1 nil 3267007475 ("" (cases-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inl({w: FODL_semantic.World_ | FORALL (wPrime: FODL_semantic.World_): booleans.IMPLIES(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(w, wPrime), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(wPrime))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC48 0
  (m_TCC48-1 nil 3267007475 ("" (grind) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m cases "FODL_semantic.f"
    "FODL_Language[Constant: TYPE, Metavariable: TYPE, Variable: TYPE, Predicate: TYPE, sigPredicate: [FODL_Language_adt.Predicate -> naturalnumbers.nat], Function_: TYPE, sigFunction_: [FODL_Language_adt.Function_ -> naturalnumbers.nat]]: DATATYPE WITH SUBTYPES Term_, Formula_, Program_
 BEGIN
  c(c: Constant): c?: Term_
  m(m: Metavariable): m?: Term_
  v(v: Variable): v?: Term_
  F(f: Function_, lF: {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}): F?: Term_
  TRUE: TRUE?: Formula_
  FALSE: FALSE?: Formula_
  NOT(f: Formula_): NOT?: Formula_
  IMPLIES(f_0, f_1: Formula_): IMPLIES?: Formula_
  OR(f_0, f_1: Formula_): OR?: Formula_
  AND(f_0, f_1: Formula_): AND?: Formula_
  IFF(f_0, f_1: Formula_): IFF?: Formula_
  P(p: Predicate, lP: {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}): P?: Formula_
  =(t_0: Term_, t_1: Term_): EQ?: Formula_
  EXISTS_(x: (v?), f: Formula_): EXISTS?: Formula_
  FORALL_(x: (v?), f: Formula_): FORALL?: Formula_
  ◇(P: Program_, f: Formula_): DIAMOND?: Formula_
  □(P: Program_, f: Formula_): BOX?: Formula_
  T?(f: Formula_): T??: Program_
  A(pre_post: [Formula_, Formula_]): A?: Program_
  SKIP: SKIP?: Program_
  <|(x: (v?), t: Term_): ASSIGNMENT?: Program_
  //(P_0, P_1: Program_): COMPOSITION?: Program_
  +(P_0, P_1: Program_): CHOICE?: Program_
  *(P: Program_): ITERATION?: Program_
 END FODL_Language")))
 (m_TCC49 0
  (m_TCC49-2 "TCC changes" 3325365751
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC49-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -6 -5)
          (("" (replace -5 -4)
            (("" (expand "every" -4)
              (("" (expand "wf" -4) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.f_var"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC50 0
  (m_TCC50-2 "TCC changes" 3325365824
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   shostak
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var))"
    "nil"))
  (m_TCC50-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2)
      (("" (replace -1)
        (("" (expand "complexity" 1)
          (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var))"
    "nil")))
 (m_TCC51 0
  (m_TCC51-2 "TCC changes" 3325366128
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.AND(wp`1 = wp`2, union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(wp`1))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC51-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.AND(wp`1 = wp`2, union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.f_var)))(wp`1))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC52 0
  (m_TCC52-2 "TCC changes" 3325366155
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.pp`1"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC52-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -5 -4)
        (("" (replace -4 -3)
          (("" (expand "every" -3)
            (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.pp`1"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC53 0
  (m_TCC53-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2)
      (("" (replace -1)
        (("" (expand "complexity" 1)
          (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((complexity const-decl "nat" wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.pp`1))"
    "nil")))
 (m_TCC54 0
  (m_TCC54-2 "TCC changes" 3325366190
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.pp`2"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC54-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -5 -4)
          (("" (replace -4 -3)
            (("" (expand "every" -3)
              (("" (expand "wf" -3) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.pp`2"
    "wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC55 0
  (m_TCC55-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.pp`2))"
    "nil")))
 (m_TCC56 0
  (m_TCC56-2 "TCC changes" 3325366219
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | FORALL (mMetavariable: FODL_semantic.AssMetavariable): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.pp`1)))(wp`1), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.pp`2)))(wp`2))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC56-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2) (("" (replace -1) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | FORALL (mMetavariable: FODL_semantic.AssMetavariable): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.pp`1)))(wp`1), union_adt[PRED[World_], PRED[[World_, World_]]].left(FODL_semantic.m(mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inl(FODL_semantic.pp`2)))(wp`2))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC57 0
  (m_TCC57-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | wp`1 = wp`2})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC58 0
  (m_TCC58-2 "TCC changes" 3325366250
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil))
   shostak
   (m subtype "FODL_semantic.term_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC58-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.term_var"
    "wf_Term_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC59 0
  (m_TCC59-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (hide -1)
      (("" (hide -2)
        (("" (hide -2)
          (("" (hide -2)
            (("" (flatten)
              (("" (replace -3)
                (("" (expand "wf" -1) (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" union_adt nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | wp`2 = wp`1 WITH [(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var)) := IF FODL_semantic.mTypePred(FODL_semantic.TPVariable(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var)))(FODL_semantic.mTerm(FODL_semantic.mMetavariable, wp`1)(FODL_semantic.term_var)) THEN FODL_semantic.mTerm(FODL_semantic.mMetavariable, wp`1)(FODL_semantic.term_var) ELSE wp`1(FODL_Language_adt[FODL_semantic.Constant, FODL_semantic.Metavariable, FODL_semantic.Variable, FODL_semantic.Predicate, FODL_semantic.sigPredicate, FODL_semantic.Function_, FODL_semantic.sigFunction_].v(FODL_semantic.var_var)) ENDIF]})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC60 0
  (m_TCC60-2 "TCC changes" 3325366275
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.P1_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC60-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (v? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (c? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (m? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (F? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Term_ type-eq-decl nil FODL_Language_adt nil))
   nil
   (m subtype "FODL_semantic.P1_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC61 0
  (m_TCC61-1 nil 3267007475 ("" (grind) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P1_var))"
    "nil")))
 (m_TCC62 0
  (m_TCC62-2 "TCC changes" 3325366324
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.P2_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC62-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.P2_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC63 0
  (m_TCC63-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2)
      (("" (replace -1)
        (("" (expand "complexity" 1)
          (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((complexity const-decl "nat" wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P2_var))"
    "nil")))
 (m_TCC64 0
  (m_TCC64-2 "TCC changes" 3325366370
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | EXISTS (w: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P1_var)))(wp`1, w), union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P2_var)))(w, wp`2))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC64-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (hide -1)
      (("" (hide -2)
        (("" (hide -2)
          (("" (flatten)
            (("" (expand "wf" -1) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | EXISTS (w: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P1_var)))(wp`1, w), union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P2_var)))(w, wp`2))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC65 0
  (m_TCC65-2 "TCC changes" 3325366485
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.P1_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC65-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (replace -7 -6)
        (("" (replace -6 -5)
          (("" (expand "every" -5)
            (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.P1_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC66 0
  (m_TCC66-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2)
      (("" (replace -1)
        (("" (expand "complexity" 1)
          (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((complexity const-decl "nat" wf_FODL_Language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P1_var))"
    "nil")))
 (m_TCC67 0
  (m_TCC67-2 "TCC changes" 3325366517
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.P2_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC67-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -7 -6)
          (("" (replace -6 -5)
            (("" (expand "every" -5)
              (("" (expand "wf" -5) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.P2_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC68 0
  (m_TCC68-2 "TCC changes" 3325366553
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   shostak
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P2_var))"
    "nil"))
  (m_TCC68-1 nil 3267007475
   ("" (skosimp*)
    (("" (replace -2)
      (("" (replace -1)
        (("" (expand "complexity" 2)
          (("" (expand "reduce_nat" 2 2) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P2_var))"
    "nil")))
 (m_TCC69 0
  (m_TCC69-2 "TCC changes" 3325366586
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.OR(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P1_var)))(wp), union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P2_var)))(wp))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC69-1 nil 3267007475 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.OR(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P1_var)))(wp), union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P2_var)))(wp))})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC70 0
  (m_TCC70-2 "TCC changes" 3325366622
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m subtype "FODL_semantic.P_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]"))
  (m_TCC70-1 nil 3267007475
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skosimp*)
        (("" (replace -6 -5)
          (("" (replace -5 -4)
            (("" (expand "every" -4)
              (("" (expand "wf" -4) (("" (prop) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m subtype "FODL_semantic.P_var"
    "wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]")))
 (m_TCC71 0
  (m_TCC71-1 nil 3267007475 ("" (termination-tcc) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m termination
    "FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var))"
    "nil")))
 (m_TCC72 0
  (m_TCC72-3 "" 3341601342
   ("" (grind :if-match nil)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil))
    nil)
   ((Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (monotonic? const-decl "bool" mucalculus nil)
    (<= const-decl "bool" mucalculus nil))
   shostak
   (m subtype
    "LAMBDA (p: defined_types[[World_, World_]].PRED): {wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.OR(wp`1 = wp`2, EXISTS (w: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(wp`1, w), p(w, wp`2)))}"
    "(mucalculus[[World_, World_]].monotonic?)"))
  (m_TCC72-2 "TCC changes" 3325366658
   ("" (grind :if-match nil) nil nil)
   ((Carrier formal-nonempty-type-decl nil FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (monotonic? const-decl "bool" mucalculus nil)
    (<= const-decl "bool" mucalculus nil))
   shostak
   (m subtype
    "LAMBDA (p: defined_types[[World_, World_]].PRED): {wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.OR(wp`1 = wp`2, EXISTS (w: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(wp`1, w), p(w, wp`2)))}"
    "(mucalculus[[World_, World_]].monotonic?)"))
  (m_TCC72-1 nil 3267007475
   ("" (skosimp*)
    (("" (expand "monotonic?" 1)
      (("" (skosimp*)
        (("" (expand "<=" 1)
          (("" (skosimp*)
            (("" (prop)
              (("" (skosimp*)
                (("" (inst 2 "w!2")
                  (("" (assert)
                    (("" (expand "<=" -6)
                      (("" (inst -6 "(w!2, s!1`2)")
                        (("" (prop) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   nil
   (m subtype
    "LAMBDA (p: defined_types[[World_, World_]].PRED): {wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.OR(wp`1 = wp`2, EXISTS (w: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(wp`1, w), p(w, wp`2)))}"
    "(mucalculus[[World_, World_]].monotonic?)")))
 (m_TCC73 0
  (m_TCC73-2 "TCC changes" 3325366688
   ("" (grind :if-match nil) nil nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (glb const-decl "pred[T]" mucalculus nil)
    (member const-decl "bool" sets nil)
    (mu const-decl "pred[T]" mucalculus nil)
    (lfp const-decl "pred[T]" mucalculus nil)
    (<= const-decl "bool" mucalculus nil))
   shostak
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({w: [FODL_semantic.World_, FODL_semantic.World_] | mucalculus[[World_, World_]].mu(LAMBDA (p: defined_types[[World_, World_]].PRED): {wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.OR(wp`1 = wp`2, EXISTS (w: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(wp`1, w), p(w, wp`2)))})(w)})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}"))
  (m_TCC73-1 nil 3267007475 ("" (cases-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (reduce_nat adt-def-decl "[FODL_Language -> nat]" FODL_Language_adt
     nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (complexity const-decl "nat" wf_FODL_Language nil))
   nil
   (m subtype
    "union_adt[PRED[World_], PRED[[World_, World_]]].inr({w: [FODL_semantic.World_, FODL_semantic.World_] | mucalculus[[World_, World_]].mu(LAMBDA (p: defined_types[[World_, World_]].PRED): {wp: [FODL_semantic.World_, FODL_semantic.World_] | booleans.OR(wp`1 = wp`2, EXISTS (w: FODL_semantic.World_): booleans.AND(union_adt[PRED[World_], PRED[[World_, World_]]].right(FODL_semantic.m(FODL_semantic.mMetavariable)(union_adt[wf_Formula_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_], wf_Program_[Constant, Metavariable, Variable, Predicate, sigPredicate, Function_, sigFunction_]].inr(FODL_semantic.P_var)))(wp`1, w), p(w, wp`2)))})(w)})"
    "{u: union_adt[PRED[World_], PRED[[World_, World_]]].union | CASES FODL_semantic.l OF inl(f): union_adt[PRED[World_], PRED[[World_, World_]]].inl?(u), inr(P): union_adt[PRED[World_], PRED[[World_, World_]]].inr?(u) ENDCASES}")))
 (m_TCC74 0
  (m_TCC74-2 "TCC changes" 3325366798
   ("" (grind :if-match nil)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil))
    nil)
   ((wf_Program_SKIP name-judgement "wf_Program_" FODL_semantic nil)
    (wf_Formula_FALSE name-judgement "wf_Formula_" FODL_semantic nil)
    (wf_Formula_TRUE name-judgement "wf_Formula_" FODL_semantic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (union type-decl nil union_adt nil)
    (every adt-def-decl "boolean" union_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil))
   shostak
   (m cases "FODL_semantic.P"
    "FODL_Language[Constant: TYPE, Metavariable: TYPE, Variable: TYPE, Predicate: TYPE, sigPredicate: [FODL_Language_adt.Predicate -> naturalnumbers.nat], Function_: TYPE, sigFunction_: [FODL_Language_adt.Function_ -> naturalnumbers.nat]]: DATATYPE WITH SUBTYPES Term_, Formula_, Program_
 BEGIN
  c(c: Constant): c?: Term_
  m(m: Metavariable): m?: Term_
  v(v: Variable): v?: Term_
  F(f: Function_, lF: {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}): F?: Term_
  TRUE: TRUE?: Formula_
  FALSE: FALSE?: Formula_
  NOT(f: Formula_): NOT?: Formula_
  IMPLIES(f_0, f_1: Formula_): IMPLIES?: Formula_
  OR(f_0, f_1: Formula_): OR?: Formula_
  AND(f_0, f_1: Formula_): AND?: Formula_
  IFF(f_0, f_1: Formula_): IFF?: Formula_
  P(p: Predicate, lP: {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}): P?: Formula_
  =(t_0: Term_, t_1: Term_): EQ?: Formula_
  EXISTS_(x: (v?), f: Formula_): EXISTS?: Formula_
  FORALL_(x: (v?), f: Formula_): FORALL?: Formula_
  ◇(P: Program_, f: Formula_): DIAMOND?: Formula_
  □(P: Program_, f: Formula_): BOX?: Formula_
  T?(f: Formula_): T??: Program_
  A(pre_post: [Formula_, Formula_]): A?: Program_
  SKIP: SKIP?: Program_
  <|(x: (v?), t: Term_): ASSIGNMENT?: Program_
  //(P_0, P_1: Program_): COMPOSITION?: Program_
  +(P_0, P_1: Program_): CHOICE?: Program_
  *(P: Program_): ITERATION?: Program_
 END FODL_Language"))
  (m_TCC74-1 nil 3267008378
   ("" (skosimp*)
    (("" (typepred "P!1")
      (("" (prop)
        (("1" (assert) nil nil) ("2" (assert) nil nil)
         ("3" (assert) nil nil) ("4" (assert) nil nil)
         ("5" (assert) nil nil) ("6" (assert) nil nil)
         ("7" (assert) nil nil) ("8" (assert) nil nil)
         ("9" (assert) nil nil) ("10" (assert) nil nil)
         ("11" (assert) nil nil) ("12" (assert) nil nil)
         ("13" (assert) nil nil) ("14" (assert) nil nil)
         ("15" (assert) nil nil) ("16" (assert) nil nil)
         ("17" (assert) nil nil) ("18" (assert) nil nil)
         ("19" (assert) nil nil) ("20" (assert) nil nil)
         ("21" (assert) nil nil) ("22" (assert) nil nil)
         ("23" (assert) nil nil) ("24" (assert) nil nil)
         ("25" (assert) nil nil) ("26" (assert) nil nil)
         ("27" (assert) nil nil) ("28" (assert) nil nil)
         ("29" (assert) nil nil) ("30" (assert) nil nil)
         ("31" (assert) nil nil) ("32" (assert) nil nil)
         ("33" (assert) nil nil) ("34" (assert) nil nil)
         ("35" (assert) nil nil) ("36" (assert) nil nil)
         ("37" (assert) nil nil) ("38" (assert) nil nil)
         ("39" (assert) nil nil) ("40" (assert) nil nil)
         ("41" (assert) nil nil) ("42" (assert) nil nil)
         ("43" (assert) nil nil) ("44" (assert) nil nil)
         ("45" (assert) nil nil) ("46" (assert) nil nil)
         ("47" (assert) nil nil) ("48" (assert) nil nil)
         ("49" (assert) nil nil) ("50" (assert) nil nil)
         ("51" (assert) nil nil) ("52" (assert) nil nil)
         ("53" (assert) nil nil) ("54" (assert) nil nil)
         ("55" (assert) nil nil) ("56" (assert) nil nil)
         ("57" (assert) nil nil) ("58" (assert) nil nil)
         ("59" (assert) nil nil) ("60" (assert) nil nil)
         ("61" (assert) nil nil) ("62" (assert) nil nil)
         ("63" (assert) nil nil) ("64" (assert) nil nil)
         ("65" (assert) nil nil) ("66" (assert) nil nil)
         ("67" (assert) nil nil) ("68" (assert) nil nil)
         ("69" (assert) nil nil) ("70" (assert) nil nil)
         ("71" (assert) nil nil) ("72" (assert) nil nil)
         ("73" (assert) nil nil) ("74" (assert) nil nil)
         ("75" (assert) nil nil) ("76" (assert) nil nil)
         ("77" (assert) nil nil) ("78" (assert) nil nil)
         ("79" (assert) nil nil) ("80" (assert) nil nil)
         ("81" (assert) nil nil) ("82" (assert) nil nil)
         ("83" (assert) nil nil) ("84" (assert) nil nil)
         ("85" (assert) nil nil) ("86" (assert) nil nil)
         ("87" (assert) nil nil) ("88" (assert) nil nil)
         ("89" (assert) nil nil) ("90" (assert) nil nil)
         ("91" (assert) nil nil) ("92" (assert) nil nil)
         ("93" (assert) nil nil) ("94" (assert) nil nil)
         ("95" (assert) nil nil) ("96" (assert) nil nil)
         ("97" (assert) nil nil) ("98" (assert) nil nil)
         ("99" (assert) nil nil) ("100" (assert) nil nil)
         ("101" (assert) nil nil) ("102" (assert) nil nil)
         ("103" (assert) nil nil) ("104" (assert) nil nil)
         ("105" (assert) nil nil) ("106" (assert) nil nil)
         ("107" (assert) nil nil) ("108" (assert) nil nil)
         ("109" (assert) nil nil) ("110" (assert) nil nil)
         ("111" (assert) nil nil) ("112" (assert) nil nil)
         ("113" (assert) nil nil) ("114" (assert) nil nil)
         ("115" (assert) nil nil) ("116" (assert) nil nil)
         ("117" (assert) nil nil) ("118" (assert) nil nil)
         ("119" (assert) nil nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" mucalculus nil)
    (monotonic? const-decl "bool" mucalculus nil)
    (wf_Program_ type-eq-decl nil wf_FODL_Language nil)
    (Program_ type-eq-decl nil FODL_Language_adt nil)
    (wf_Formula_ type-eq-decl nil wf_FODL_Language nil)
    (Formula_ type-eq-decl nil FODL_Language_adt nil)
    (ITERATION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (CHOICE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (COMPOSITION? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (ASSIGNMENT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (SKIP? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (A? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (T?? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (wf def-decl "boolean" wf_FODL_Language nil)
    (BOX? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (DIAMOND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FORALL? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EXISTS? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (EQ? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (P? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IFF? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (AND? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (IMPLIES? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (NOT? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (FALSE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (TRUE? adt-recognizer-decl "[FODL_Language -> boolean]"
     FODL_Language_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union type-decl nil union_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (FODL_Language type-decl nil FODL_Language_adt nil)
    (sigFunction_ formal-const-decl "[Function_ -> nat]" FODL_semantic
     nil)
    (Function_ formal-type-decl nil FODL_semantic nil)
    (sigPredicate formal-const-decl "[Predicate -> nat]" FODL_semantic
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Predicate formal-type-decl nil FODL_semantic nil)
    (Variable formal-type-decl nil FODL_semantic nil)
    (Metavariable formal-type-decl nil FODL_semantic nil)
    (Constant formal-type-decl nil FODL_semantic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (no_metavariable def-decl "boolean" wf_FODL_Language nil)
    (World_ type-eq-decl nil FODL_semantic nil)
    (TPVariable formal-const-decl "[Variable -> TypePred]"
     FODL_semantic nil)
    (mTypePred formal-const-decl "[TypePred -> [Carrier -> bool]]"
     FODL_semantic nil)
    (TypePred formal-type-decl nil FODL_semantic nil)
    (Carrier formal-nonempty-type-decl nil FODL_semantic nil))
   shostak
   (m cases "FODL_semantic.P"
    "FODL_Language[Constant: TYPE, Metavariable: TYPE, Variable: TYPE, Predicate: TYPE, sigPredicate: [FODL_Language_adt.Predicate -> naturalnumbers.nat], Function_: TYPE, sigFunction_: [FODL_Language_adt.Function_ -> naturalnumbers.nat]]: DATATYPE WITH SUBTYPES Term_, Formula_, Program_
 BEGIN
  c(c: Constant): c?: Term_
  m(m: Metavariable): m?: Term_
  v(v: Variable): v?: Term_
  F(f: Function_, lF: {lPrime: list[Term_] | sigFunction_(f) = length(lPrime)}): F?: Term_
  TRUE: TRUE?: Formula_
  FALSE: FALSE?: Formula_
  NOT(f: Formula_): NOT?: Formula_
  IMPLIES(f_0, f_1: Formula_): IMPLIES?: Formula_
  OR(f_0, f_1: Formula_): OR?: Formula_
  AND(f_0, f_1: Formula_): AND?: Formula_
  IFF(f_0, f_1: Formula_): IFF?: Formula_
  P(p: Predicate, lP: {lPrime: list[Term_] | sigPredicate(p) = length(lPrime)}): P?: Formula_
  =(t_0: Term_, t_1: Term_): EQ?: Formula_
  EXISTS_(x: (v?), f: Formula_): EXISTS?: Formula_
  FORALL_(x: (v?), f: Formula_): FORALL?: Formula_
  ◇(P: Program_, f: Formula_): DIAMOND?: Formula_
  □(P: Program_, f: Formula_): BOX?: Formula_
  T?(f: Formula_): T??: Program_
  A(pre_post: [Formula_, Formula_]): A?: Program_
  SKIP: SKIP?: Program_
  <|(x: (v?), t: Term_): ASSIGNMENT?: Program_
  //(P_0, P_1: Program_): COMPOSITION?: Program_
  +(P_0, P_1: Program_): CHOICE?: Program_
  *(P: Program_): ITERATION?: Program_
 END FODL_Language"))))

