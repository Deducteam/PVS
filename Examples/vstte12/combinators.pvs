% 1. reduction is defined over reducible? terms, for which reduction returns t' only if
%    t ->* t'.
% 2. Follows from S_free_implies_reducible_step
% 3. Follws from iter_reduce_ks

combinators: THEORY
  BEGIN

  % We define the term class as a recursive datatype.  We have dispensed
  % with context since the reduce operation performs the same reduction
  % directly on terms.

   term: DATATYPE
    BEGIN
     S: S?
     K: K?
     apply(fun: term, arg: term): apply?
    END term

   P, Q, R: VAR term

  % values are a subset of terms for which value? holds.

   value?(R): RECURSIVE bool =
     CASES R OF
      apply(Rf, Ra): value?(Ra) AND
		     (K?(Rf) OR S?(Rf) OR
		      (apply?(Rf) AND S?(fun(Rf)) AND value?(arg(Rf))))
      ELSE K?(R) OR S?(R)
     ENDCASES
    MEASURE R BY <<

  % (value?) is the subtype of term satisfying value?    
   U, V, W: VAR (value?)

  % K_redex? and S_redex? characterize the two left-hand sides of the
  % reduction relation

   K_redex?(R): bool =
     (apply?(R) AND apply?(fun(R)) AND value?(arg(R)) AND
      K?(fun(fun(R))) AND value?(arg(fun(R))))

   S_redex?(R) : bool =
     (apply?(R) AND apply?(fun(R)) AND value?(arg(R)) AND
       apply?(fun(fun(R))) AND S?(fun(fun(fun(R)))) AND
           value?(arg(fun(R))) AND value?(arg(fun(fun(R)))))

   % A redex is either a K_redex or an S_redex	   

   redex?(R): bool =
      (K_redex?(R) OR S_redex?(R))

   % The reduce operation finds the left-most, innermost redex
   % and applies the reduction rule to it

   reduce(R): RECURSIVE term =
     (IF K_redex?(R) THEN (arg(fun(R)))
      ELSIF S_redex?(R) THEN apply(apply(arg(fun(fun(R))), arg(R)),
                                   apply(arg(fun(R)), arg(R)))
      ELSIF apply?(R) THEN IF value?(fun(R))
                           THEN apply(fun(R), reduce(arg(R)))
	                   ELSE apply(reduce(fun(R)), arg(R)) ENDIF
      ELSE R ENDIF)
     MEASURE R BY <<

   % size(R) is the number of combinator occurrences
   % The reduce_nat operator generated by the DATATYPE declaration:
   % the first two arguments handle the K and S cases, and the
   % third argument + applies to the results of the recursive
   % evaluation of reduce_nat on the operator and argument of apply

   size(R): posnat = reduce_nat(1, 1, +)(R)

   size_apply: LEMMA size(apply(Q, R)) = size(Q) + size(R)

   % A value is irreducible, and all irreducible terms are values

   reduce_value: LEMMA value?(R) iff (reduce(R) = R)

   context: DATATYPE
    BEGIN
     hole: hole?
     l_apply(lfun: context, larg: term): l_apply?
     r_apply(rfun: (value?), rarg: context): r_apply?
    END context

    C, D: VAR context

    csubst(C, R): RECURSIVE term =
     CASES C OF
       hole: R,
       l_apply(D, Q): apply(csubst(D, R), Q),
       r_apply(V, D): apply(V, csubst(D, R))
     ENDCASES
     MEASURE C BY <<

     redex_reduce(X: (redex?)): term =
       (IF K_redex?(X)
          THEN (arg(fun(X)))
          ELSE apply(apply(arg(fun(fun(X))), arg(X)),
                     apply(arg(fun(X)), arg(X)))
        ENDIF)		     

     reduce_rel(R, Q): bool =
       (EXISTS C, (X: (redex?)):
         R = csubst(C, X) AND Q = csubst(C, redex_reduce(X)))

     rtc_reduce_rel(R, Q): INDUCTIVE bool =
       (R = Q OR
         (EXISTS P: reduce_rel(R, P) AND rtc_reduce_rel(P, Q)))

     reduce_context: RECURSIVE JUDGEMENT
        reduce(R) HAS_TYPE
	   {Q | IF value?(R)
	         THEN R = Q
		 ELSE reduce_rel(R, Q)
	         ENDIF}


   m, n: VAR nat

   % iter_reduce applies reduce n times to R. 

   iter_reduce(n)(R): RECURSIVE term =
      (IF n = 0
          THEN R
	  ELSE (LET Q = reduce(R)
	         IN IF R = Q THEN R ELSE iter_reduce(n - 1)(Q) ENDIF)
	ENDIF)
     MEASURE n

   iter_reduce_rtc_reduce_rel: RECURSIVE JUDGEMENT
      iter_reduce(n)(R) HAS_TYPE {Q | rtc_reduce_rel(R, Q)}

   % A term R is reducible if there is some iteration of reduce
   % that yields a value on it.  The value of a reducible term
   % is computed by reduction.  This corresponds to the existence
   % of an irreducible t' such that t ->* t'

   reducible?(R): bool = (EXISTS n: value?(iter_reduce(n)(R)))

   reduction(R: (reducible?)): (value?)
       = iter_reduce(choose! n: value?(iter_reduce(n)(R)))(R)


   reduction_rtc_reduce_rel: JUDGEMENT
     reduction(R: (reducible?)) HAS_TYPE {Q | rtc_reduce_rel(R, Q)}

   % Exercise 2: We define the predicate S_free? to check that R contains no S
     
   S_free?(R): RECURSIVE bool =
      (CASES R OF
        apply(Rf, Ra): S_free?(Rf) AND S_free?(Ra),
	K: TRUE,
        S:  FALSE
	ENDCASES)
      MEASURE R BY <<

   S_free_size: LEMMA
       S_free?(R) IMPLIES (reduce(R) = R OR size(reduce(R)) < size(R))

   S_free_reduce: LEMMA
       S_free?(R) IMPLIES S_free?(reduce(R))

   iter_reduce_reduce: LEMMA
       reduce(R) = R IMPLIES iter_reduce(n)(R) = R

   % Any S_free term reduces to a value for a bound given by its size       

   S_free_implies_reducible_step: LEMMA
       (FORALL n: n >= size(R) AND S_free?(R) IMPLIES value?(iter_reduce(n)(R)))

   % Exercise 3: The ks function is defined to construct a nested application of Ks.       

   ks(n): RECURSIVE (S_free?) = 
       (if n = 0 THEN K ELSE apply(ks(n - 1), K) ENDIF)
     MEASURE n

   % A useful theorem for moving reduce from the front to the back of a reduction
   % sequence

   reduce_iter_reduce: LEMMA
       iter_reduce(n)(reduce(R)) = reduce(iter_reduce(n)(R))

   % Two iterations of ks yields a K redex

   reduce_ks: LEMMA
       reduce(ks(n+ 2)) = ks(n)

   % Exercise 3
   
   iter_reduce_ks: LEMMA
       m >= n IMPLIES
         iter_reduce(m)(ks(n)) = (IF even?(n) THEN K ELSE apply(K, K) ENDIF)
	
  END combinators
