% Document Type: LaTeX
% Master File: language.tex

\chapter{Theories}\label{theories}
\index{theories}

Specifications in \pvs\ are built from {\em theories}, which provide
genericity, reusability, and structuring.  \pvs\ theories may be
parameterized.  A theory consists of a {\em theory
identifier\/}, a list of formal {\em parameters\/}, an {\tt EXPORTING}
clause, an {\em assuming part\/}, a {\em theory body\/}, and an ending
id.  The syntax for theories is shown in Figure~\ref{bnf-theory}.

\pvsbnf{bnf-theory}{Theory Syntax}

Everything is optional except the identifiers and the keywords.  Thus
the simplest theory has the form
\begin{pvsex}
  triv : THEORY
    BEGIN
    END triv
\end{pvsex}

The formal parameters, assuming, and theory body consist of declarations
and {\tt IMPORTING}s.  The various declarations are described in
Section~\ref{declarations}.  In this section we discuss the restrictions
on the allowable declarations within each section, the formal
parameters, the assuming part, and the {\tt EXPORTING}s and {\tt IMPORTING}s.

%Theories are used to introduce
%variables, constants, functions, and formulas.  They may be
%parameterized by types or constants,\footnote{Future releases of \pvs\
%will allow theory and subtype parameters.} and may specify constraints
%on the use of the theory by providing an assuming part.  Entities from
%other theories may be introduced by means of {\tt IMPORTING} clauses.
%Entities declared in a theory may be exported with an {\tt EXPORTING}
%clause.

The {\tt groups} theory below illustrates these concepts.  It views a
group as a 4-tuple consisting of a type {\tt G}, an identity element
{\tt e} of {\tt G}, and operations {\tt o}\footnote{Recall that {\tt o}
is an infix operator.} and {\tt inv}.  Note the use of the type
parameter {\tt G} in the rest of the formal parameter list.  The
assuming part provides the group axioms.  Any use of the {\tt groups}
theory incurs the obligation to prove all of the {\tt ASSUMPTION}s.  The
body of the {\tt groups} theory consists of two theorems, which can be
proved from the assumptions.

\pvstheory{groups-alltt}{Theory {\tt groups}}{groups-alltt}

\section{Theory Identifiers}

The theory identifier introduces a name for a theory; as described in
Section~\ref{names}, this identifier can be used to help disambiguate
references to declarations of the theory.

In the \pvs\ system, the set of theories currently available to the
session form a {\em context\/}.  Within the context theory names must be
unique.  There is an initial context available, called the prelude,
which provides, among other things, the Boolean operators, equality, and
the {\tt real}, {\tt rational}, {\tt integer}, and {\tt naturalnumber}
types and their associated properties.  The only difference between the prelude and
user-defined theories is that the prelude is automatically imported in
every theory, without requiring an explicit \rsv{IMPORTING} clause.

The end identifier must match the theory identifier, or an error is
signaled.


\section{Theory Parameters}\label{parameters}
\index{theory parameters|(}
\index{formal parameters|see{theory parameters}}

The theory parameters allow theory schemas to be specified.  This
provides support for {\em universal polymorphism\/}\index{polymorphism}

Theory parameters may be types, subtypes, or constants, and {\tt
IMPORTING}s may be interspersed.  Theory parameters must have unique
identifiers.  The parameters are ordered, allowing later parameters to
refer to earlier ones.  This is another form of dependency, akin to
dependent types (see Section~\ref{dependent-types}).  A theory is {\em
instantiated\/} from within another theory by providing {\em actual
parameters\/}\index{actual parameters} to substitute for the formals.
Actual parameters may occur in {\tt IMPORTING}s, {\tt EXPORTING}s, theory
declarations, and names.  In each case they are enclosed in braces ({\tt
[} and {\tt ]}) and separated with commas.

The actuals must match the formals in number, kind, and (where
applicable) type.  In this matching process the {\tt IMPORTING}s, which
must be enclosed in parentheses, are ignored.  For example, given the
theory declaration
\begin{pvsex}
  T [t: TYPE,
     subt: TYPE FROM t
     (IMPORTING orders[subt]) <=: (partial_order?),
     c: subt,
     d: \{x:subt | c <= x\}]
\end{pvsex}
a valid instance has five actual parameters; an example is
\begin{pvsex}
  T[int, \{x:nat | x < 10\}, <=, 5, 6]
\end{pvsex}
%
Note that the matching process may lead to the generation of \emph{actual}
\tccs.\index{actual TCC}\index{TCC!actual}

\index{theory parameters|)}


\section{{\tt IMPORTING}s and {\tt EXPORTING}s}\label{importings}

The \rsv{IMPORTING} and \rsv{EXPORTING} clauses form a hierarchy,
much like the subroutine hierarchy of a programming
language.

Names declared in a theory may be made available to other theories in
the same context by means of the {\tt EXPORTING} clause.  Names exported
by a given theory may be imported into a second theory by means of the
{\tt IMPORTING} clause.  Names that are exported from one theory are said to
be {\em visible\/} to any theory which uses the given theory.  In this
section we describe the syntax of the {\tt EXPORTING} and {\tt IMPORTING}
clauses and give some simple examples.

\pvsbnf{bnf-exporting}{Importing and Exporting Syntax}


\subsection{The {\tt EXPORTING} Clause}
\index{exporting@{\tt EXPORTING}|(}

The {\tt EXPORTING} clause specifies the names declared in the theory
which are to be made available to any theory \texttt{IMPORTING} it.  It may
also specify instances of the theories which it imported to be exported.
The syntax of the {\tt EXPORTING} clause is given in
Figure~\ref{bnf-exporting}.

\noindent
The {\tt EXPORTING} clause is optional; if omitted, it defaults to
\begin{alltt}
  EXPORTING ALL WITH ALL
\end{alltt}

Any declared name may be exported except for variable declarations and formal parameters.
When {\tt ALL} is specified for the {\em ExportingNames\/}, all
entities declared in the theory aside from the variables are exported.
If a list of names is specified, then these are exported.  Finally, when
a list of names follows {\tt ALL BUT}, all names aside from these are exported.

Since PVS supports overloading, it is possible that the exported name
will be ambiguous.  Such names may be disambiguated by including the
type, if it is a constant, or by including one of the keywords {\tt
TYPE} or {\tt FORMULA}.  The keyword {\tt TYPE} is used for any type
declaration, and {\tt FORMULA} is used for any formula declaration
(including {\tt AXIOM}s, {\tt LEMMA}s, etc.)  If not disambiguated, all
declarations (except variables and formals) with the specified id will be exported.

When names are specified they are checked for {\em completeness\/}.
This means that when a name is exported all of the names on which the
corresponding declaration(s) depend must also be exported.  Thus, for
example, given the following declarations
\begin{alltt}
  sometype: TYPE
  someconst: sometype
\end{alltt}
it would be illegal to export {\tt someconst} without also exporting
{\tt sometype}.  Note that this check is unnecessary if exporting {\tt
ALL} without {\tt BUT}.

In some cases it is desirable (or necessary for completeness) to
export some of the instances of the theories which are used by the
given theory.  This is done by specifying a {\tt WITH} subclause as a
part of the {\tt EXPORTING} clause.  The {\tt WITH} subclause may be
{\tt ALL}, indicating that all instances of theories used by the given
theory are exported.  If {\tt CLOSURE} is specified, then the
typechecker determines the instances to be exported by a {\em
completion analysis\/}\index{completion analysis} on the exported
names.  Completion analysis determines those entities that are
directly or indirectly referenced by one of the exported
names.\footnote{Proofs are not used in completion analysis.} Finally,
a list of theory names may be given; in this case the theory names
must be complete in the sense that if an exported name refers to an
entity in another theory instance, then that theory instance must be
exported also.  Other theory instances may also be exported even if
not actually needed for completeness in this sense.  The {\tt WITH}
subclause may only reference theory instances, \ie\ theory names with
actuals provided for all of the corresponding formal parameters.

As a practical matter, it is probably best not to include an {\tt
EXPORTING} clause unless there is a good reason.  That way everything
that is declared will be visible at higher levels of the {\tt IMPORTING}
chain.

\index{exporting@{\tt EXPORTING}|)}

\subsection{{\tt IMPORTING} Clauses}

{\tt IMPORTING} clauses import the visible names of another theory.  {\tt
IMPORTING} clauses may appear in the formal parameters list, the assuming
part, or the theory part of a theory.  In addition, theory abbreviations
implicitly import the theory name that they abbreviate (see
Section~\ref{theory-abbreviations}).

The names appearing in an {\tt IMPORTING} or theory abbreviation specifies a
theory and optionally gives an instance of that theory, by providing
actual parameters corresponding to the formal parameters of the theory
used.  {\tt IMPORTING}s are cumulative; entities made visible at some point
in a theory are visible to every declaration following.

An {\tt IMPORTING} with actual parameters provided is said to be a {\em
theory instance\/}.\index{theory instance} We use the same terminology for
an {\tt IMPORTING} that refers to theory that has no formal parameters.
Otherwise it is referred to as a {\em generic\/}\index{generic reference}
reference.

A single theory may appear in any number of {\tt IMPORTING}s of another
theory, both instantiated and generic.  Obviously, any time there is
more than one {\tt IMPORTING} of a given theory there is a chance for
ambiguity.  Section~\ref{names} discusses such ambiguities, explaining
how the system attempts to resolve them and how the user can
disambiguate in situations where the system cannot.

An {\tt IMPORTING} forms a relation between the theory containing the {\tt
IMPORTING} and the theory referenced.  The transitive closure of the {\tt
IMPORTING} relation is called the {\em importing chain\/} of a theory.  The
importing chain must form a directed acyclic graph; hence a theory may not
end up importing itself, directly or indirectly.


\section{Theory Abbreviations}\label{theory-abbreviations}
\index{theory abbreviations}

A theory abbreviation introduces a new name for a theory instance,
providing an alternate means for referring to the instance.  For
example, given the declaration
\begin{pvsex}
  fsets: THEORY = sets[[integer -> integer]]
\end{pvsex}
where {\tt sets} is a theory in which the function {\tt member} is
declared, the name {\tt sets[[integer -> integer]].member} may instead
be written as {\tt fsets.member}.  The body of a theory abbreviation
must refer to a theory of the current context or the prelude, and the
actual parameters must be compatible (in number, kind, and type) with
the corresponding theory parameters\index{theory parameters}.

In addition to providing an abbreviation, such declarations do an
implicit {\tt IMPORTING}\index{IMPORTING@{\tt IMPORTING}} of the theory instance.
Theory abbreviations may not be exported.


\section{Assuming Part}\label{assuming}

The assuming part consists of top-level declarations and {\tt IMPORTING}s.
The assuming part precedes the theory part, so the
theory part may refer to entities declared in the assuming part.  The
grammar for the assuming part is given in Figure~\ref{bnf-assuming}.

\pvsbnf{bnf-assuming}{Assuming Syntax}

The primary purpose of the assuming part is to provide constraints on the
use of the theory, by means of {\tt ASSUMPTION}s.  These are formulas
expressing properties that are expected to hold of any instance of the
theory.  They are generally stated in terms of the formal parameters, and
when instantiated they become \emph{assuming} \tccs\ \index{assuming
TCC}\index{TCC!assuming} {\tt OBLIGATION}s which must be discharged.  For
example, given the theory {\tt groups} above, the importing
\begin{pvsex}
  IMPORTING groups[int, 0, +, -]
\end{pvsex}
generates the following obligations
\begin{pvsex}
  % Assuming TCC generated for  groups[int, 0, +, -]
  IMPORTING1_TCC1: OBLIGATION
    (FORALL (a: int), (b: int), (c: int):
         +(a, (+(b, c))) = +((+(a, b)), c))
  
  % Assuming TCC generated for  groups[int, 0, +, -]
  IMPORTING1_TCC2: OBLIGATION (FORALL (a: int):
         +(0, a) = a AND +(a, 0) = a)
  
  % Assuming TCC generated for  groups[int, 0, +, -]
  IMPORTING1_TCC3: OBLIGATION (FORALL (a: int):
         +(-(a), a) = 0 AND +(a, -(a)) = 0)
\end{pvsex}

Except for the variable declarations, the declarations of the assumings
are all externally visible.  
  
The dynamic semantics of an \emph{assuming} part of a theory is as
follows.  Internal to the theory, assumptions are used exactly as axioms
would be used.  Externally, for each import of a theory, the assumptions
have to be discharged (i.e., proved) with the actual parameters replacing
the formal parameters.  Note that in terms of the proof chain, every proof
in a theory depends on the proofs of the assumptions.

Assuming \tccs\ are generated when a theory is instantiated, which may or
may not occur when it is imported.  Thus if a theory with assumptions is
imported generically, the assuming \tccs\ are not generated until some
reference is instantiated.  If a theory instance is imported, then the
assuming \tccs\ precede the importing in the dynamic semantics.  Note that
this may not make sense, as the assumings may refer to entities that are
not visible until after the theory is imported.  Thus the following is
illegal.
\begin{pvsex}
  assuming_test[n: nat, m: {x:int | x < n}]: THEORY
  BEGIN
   ASSUMING
    rel_prime?(x, y: int): bool = EXISTS (a, b: int): x*a + y*b = 1
    rel_prime: ASSUMPTION rel_prime?(n,m)
   ENDASSUMING
  END assuming_test

  assimp: THEORY
  BEGIN
   IMPORTING assuming_test[4, 2]
  END assimp
\end{pvsex}
And leads to the following error message.
\begin{pvsex}
  Error: assumption refers to 
    assuming_test[4, 2].rel_prime?,
  which is not visible in the current theory
\end{pvsex}
There are a number of ways to solve this problem.  Perhaps the simplest is
to first import the theory generically, then import the instance.
\begin{pvsex}
   IMPORTING assuming_test
   IMPORTING assuming_test[4, 2]
\end{pvsex}
Now the reference to \texttt{rel\_prime?} makes sense in the assuming
\tcc\ generated for the second importing.

In this case, another solution is to simply define \texttt{rel\_prime?} as
a \emph{macro} (see Section~\ref{macro-declarations}).
\begin{pvsex}
  rel_prime?(x, y: int): MACRO bool = EXISTS (a, b: int): x*a + y*b = 1
\end{pvsex}
Of course, this will not work if the declaration in question is a
recursive or inductive definition.

Another solution is to provide the declaration in a theory that is
imported in both the theory with the assuming and the theory importing
that theory.
\begin{pvsex}
  rel_prime[y:int]: THEORY
  BEGIN
   rel_prime?(x: int): bool = EXISTS (a, b: int): x*a + y*b = 1
  END assth2

  assuming_test[n: nat, m: {x:int | x < n}]: THEORY
  BEGIN
   ASSUMING
    IMPORTING rel_prime[m]
    rel_prime: ASSUMPTION rel_prime?(n)
   ENDASSUMING
  END assuming_test2

  assuming_imp: THEORY
  BEGIN
   IMPORTING rel_prime[2], assuming_test[4, 2]
  END assuming_imp
\end{pvsex}
Now the reference to \texttt{rel\_prime?} in the assuming \tcc\ associated
with \texttt{assuming\_test[4, 2]} is the same as the previously imported
instance, so there is no problem.  In the theory \texttt{assuming\_imp},
\texttt{rel\_prime} may also be imported generically.  However, if
\texttt{rel\_prime} is not imported, or is imported with a different
parameter (e.g., \texttt{rel\_prime[3]}) then the above error is produced.


\section{Theory Part}

The theory part consists of top-level declarations and {\tt IMPORTING}s.
Declarations are ordered; references may not be made to declarations
which occur later in the theory.  The theory part usually contains the
main body of the theory.  Assuming declarations are not allowed in the
theory part.  The grammar for the theory part is given in
Figure~\ref{bnf-theory-part}.

\pvsbnf{bnf-theory-part}{Theory Part Syntax}
