% Master File: language.tex

\section{Tables}
\index{tables|(}

Many expressions are easier to express and to read when presented in
tabular form, as described in~\cite{Heitmeyer94:SCR-checks,Parnas92}.
There are many types of tables, ten different interpretations are
described in~\cite{Parnas92} alone.  Rather than provide support for all
these tables, we chose to support a simple form of table initially,
providing extensions in later versions of PVS as the need arises.

PVS provides a form of table expressions that allows simple
tables\footnote{In Parnas' terms~\cite{Parnas92}, these tables are
\emph{normal function tables} of one or two dimensions.} to be presented,
and supports \emph{table consistency conditions}\index{table consistency}.
One of the consistency conditions (the \emph{Mutual Exclusion
Property}\index{mutual exclusion property} or
\emph{disjointness}\index{disjointness property}) requires the pairwise
conjunction of a set of formulas to be false; another (the \emph{Coverage
Property}\index{coverage property}) requires the disjunction of a set of
formulas to be true.

Tables are supported by means of the more generic \texttt{COND}
expression, which provides the semantic foundation.  In the following
sections, we first describe the \texttt{COND} expression, and then
\texttt{TABLE} expressions.

\subsection{\texttt{COND} Expressions}
\index{cond expressions@\texttt{COND} expressions|(}

The {\tt COND} construct is a multi-way extension to the polymorphic
{\tt IF-THEN-ELSE} construct of PVS\@.  Its form is
\begin{pvsex}
  COND
      be\_1 -> e\_1,
      be\_2 -> e\_2,
        \ldots
      be\_n -> e\_n
  ENDCOND
\end{pvsex}
where the {\tt be\_}i's are boolean expressions, and the {\tt e\_}i's are
expressions of some common supertype.  It is required that the {\tt
be\_}i's are pairwise disjoint and that their disjunction is a tautology:
these constraints are generated as \emph{disjointness}\index{disjointness
TCC}\index{TCC!disjointness} and \emph{coverage}\index{coverage
TCC}\index{TCC!coverage} TCCs that must be discharged before PVS will
consider a {\tt COND} expression fully type-correct.
\begin{pvsex}
  foo_TCC1: OBLIGATION NOT (be\_1 AND be\_2) AND\ldots{}AND NOT (be\_n-1 AND be\_n)
  foo_TCC2: OBLIGATION be\_1 OR be\_2 OR\ldots{}OR be\_n
\end{pvsex}

Notice that a {\tt COND} expression with $n$ clauses generates $O(n^2)$
clauses in its disjointness TCC\@.  

Assuming its associated TCCs are discharged, the schematic {\tt COND}
shown above is equivalent to the following {\tt IF-THEN-ELSE} form,
which is its semantic definition.

\begin{pvsex}
  IF be\_1 THEN e\_1
  ELSIF be\_2 THEN e\_2
          \ldots
  ELSIF be\_n-1 THEN e\_n-1
  ELSE e\_n
\end{pvsex}

The {\tt COND} may include an {\tt ELSE} clause:
\begin{pvsex}
  COND
      be\_1 -> e\_1,
      be\_2 -> e\_2,
        \ldots
      ELSE -> e\_n
  ENDCOND
\end{pvsex}
This form does not require the coverage TCC and is equivalent to the
same {\tt IF-THEN-ELSE} form shown above.

\input{bnf-cond-expr}

Using {\tt COND}, we can translate the following tabular
specification of the \emph{sign} function
\[
\begin{array}{|c||c|c|c|}
\hline
 & x<0 & x=0 & x>0\\
\hline
\emph{sign}(x) & -1 & 0 & 1\\
\hline
\end{array}
\]
into
\begin{pvsex}
  sign(x): int = COND
                    x<0 -> -1, 
                    x=0 -> 0,
                    x>0 -> 1
                 ENDCOND
\end{pvsex}

Two dimensional tables can be generated by nested {\tt COND}s.  For
example, the following table defining the value for {\tt safety\_injection}
\begin{center}
\begin{tabular}{|c||c|c|}
\hline
modes & \multicolumn{2}{c|}{conditions} \\
\hline
\hline
normal & false & true\\
\hline
low & not overridden & overridden \\
\hline
voter\_failure & true & false\\
\hline
\hline
safety\_injection & on & off\\
\hline
\end{tabular}
\end{center}
can be represented as
\begin{pvsex}
  safety\_injection(mode, overridden): on\_off = 
    COND
      mode=normal -> off,
      mode=low -> (COND NOT overridden -> on, overridden -> off ENDCOND),
      mode=voter\_failure -> on
    ENDCOND
\end{pvsex}

Notice that {\tt mode=low} provides the ``left context'' used in
generating the TCCs for the nested {\tt COND}.  This causes some
redundancy in highly structured two dimensional tables as the
following example shows.
\begin{center}
\begin{tabular}{|c||c|c|}
\hline
 & \multicolumn{2}{c|}{input}\\
\cline{2-3}
state & x & y\\
\hline
\hline
a & a & b\\
\hline
b & b & b\\
\hline
\end{tabular}
\end{center}
This translates to
\begin{pvsex}
  COND
    state=a -> COND input=x -> a,input=y -> b ENDCOND,
    state=b -> COND input=x -> b,input=y -> b ENDCOND
  ENDCOND
\end{pvsex}
The coverage TCCs generated for the two inner {\tt COND}s will have the form
\begin{pvsex}
   foo\_TCC2 : OBLIGATION state=a IMPLIES input=x OR input=y
   foo\_TCC3 : OBLIGATION state=b IMPLIES input=x OR input=y
\end{pvsex}
whereas, because of the disjointness and coverage of $\{${\tt a}, {\tt
b}$\}$, the correct TCC is the simpler form
\begin{pvsex}
   foo\_TCC: OBLIGATION input=x OR input=y
\end{pvsex}
The source of the error here is that our translation of the original
table is too simple-minded.  A better translation is the following.
\begin{pvsex}
  LET
    x1 = COND input=x -> a, input=y -> b ENDCOND,
    x2 = COND input=x -> b, input=y -> b ENDCOND
  IN
    COND state=a -> x1, state=b -> x2 ENDCOND
\end{pvsex}
And this generates the correct TCCs.

Note that if the {\tt be\_i}'s are members of an enumerated type, then
the standard PVS {\tt CASES} construct should be used instead of {\tt
COND}, since there is no need to generate TCCs in these cases.  For
example, if in the previous example $\{$ {\tt a}, {\tt b} $\}$ and
$\{$ {\tt x}, {\tt y} $\}$ had been enumerated types, then the table
could have been expressed as
\begin{pvsex}
  CASES state OF
    a: CASES input OF x: a, y: b ENDCASES,
    b: CASES input OF x: b, y: b ENDCASES
  ENDCASES
\end{pvsex}
and no TCCs would be generated.

If the {\tt be\_i}'s are all equalities with the same left hand side,
whose right hand sides are ground arithmetic terms (involving only
numbers, \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}) then the typechecker
directly checks for coverage and disjointness so no \tccs\ are generated
in this case.

\index{cond expressions@\texttt{COND} expressions|)}


\subsection{Table Expressions}

The {\tt COND} and {\tt CASES} constructs (see datatypes on page~\pageref{datatypes}) provide the semantic
foundation for our treatment of tables in PVS; for convenience, we
also provide a {\tt TABLE} construct that provides more attractive
syntax for the important special cases of regular one and
two-dimensional tables.  The example above can be written in the
alternative form.
\begin{pvsex}
   TABLE
%               ---------------------
               |[ input=x | input=y ]|
%     -------------------------------
      | state=a |    a    |    b    ||
%     -------------------------------
      | state=b |    b    |    b    ||
%     -------------------------------
   ENDTABLE
\end{pvsex}
This will translate internally into the {\tt LET} and {\tt COND} form
shown earlier.  Note that the horizontal lines are simply PVS
comments.\footnote{The \LaTeX\ generation translates these constructs into attractively
typeset tables.  See the PVS System Guide~\cite{PVS:userguide} for details.}

The row and column headers to a {\tt TABLE} construct are arbitrary
boolean expressions.   In cases where the expressions are all of the
form {\tt id=x}, the {\tt id} can be factored out to produce simpler
tables of the following form.
\begin{pvsex}
   TABLE state,    input
%               ----------
               |[ x | y ]|
%        -----------------
         |  a   | a | b ||
%        -----------------
         |  b   | b | b ||
%        -----------------
   ENDTABLE
\end{pvsex}
In this form, as the headings are enumeration constructs this is
internally represented as a \texttt{CASES} construct, and so generates
no \tccs\ (the previous version generates 5 \tccs).

One-dimensional tables can be presented in both ``horizontal'' and
``vertical'' forms.  The \emph{sign} function example can be
presented as a ``vertical'' table as follows.
\begin{pvsex}
  sign(x): int = TABLE 
%                ------------
                |[ x<0 | -1 ]|
%                ------------
                 | x=0 |  0 ||
%                ------------
                 | x>0 |  1 ||
%                ------------
   ENDTABLE
\end{pvsex}

And as a horizontal one as follows.
\begin{pvsex}
  sign(x): int = TABLE 
%                --------------------
                 |[ x<0 | x=0 | x>0 ]|
%                -------------------
                 |   -1 |  0  |  1  ||
%                --------------------
   ENDTABLE
\end{pvsex}


A more complex two-dimensional example is provided by the mode
transition tables used in SCR\@.  These have the following form.
\[
\begin{array}{|c|c|c|}
\hline
\mbox{current mode} & \mbox{Event} & \mbox{New Mode} \\
\hline
m_{1} & e_{1,1} & m_{1,1} \\
    & e_{1,2} & m_{1,2} \\
    & \ldots & \ldots\\
    & e_{1,k_1} & m_{1,k_1} \\
\hline
m_{2} & e_{2,1} & m_{2,1} \\
    & e_{2,2} & m_{2,2} \\
    & \ldots & \ldots\\
    & e_{2,k_2} & m_{2,k_2} \\
\hline
\ldots  & \ldots & \ldots\\  
\hline
m_{p} & e_{p,1} & m_{p,1} \\
    & e_{p,2} & m_{p,2} \\
    & \ldots & \ldots\\
    & e_{p,k_p} & m_{p,k_p} \\
\hline
\end{array}
\]
And translate to the following form.
\smaller
\begin{center}
\begin{pvsex}
TABLE mode
%--------------------------------
     |  m\_1 | TABLE event
                  | e\_1,1 | m\_1,1 ||
                  | e\_1,2 | m\_1,2 ||
           \ldots
                  | e\_1,k1| m\_1,k1||
             ENDTABLE ||
%--------------------------------
     |  m\_2 | TABLE event
                  | e\_2,1 | m\_2,1 ||
                  | e\_2,2 | m\_2,2 ||
           \ldots
                  | e\_2,k2| m\_2,k2||
             ENDTABLE ||
%--------------------------------
        \ldots
%--------------------------------
     |  m\_p | TABLE event
                  | e\_p,1 | m\_p,1 ||
                  | e\_p,2 | m\_p,2 ||
           \ldots
                  | e\_p,kp| m\_p,kp||
             ENDTABLE ||
%--------------------------------
ENDTABLE
\end{pvsex}
\end{center}

The last row or column heading in a table may contain the \texttt{ELSE}
keyword, which has the same meaning as for the corresponding \texttt{COND}
or \texttt{CASES} expression.

The table may also have blank entries (except in the headings).  These
represent illegal values; in other words the entry may never be reached.
This is represented by generation of a TCC indicating that the
formulas corresponding to the row and column headings for that entry
cannot both be true.

Note that this is different than having ``don't care'' values.  If you
want to add don't care entries, make sure that you use an array; the table
\begin{pvsex}
DC: int
TABLE
         |[ x < 0 | x = 0 | x > 0 ]|
  | y < 0 |   1   |   0   |   DC  ||
  | y = 0 |  DC   |   2   |    3  ||
  | y > 0 |   -2  |  DC   |    0  ||
  ENDTABLE
\end{pvsex}
may seem like any integer may appear in place of \texttt{DC}, but it must
always be the same integer, which is probably not intended.  The right way
to do this is
\begin{pvsex}
DC(n:nat): int
TABLE
         |[ x < 0 | x = 0 | x > 0 ]|
  | y < 0 |   1   |   0   | DC(2) ||
  | y = 0 | DC(0) |   2   |    3  ||
  | y > 0 |   -2  | DC(1) |    0  ||
  ENDTABLE
\end{pvsex}

\index{tables|)}
