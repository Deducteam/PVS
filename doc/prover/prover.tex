% Document Type: LaTeX
% Master File: prover.tex
\documentclass[12pt,twoside]{book}
\usepackage{relsize,alltt,makeidx,url,boxedminipage,fancyheadings,tabularx}
%\usepackage{../../pvs}
\usepackage{../makebnf}
\usepackage[chapter]{tocbibind}

\usepackage{ifpdf}
\ifpdf
\usepackage[pdftex,dvipsnames,usenames]{color}
\usepackage[bookmarks=true,hyperindex=true,colorlinks=true,linkcolor=Brown,citecolor=blue,backref=page,pagebackref=true,plainpages=false,pdfpagelabels]{hyperref}
\else
\usepackage[bookmarks=true,hyperindex=true]{hyperref}
\fi

\newcommand{\allttinput}[1]{\hozline{\smaller\smaller\smaller\begin{alltt}\input{#1}\end{alltt}}\hozline}
\topmargin -10pt
\textheight 8.5in
\textwidth 6.0in
\headheight 15 pt
\columnwidth \textwidth
\oddsidemargin 0.5in
\evensidemargin 0.5in   % fool system for page 0
\setcounter{topnumber}{9}
\renewcommand{\topfraction}{.99}
\setcounter{bottomnumber}{9}
\renewcommand{\bottomfraction}{.99}
\setcounter{totalnumber}{10}
\renewcommand{\textfraction}{.01}
\renewcommand{\floatpagefraction}{.01}
\raggedbottom

\font\largett=cmtt10 scaled\magstep2
\font\hugett=cmtt10 scaled\magstep4
\def\optl{{\smaller\sc {\smaller\smaller \&}optional}}
\def\rest{{\smaller\sc {\smaller\smaller \&}rest}}
\def\default#1{\textrm{[\texttt{#1}]}}
\def\bkt#1{{$\langle$#1$\rangle$}}
\newcommand{\ii}[1]{{\textit{\hyperpage{#1}}}}
\newcommand{\indextt}[1]{\index{#1@{\texttt{#1}}}} %just the index in tt form
\newcommand{\indtt}[1]{\texttt{#1}\index{#1@{\texttt{#1}}}}  %text+index in tt
\newcommand{\emacstt}[1]{\texttt{M-x~#1}\index{Emacs commands!#1@{\texttt{#1}}}}%index Emacs
\newcommand{\indexlargett}[1]{\index{#1@{\texttt{#1}}|ii}}
\newcommand{\indexlargettdoll}[1]{\index{#1@{\texttt{#1}}|ii}} %removed$
\newcommand{\indlargett}[1]{\texttt{#1}\indexlargett{#1}}%largett+index
\newcommand{\indttdol}[1]{\texttt{#1/\char36}\index{#1@{\texttt{#1}}}} %\index{#1@\texttt{#1\char36}}}
\newcommand{\indttdoll}[1]{\texttt{#1\char36}\index{#1\char36@{\texttt{#1\char36}}}}
\newcommand{\indttbang}[1]{\texttt{#1!}\index{#1"!@{\texttt{#1"!}}}}
\newcommand{\indttdbang}[1]{\texttt{#1!!}\index{#1"!"!@{\texttt{#1"!"!}}}}
\newcommand{\indskobang}{\index{skolem"!@{\texttt{skolem"!}}}}
\newcommand{\indskobangii}{\index{skolem"!@{\texttt{skolem"!}}|ii}}
\newcommand{\skobangdol}{\texttt{skolem!/\char36}\indskobang}
\newcommand{\skobang}{\texttt{skolem!}\indskobang}
\newcommand{\indbang}{\texttt{induct-and-rewrite!}\index{induct-and-rewrite"!@{\texttt{induct-and-rewrite"!}}}}
\newcommand{\thenat}{\texttt{then@}\index{then"@@{\texttt{then@}}}}
\newcommand{\carg}[1]{\textrm{\emph{#1}}\index{#1}}
\newcommand{\cargdflt}[2]{\carg{#1}\default{#2}}
\newenvironment{usage}[1]{\item[usage:\hspace*{-0.175in}]#1\begin{description}\setlength{\itemindent}{-0.2in}\setlength{\itemsep}{0.1in}}{\end{description}}
\newcommand{\prparagraph}[2]{\paragraph{#1}\label{#2}\index{#2}}
\newcommand{\prsubsection}[2]{
\subsection[{\largett #1}:  #2]
              {{\hugett #1}: \raggedright #2}\label{#1}\indexlargett{#1}}
\newcommand{\prdolsubsection}[2]{
\subsection[{\largett #1/\char36}:  #2]
              {{\hugett #1/\char36}: \raggedright #2}\label{#1}\indexlargett{#1}}%\indexlargettdoll{#1}}

\makeindex

\begin{document}
%\pagestyle{empty}

%\renewcommand{\baselinestretch}{2}
\newenvironment{display}{\begin{alltt}\small\tt\vspace{0.3\baselineskip}}{\vspace{0.3\baselineskip}\end{alltt}}
\newcommand{\normtt}[1]{{\obeyspaces \texttt{#1 }}}
\newenvironment{pagegroup}{}{}
%\newenvironment{smalltt}{\begin{alltt}\small\tt}{\end{alltt}}
\newenvironment{tdisplay}{\begin{alltt}\footnotesize\tt\vspace{0.3\baselineskip}}{\vspace{0.3\baselineskip}\end{alltt}}
\input{../pvstex}
%\input{/project/pvs/doc/jmacros}
\newcommand{\Infrule}[3]{
{{\displaystyle\strut #1}\over{\displaystyle\strut #2}}\;\mbox{\scriptsize$\bf #3$}
}
\newcommand{\imp}{\supset}
\newcommand{\pair}[1]{\langle #1 \rangle}
\newcommand{\seq}[2]{#1_{1} \ldots #1_{#2}}  
\newcommand{\implies}{\supset}

\def\id#1{\hbox\texttt{#1}} %changing ids from roman to tt.
%\bibliographystyle{alpha}
%\input{title}
\vspace{4in}

\begin{titlepage}
\vspace*{1in}
\noindent
\rule[1pt]{\textwidth}{2pt}
\begin{center}
\newfont{\pvstitle}{cmss17 scaled \magstep4}
\textbf{\pvstitle PVS Prover Guide}
\end{center}
\begin{flushright}
{\Large Version 3.2 {\smaller$\bullet$} September 2004}
\end{flushright}
\rule[1in]{\textwidth}{2pt}
\vspace*{2in}
\begin{flushleft}
N.~Shankar\\
S.~Owre\\
J.~M.~Rushby\\
D.~W.~J.~Stringer-Calvert\\
{\smaller\url{{Owre,Shankar,Rushby,Dave_SC}@csl.sri.com}}\\
{\smaller\url{http://pvs.csl.sri.com/}}
\end{flushleft}
\vspace*{1in}
\vbox{\hbox to \textwidth{{\Large SRI International\hfill}}%
\hbox to \textwidth{{\small\sf
Computer Science Laboratory $\bullet$ 333 Ravenswood Avenue $\bullet$ Menlo Park CA 94025\hfill}}}
\end{titlepage}

\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{\markboth{\emph{#1}}{}\markright{\emph{#1}}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \em \ #1}}
\lhead[\thepage]{\rightmark}
%\cfoot{\protect\small\bf \fbox{PVS 2.3 DRAFT}}
\cfoot{}
\rhead[\leftmark]{\thepage}
\setcounter{secnumdepth}{1} 
\setcounter{tocdepth}{2}
\pagenumbering{roman}
\thispagestyle{empty}

\newpage

\vspace*{6in}\noindent
The initial development of PVS was funded by SRI International.
Subsequent enhancements were partially funded by SRI and by NASA
Contracts NAS1-18969 and NAS1-20334, NRL Contract N00014-96-C-2106,
NSF Grants CCR-9300044, CCR-9509931, and CCR-9712383, AFOSR contract
F49620-95-C0044, and DARPA Orders E276, A721, D431, D855, and E301.
\newpage\setcounter{page}{1}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{page}{1}

\chapter{Introduction}

PVS stands for ``Prototype Verification System,'' and as the name suggests,
it is a prototype environment for specification and verification.  This document is a
reference manual for the commands employed in constructing proofs using the
PVS proof checker.  The \emph{PVS System Guide}~\cite{PVS:userguide} should
be consulted for information on how to use the system to develop
specifications and proofs.  The \emph{PVS Language
Reference}~\cite{PVS:language} describes the language of PVS\@. 

The primary purpose of PVS is to provide formal support for
conceptualization and debugging in the early stages of the life cycle of
the design of a hardware or software system.  In these stages, both the
requirements and designs are expressed in abstract terms that are not
necessarily executable.  We find that such abstract specifications are
best analyzed by attempting proofs of desirable consequences of the
specification.  Our own experience with PVS in this regard has been that
such attempted proofs of \emph{putative theorems\index{putative theorems}}
very quickly highlight even subtle errors and infelicities.  These would
be costly to detect and correct at later stages of the design life cycle.

The primary emphasis in the PVS proof checker is on supporting the
construction of readable proofs.  The  automation underlying
PVS serves to ensure that the process of verification yields human
insights that can be easily communicated to other humans, and
encapsulated for future verifications.  PVS therefore pays a lot of
attention to simplifying the process of developing, debugging,
maintaining, and presenting proofs.  In order to make proofs easier to
develop, the PVS proof checker provides a collection of powerful proof
commands to carry out propositional, equality, and arithmetic reasoning
with the use of definitions and lemmas.  These proof commands can be
combined to form \emph{proof strategies}.  To make proofs easier to
debug, the PVS proof checker permits proof steps to be undone, and it
also allows the specification to be modified during the course of a
proof.  To support proof maintenance, PVS allows proofs (and partial
proofs) to be edited and rerun.  Currently, the proofs generated by
PVS can be made presentable but they still fall short of being humanly
readable.   The readability of proofs will be one focus of future
enhancements to PVS\@.

PVS is meant to provide effective theorem proving support for a richly
expressive specification language.  The combination of an expressive logic
and a powerful theorem proving capability in PVS hinges on a careful
integration between the typechecker and the proof checker.  The
typechecker exploits the deductive power of the proof checker to
automatically discharge proof obligations generated by the typechecker.
These proof obligations, termed \emph{type correctness conditions} (or
TCCs\index{TCC}), arise for instance, when a term is typechecked against
an expected predicate subtype.  Such proof obligations can also arise as
subgoals during proof checking since the typechecker is frequently invoked
to check user-supplied expressions and quantifier instantiations.

The combination of direct control by the user for the higher levels of
proof development, and powerful automation for the lower levels, is also
somewhat unusual.  On the whole, PVS provides more automation than a
low-level proof checker (such as LCF\index{LCF}~\cite{LCF},
HOL\index{HOL}~\cite{Gordon:HOL88}, Nuprl\index{Nuprl}~\cite{Nuprl-book},
Automath\index{Automath}~\cite{deBruijn80}), and more control than a
highly automatic theorem prover (such as Otter\index{Otter}~\cite{Otter90}
or Nqthm\index{Nqthm}~\cite{Boyer-Moore79,Boyer-Moore88}).  Compared with
thoroughly automated theorem provers such as Nqthm\index{Nqthm}, the
deductive component of PVS may be considered a proof checker---but it
seems like a theorem prover to those accustomed to systems such as
HOL\index{HOL} which provide limited automation.  We reflect this
ambivalence by sometime referring to PVS as a theorem prover, and
sometimes as a proof checker.  The PVS proof checker is somewhat in the
spirit to the IMPLY\index{IMPLY} prover of Bledsoe\index{Bledsoe, Woodrow
W.} and his colleagues~\cite{Bledsoe74}.

While there are clearly many avenues for further improvement of the PVS
system, the combination of a highly expressive specification language and
a powerful interactive proof checking capability already yields a
productive verification environment.  There are a number of examples, both
big and small, that support this
observation---see~\cite{Owre-etal98:FM-TRENDS}.  A list of applications of
PVS and a bibliography of PVS related reports and papers is maintained at
the PVS web site at \url{http://pvs.csl.sri.com/}.



\section{PVS Proof Display and Construction}

We give a brief overview of the sequent-style proof representation used in
PVS since this is needed to understand the effect of the PVS proof
commands.  The PVS proof checker is interactive, but also supports a batch
mode in which proofs can be easily rerun.  The prover maintains a
\emph{proof tree}, and it is the goal of the user to construct a proof
tree which is complete, in the sense that all of the leaves are recognized
as true.  Each node of the proof tree is a \emph{proof goal} that follows
from its offspring nodes by means of a proof step.  Each proof goal is a
\emph{sequent} consisting of a sequence of formulas called
\emph{antecedents} and a sequence of formulas called \emph{consequents}.
Such a sequent is displayed as
\begin{center}
\begin{tabular}{ll}
  \texttt{\{-1\}} & $A_1$\\
  \texttt{\{-2\}} & $A_2$\\
  \texttt{[-3]} & $A_3$\\
 & \vdots\\
 \multicolumn{2}{l}\texttt{|-------}\\
  \texttt{\{1\}} & $B_1$\\
  \texttt{[2]} & $B_2$\\
  \texttt{\{3\}} & $B_3$\\
 & \vdots
\end{tabular}
\end{center}
where the $A_i$ and $B_j$ are PVS formulas collectively referred to
as \emph{sequent formulas}: the $A_i$ are the antecedents and the
$B_j$ are the consequents; the row of dashes serves to separate the
antecedents from the consequents.\footnote{In written text, sequents
may also be written as $A_1, A_2, A_3, \ldots\vdash B_1, B_2, B_3,
\ldots$} The sequence of antecedents or consequents (but not both) may
be empty.  The intuitive interpretation of a sequent is that the
conjunction of the antecedents  implies the disjunction of the
consequents, \ie\ $(A_1\wedge A_2\wedge A_3 \ldots) \supset (B_1 \vee
B_2 \vee B_3 \ldots)$.  The proof tree starts off with a root node of
the form $ \vdash A$, where $A$ is the theorem to be proved.   PVS
proof steps build a proof tree by adding subtrees to leaf nodes
as directed by the proof commands. 
It is easy to see that a sequent is \emph{true} if any antecedent is the same as any consequent, if any
antecedent is \emph{false}, or if any consequent is \emph{true}.
Other sequents can also be recognized as \emph{true}, using more
powerful inferences that will be described later.
Once a sequent is recognized as \emph{true}, that branch of the
proof tree is terminated.   The goal is to build a proof tree whose
branches have all been terminated in this way.

At any time in a PVS proof, attention is focussed on some sequent that is
a leaf node in the current proof tree---this is the sequent that is
displayed by the PVS prover while awaiting the user's command.  The
numbers in brackets, \eg\ \texttt{[-3]}, and braces, \eg\ \texttt{\{3\}},
before each formula in the displayed sequent are used to name the
corresponding formulas.  The formula numbers in square brackets (\eg\
\texttt{[-3]} above) indicate formulas that are unchanged in a subgoal
from the parent goal whereas the numbers in braces (\eg\ \{2\} in the
example above), serve to highlight those formulas that are either new or
modified from those of the parent sequent.

PVS \emph{interactive commands} allow the user to shift the focus (using
the \indtt{postpone} command) to a sibling of the current sequent (if any), or
to abandon (using the \indtt{fail} or \indtt{undo} command) a portion of the proof
containing the current sequent in order to return to some ancestor node
representing an earlier point in the proof.  PVS \emph{proof steps} cause a
subtree of sequents to ``grow'' from the current sequent, and shift the focus
to one of the leaves of the new subtree.  For example, one proof step (called
\indtt{split} in PVS) takes a sequent of the form \[ \Gamma \vdash A \wedge B
\] (where $\Gamma$ is any sequence of formulas) and creates the pair of child
sequents \[ \Gamma \vdash A \ \mbox{\ and\ }\ \Gamma \vdash B\] (\ie\ in order
to prove a conjunction, it is sufficient to prove each of the conjuncts
separately).

A PVS \emph{proof command} when applied to a sequent provides the
means to construct proof trees.  These commands can be used to introduce
lemmas, expand definitions, apply decision procedures, eliminate
quantifiers, and so on; they affect the proof tree, and are saved when
the proof is saved.  Proof commands may be invoked directly by the user,
or as the result of executing a strategy.   We refer to the
action resulting from a proof command as a \emph{proof step} or a \emph{proof
rule} and often use  these terms interchangeably.  

The proof commands that really define the PVS logic are called the
\emph{primitive rules}; they either recognize the current sequent as
true and terminate that branch of the proof tree, or they add one or
more child nodes to the current sequent and transfer the focus to one of
these children.  PVS \emph{strategies} are combinations of
proof-steps that can, in principle, add a subtree of any depth to the
current node (\ie\ the step may invoke substeps and so on).  On the
other hand, those proof steps called \emph{defined rules} (which can be
the result of invoking strategies with the \indtt{apply} control strategy)
silently prune those branches of the subtrees which they generate that
are recognized as true, and collapse all remaining interior nodes, so
that the subtree actually generated has depth zero (\ie\ the sequent is
recognized as true and this branch of the proof terminates) or one (\ie\
it simply adds children to the current node).

As mentioned earlier, some of the individual proof steps in the PVS prover
are extremely sophisticated and make heavy use of arithmetic and equality
decision procedures.  Various properties of function, record, tuple, and
cotuple types, and abstract datatypes, are also built into the operation
of the PVS prover.  The interplay between type information (from the
specification) and inference is also mechanized in a significant way by
PVS.\@ For example, if the function definition \[\textit{factorial}(n)
{\bf :\ recursive\ } \textit{nat} = \rmif n=0 \rmthen 1 \rmelse n\times
\textit{factorial}(n-1) \rmendif\] is used to expand the term
$\textit{factorial}(i+1)$, where $i$ is of type \emph{nat}, the PVS prover
will retrieve the type predicate for \emph{nat}, namely \[(\lambda n: n
\geq 0),\] instantiate it with $i$ and call the arithmetic decision
procedures to deduce that $i+1 \neq 0$, and thereby select just the
relevant branch of the definition to produce the result \[ (i+1)\times
\textit{factorial}(i+1-1). \]

Though there are only a few proof commands in PVS, many of these commands
are quite powerful and flexible.  It is wise to experiment with the
commands in order to more thoroughly understand how they work, and to
employ the more powerful commands whenever possible.  As with any
automated reasoning system, the form of the specification can
significantly affect the ease or difficulty of the accompanying proofs.
The specifier must demonstrate good taste in writing abstract
specifications, using definitions to name useful concepts, employing
types, subtypes, and abstract datatypes appropriately, and in stating
lemmas in their most useful forms.  In a system like PVS, it is quite easy
to carry out a less than elegant proof; the user must exercise enough
discipline to structure proofs so that they are less cluttered, easy to
read, and can be robustly rerun in the face of minor changes.  It is also
important to introduce useful lemmas as they arise in the proof, and
define strategies to encapsulate patterns of proof steps.

The remainder of this chapter summarizes how interactive PVS proof
attempts are initiated and terminated.  Chapter~\ref{example} contains a
small example proof to illustrate how the PVS proof checker is used.
Chapter~\ref{logic} gives a brief overview of the logical underpinnings of
PVS\@.  Chapter~\ref{commands} describes the syntax of the proof commands.
Chapter~\ref{strategy} is a guide to the PVS proof strategy language and
also gives examples of proof strategies and derived inference rules.

\section{Interaction Basics}\index{Interaction basics}\label{interaction}

The following paragraphs summarize how proof attempts are initiated,
abandoned, or interrupted, and how help information can be obtained.
Full details are presented in the PVS user guide~\cite{PVS:userguide}.

\prparagraph{Initiating a Proof Attempt}{Initiating Proofs}

A proof session is initiated from within an Emacs buffer containing a PVS
specification by using the Emacs command \emacstt{pr} with the cursor at
the formula that is to be proved.  If the formula has already been proved,
the user is asked whether the proof attempt should proceed.  If a proof or
partial proof for the relevant formula already exists, then the user is
asked if this proof should be rerun.  The Emacs command \emacstt{xpr} can
be used to initiate a proof that generates a Tcl/Tk display of the proof
structure as it is being developed.  To interactively rerun a proof, use
\emacstt{step-proof} (\emacstt{x-step-proof} to also generate a display).

\prparagraph{Exiting a Proof Attempt}{Exiting Proofs}

In the proof sessions shown below, all user input is displayed in
boldface.  The proof commands follow the \texttt{Rule?}\ prompt and the
remaining text is generated by PVS\@.  A proof attempt can be abandoned by
typing \texttt{q} or \indtt{quit} at the prompt.  At the end of a
successful or abandoned proof attempt, the user is queried as to whether
the resulting partial proof should be saved.  The timing characteristics
are displayed at the end.  The saved partial proof can be rerun in a
subsequent attempt so that the unfinished parts of the proof can be
completed.  Multiple proofs may be saved for a given formula, allowing new
proof approaches to be tried without losing earlier attempts.

\prparagraph{Getting Help}{Getting Help}

There are several ways of getting helpful information about the
proof checking commands.  The easiest way is to invoke
\emacstt{help-pvs-prover} or \emacstt{x-prover-commands}.  See
page~\pageref{help} for the interactive \indtt{help} rule.

\prparagraph{Interrupting Proofs}{Interrupting Proofs}

The proof checker can be interrupted when it is working on a command by
typing \indtt{C-c C-c}.  This places the system at a Lisp break, where it
is possible to interact with the underlying Lisp system.  Typing
\texttt{(restore)} at the break returns the system to the \texttt{Rule?}\
prompt corresponding to the last interaction.



\chapter{An Example Proof}\index{Proof example}
\label{example}

We consider a simple proof using induction to show that
when given two functions \texttt{f} and \texttt{g} on the natural numbers,
the sum of the first \texttt{n} values of \texttt{f} and \texttt{g}
is the same as the sum of the first \texttt{n} values of
the function \texttt{(LAMBDA n:~f(n) + g(n))}.
The theory \texttt{sum} below defines the summation operator \texttt{sum}
and states the desired theorem as \texttt{sum\_plus}.

\pvstheory{summation3}{\texttt{sum}}{sum}

In the first proof attempt described below,  \texttt{sum\_plus} is proved
using simple, low-level inference steps, and in the second proof attempt, the
same theorem is proved by invoking a single high-level proof strategy.

Once the proof is initiated\footnote{By placing the cursor on the formula
and typing \emacstt{prove}.  See the previous chapter or the System
Guide~\cite{PVS:userguide} for details on other ways to initiate proof
attempts.}, the main goal is displayed in the \texttt{*pvs*} buffer
followed by a \texttt{Rule?}\ prompt.  The user commands are typed in at
this prompt.  Note that the free \texttt{n} in the original formula has
been renamed to \texttt{n1}.  This is done both to make the formula less
confusing to read, and to ensure that variables are not inadvertently
captured.\footnote{PVS keeps internal pointers from variable references to
the bound variables, but if an expression is cut from the sequent and
pasted into a command argument, this information is lost and the results
can be confusing.}  The first command, \skobang{}, introduces Skolem
constants \texttt{f!1}, \texttt{g!1}, and \texttt{n1!1} for the
universally quantified variables in the theorem.  The second command,
\indtt{lemma}, introduces the induction scheme for natural numbers
\texttt{nat\_induction}\index{nat\_induction@{\texttt{nat\_induction}}} as
an antecedent formula.  This induction scheme is proved as a lemma in the
theory \indtt{naturalnumbers} in the PVS prelude.\footnote{The lemma name
can also be given in its full form \texttt{naturalnumbers.nat\_induction}
if the theory name is needed for disambiguation.  See the PVS language
manual~\cite{PVS:language} for more details of how name resolution is
performed.}

\clearpage
\noindent
\begin{smallsession}\indskobang\indextt{lemma}
sum_plus :  

  |-------
\{1\}   FORALL (f, g: [nat -> nat], n1: nat):
        sum(LAMBDA n: f(n) + g(n), n1) = sum(f, n1) + sum(g, n1)

Rule? (skolem!)
Skolemizing,
this simplifies to: 
sum_plus :  

  |-------
\{1\}   sum(LAMBDA n: f!1(n) + g!1(n), n1!1) =
       sum(f!1, n1!1) + sum(g!1, n1!1)

Rule? (lemma "nat_induction")
Applying nat_induction where 
this simplifies to: 
sum_plus :  

\{-1\}   FORALL (p: pred[nat]):
        (p(0) AND (FORALL j: p(j) IMPLIES p(j + 1))) IMPLIES
         (FORALL i: p(i))
  |-------
[1]   sum(LAMBDA n: f!1(n) + g!1(n), n1!1) =
       sum(f!1, n1!1) + sum(g!1, n1!1)
\end{smallsession}

The next step is to instantiate the induction scheme with a suitable
induction predicate.  This instantiation is supplied manually using
the \indtt{inst} command.   
\begin{smallsession}\indextt{inst}
Rule? (inst - "(LAMBDA n: sum((LAMBDA (n: nat): f!1(n) + g!1(n)), n)
          = sum(f!1, n) + sum(g!1, n))")
Instantiating the top quantifier in - with the terms: 
 (LAMBDA n: sum((LAMBDA (n: nat): f!1(n) + g!1(n)), n)
          = sum(f!1, n) + sum(g!1, n)),
this simplifies to:
\end{smallsession}
The effect of \indtt{inst} command is to generate a subgoal
where the universally quantified variable \texttt{p} has been
replaced by the given induction predicate.  After substitution the result
was beta reduced.
\begin{smallsession}
sum_plus :  

\{-1\}   (sum((LAMBDA (n: nat): f!1(n) + g!1(n)), 0) =
        sum(f!1, 0) + sum(g!1, 0)
        AND
        (FORALL j:
           sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j) =
            sum(f!1, j) + sum(g!1, j)
            IMPLIES
            sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j + 1) =
             sum(f!1, j + 1) + sum(g!1, j + 1)))
       IMPLIES
       (FORALL i:
          sum((LAMBDA (n: nat): f!1(n) + g!1(n)), i) =
           sum(f!1, i) + sum(g!1, i))
  |-------
[1]   sum(LAMBDA n: f!1(n) + g!1(n), n1!1) =
       sum(f!1, n1!1) + sum(g!1, n1!1)
\end{smallsession}

Applying the conjunctive splitting command \indtt{split} to the goal
yields three subgoals.  The first goal is to demonstrate that the
conclusion of the instantiated induction scheme implies the original
conjecture following the introduction of Skolem constants.  The second
subgoal is the base case, and the third subgoal is the induction step.
The first subgoal is easily proved by using the heuristic instantiation
command \indtt{inst?}.
\begin{smallsession}\indextt{split}
Rule? (split)
Splitting conjunctions,
this yields  3 subgoals: 
sum_plus.1 :  

\{-1\}   FORALL i:
        sum((LAMBDA (n: nat): f!1(n) + g!1(n)), i) =
         sum(f!1, i) + sum(g!1, i)
  |-------
[1]   sum(LAMBDA n: f!1(n) + g!1(n), n1!1) =
       sum(f!1, n1!1) + sum(g!1, n1!1)

Rule? (inst?)
Found substitution:
i gets n1!1,
Using template: sum((LAMBDA (n: nat): f!1(n) + g!1(n)), i) =
                 sum(f!1, i) + sum(g!1, i)
Instantiating quantified variables,

This completes the proof of sum_plus.1.
\end{smallsession}

The second subgoal, the base case, contains an irrelevant formula numbered
\texttt{2} which was only needed for the first subgoal proved
above.  This formula can be suppressed with the \indtt{hide} command.
The hidden formulas can be examined using the Emacs command
\emacstt{show-hidden-formulas}, and revealed or reintroduced into the
sequent using the \indtt{reveal} command. 
\begin{smallsession}\indextt{hide}
sum_plus.2 :  

  |-------
\{1\}   sum((LAMBDA (n: nat): f!1(n) + g!1(n)), 0) =
       sum(f!1, 0) + sum(g!1, 0)
[2]   sum(LAMBDA n: f!1(n) + g!1(n), n1!1) =
       sum(f!1, n1!1) + sum(g!1, n1!1)

Rule? (hide 2)
Hiding formulas:  2,
this simplifies to: 
sum_plus.2 :  

  |-------
[1]   sum((LAMBDA (n: nat): f!1(n) + g!1(n)), 0) =
       sum(f!1, 0) + sum(g!1, 0)
\end{smallsession}
 We are then left with the formula numbered \texttt{1} which is easily
proved by expanding the definition of \texttt{sum} using the
\indtt{expand} command.  Notice that this command uses the PVS decision
procedures to simplify the definition of \texttt{sum} and to reduce the
equality to \texttt{TRUE}\@.
\begin{smallsession}\indextt{expand}
Rule? (expand "sum")
Expanding the definition of sum,
this simplifies to: 
sum_plus.2 :  

  |-------
\{1\}   TRUE

which is trivially true.

\end{smallsession}

The remaining subgoal is the induction step.  It too contains the
irrelevant formula numbered \texttt{2} that is again suppressed using the
\indtt{hide} command.  
\begin{smallsession}\indextt{hide}
sum_plus.3 :  

  |-------
\{1\}   FORALL j:
        sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j) =
         sum(f!1, j) + sum(g!1, j)
         IMPLIES
         sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j + 1) =
          sum(f!1, j + 1) + sum(g!1, j + 1)
[2]   sum(LAMBDA n: f!1(n) + g!1(n), n1!1) =
       sum(f!1, n1!1) + sum(g!1, n1!1)

Rule? (hide 2)
Hiding formulas:  2,
this simplifies to: 
sum_plus.3 :  

  |-------
[1]   FORALL j:
        sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j) =
         sum(f!1, j) + sum(g!1, j)
         IMPLIES
         sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j + 1) =
          sum(f!1, j + 1) + sum(g!1, j + 1)
\end{smallsession}
Applying the \indtt{skosimp} command, which is
a compound of the \skobang{} and \indtt{flatten} commands,
the resulting simplified sequent contains an antecedent formula,
the induction hypothesis, and a consequent formula, the induction
conclusion.
\begin{smallsession}\indextt{skosimp}
Rule? (skosimp)
Skolemizing and flattening,
this simplifies to: 
sum_plus.3 :  

\{-1\}   sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j!1) =
       sum(f!1, j!1) + sum(g!1, j!1)
  |-------
\{1\}   sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j!1 + 1) =
       sum(f!1, j!1 + 1) + sum(g!1, j!1 + 1)
\end{smallsession}
If we apply the \indtt{expand} command selectively to expand those
occurrences of \texttt{sum} on the consequent side, we get a sequent that
is tautologously true.  Notice, once again, that the expand command makes
significant use of type information within the PVS decision procedures in
order to simplify not only the expanded definition of \texttt{sum} but
also the resulting equality between arithmetic expressions.
\begin{smallsession}\indextt{expand}
Rule? (expand "sum" +)
Expanding the definition of sum,
this simplifies to: 
sum_plus.3 :  

[-1]   sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j!1) =
       sum(f!1, j!1) + sum(g!1, j!1)
  |-------
\{1\}   sum((LAMBDA (n: nat): f!1(n) + g!1(n)), j!1) =
       sum(f!1, j!1) + sum(g!1, j!1)

which is trivially true.

This completes the proof of sum_plus.3.

Q.E.D.


Run time  = 0.79 secs.
Real time = 38.10 secs.
\end{smallsession}

This successfully completes the proof attempt.  The CPU time
and wall clock time for the proof attempt are displayed above.

\section{The Example Proof Redone}

PVS has a language in which proof strategies can be written.  The essence
of the above proof can actually be captured as a strategy.  The strategy
\indbang{} invokes induction according to the scheme appropriate to the
given induction variable and then completes the proof by expanding the
functions used in the theorem and applying heuristic instantiation and the
decision procedures.
\begin{smallsession}
sum_plus :  

  |-------
\{1\}   FORALL (f, g: [nat -> nat], n1: nat):
        sum(LAMBDA n: f(n) + g(n), n1) = sum(f, n1) + sum(g, n1)

Rule? (induct-and-rewrite! "n1")
sum rewrites sum(LAMBDA n: f!1(n) + g!1(n), 0)
  to 0
sum rewrites sum(f!1, 0)
  to 0
sum rewrites sum(g!1, 0)
  to 0
sum rewrites sum(LAMBDA n: f!1(n) + g!1(n), 1 + j!1)
  to f!1(j!1) + g!1(j!1) + sum(LAMBDA n: f!1(n) + g!1(n), j!1)
sum rewrites sum(f!1, 1 + j!1)
  to f!1(j!1) + sum(f!1, j!1)
sum rewrites sum(g!1, 1 + j!1)
  to g!1(j!1) + sum(g!1, j!1)
By induction on n1 and rewriting,
Q.E.D.


Run time  = 0.85 secs.
Real time = 6.47 secs.
\end{smallsession}

Such high-level strategies might not always succeed.  When a strategy
fails to complete a proof, it is possible to continue proving the
resulting subgoals interactively using further proof commands, or to
backtrack (using \indtt{undo}) in order to try alternative proof commands.
When a strategy is invoked with a \texttt{\char36} suffix, e.g.,
\texttt{induct-and-rewrite!\char36}\index{induct-and-rewrite"!@\texttt{induct-and-rewrite"!\char36}},
the strategy is executed so that the expanded internal steps are visible.
This mode of strategy invocation provides more information and is useful
when debugging.

The Emacs command \emacstt{show-last-proof} can be used to get a summary
of the most recently completed proof.  Note that the Emacs commands
\emacstt{add-declaration} and \emacstt{modify-declaration} can be used to
alter the specification even while a proof is progress.  Since these
commands can affect the validity of a proof, proofs should always be rerun
after completion in order to confirm their validity.  During the course of
a proof, the Emacs command \emacstt{ancestry} displays the sequence of
goals leading back to the root goal of the proof, \emacstt{siblings}
displays the sibling subgoals of the current goal,
\emacstt{show-hidden-formulas} displays the hidden formulas of the current
sequent, and \emacstt{show-auto-rewrites} displays those rewrite rules
that are automatically applied.

\chapter{The Logic of PVS} \index{Logic (of PVS)}
\label{logic}


While using the PVS proof checker, it is useful to be aware of the
rules underlying the PVS logic.  The proof rules presented here
form the theoretical basis for PVS but are not the ones that
are directly implemented in the system.   There is, of course,
a great deal more to building an effective proof checker than merely
codifying the proof rules.

The following sections present the notation used throughout this
document, then the logical rules.  Note that to be complete we should
include the type rules; these are included in the Semantics
Report~\cite{PVS:semantics}.

\section{Notation}

PVS employs a sequent calculus.  We have already introduced the
notions of \emph{sequent}, \emph{antecedent}, and \emph{consequent}.
In the following, we will use the Greek letters $\Gamma$ and $\Delta$ to
represent (finite) sequences of formulas, and latin letters $A$, $B$, and
$C$ to represent individual formulas.  As usual, these can have indices.
\emph{Inference rules} are of the form
$$\Infrule{\Gamma_1\vdash\Delta_1\quad\cdots\quad\Gamma_n\vdash\Delta_n}
{\Gamma\vdash\Delta}{R}.$$ This says that if we are given a leaf of a
proof tree of the form $\Gamma\vdash\Delta$, then by applying the rule
named {\bf R}, we may obtain a tree with $n$ new leaves.

In the following, we will be using the usual logical notation for the
connectives, quantifiers, etc.  The following table relates them to
those used in PVS.\@

\begin{center}
\begin{tabular}{|c|c|}\hline
$\neg$ & \texttt{NOT}\\\hline
$\wedge$ & \texttt{AND}, \texttt{\&}\\\hline
$\vee$ & \texttt{OR}\\\hline
$\supset$ & \texttt{IMPLIES}, \texttt{=>}\\\hline
$\iff$ & \texttt{IFF}, \texttt{<=>}\\\hline
$\forall$ & \texttt{FORALL}\\\hline
$\exists$ & \texttt{EXISTS}\\\hline
$\lambda$ & \texttt{LAMBDA}\\\hline
\end{tabular}
\end{center}
Note that an expression of the form $A$ \texttt{WHEN} $B$ is equivalent to
$B\supset A$, and hence such expressions will not be explicitly
mentioned in the rules.  A PVS \texttt{IF} expression of the form
\begin{alltt}
  IF \(A\) THEN \(B\) ELSIF \(C\) THEN \(D\) ELSE \(E\) ENDIF
\end{alltt}
will be abbreviated  below as $\texttt{IF}(A,B,\texttt{IF}(C,D,E))$

\section{The Structural Rules}

The structural rules permit the sequent to be rearranged or weakened
via the introduction of new sequent formulas into the conclusion.  
All of the structural rules can be expressed in terms of the single
powerful weakening rule  shown below.
It allows a weaker statement to
be derived from a stronger one by adding either antecedent formulas or
consequent formulas.  The relation $\Gamma_1\subseteq\Gamma_2$ holds
between two lists when all the formulas in $\Gamma_1$ occur in the list
$\Gamma_2$.

\begin{center}
$\Infrule{\Gamma_1\vdash\Delta_1}
         {\Gamma_2\vdash\Delta_2} {W}$
\hspace{1cm}\mbox{\smaller\smaller if $\Gamma_1\subseteq\Gamma_2$ and $\Delta_1\subseteq\Delta_2$}
\end{center}

Both the Contraction and Exchange rules shown below are absorbed by the
above \emph{Weakening} rule.     The \emph{Contraction} rule
allows multiple occurrences of the same sequent formula
to be replaced by a single occurrence. 

\begin{center}
\begin{tabular}{ccc}
$\Infrule{A,A, \Gamma\vdash\Delta}
         {A, \Gamma\vdash\Delta} {C\vdash}$
& \hspace{0.5in} &
$\Infrule{\Gamma\vdash A, A, \Delta}
         {\Gamma\vdash A, \Delta} {\vdash C}$
\end{tabular}
\end{center}

The \emph{Exchange} rule asserts that the order of the formulas in the
antecedent and the consequent parts of the sequent is immaterial.  It can
be stated as

\begin{center}
\begin{tabular}{c@{\hspace{0.5in}}c}
$\Infrule{\Gamma_1, B, A,  \Gamma_2\vdash\Delta}
         {\Gamma_1, A, B, \Gamma_2\vdash\Delta} {X\vdash}$
&
$\Infrule{\Gamma\vdash\Delta_1, B, A, \Delta_2}
         {\Gamma\vdash\Delta_1, A, B, \Delta_2} {\vdash X}$
\end{tabular}
\end{center}


\section{The Propositional Rules}

The rules about conjunction, disjunction, implication, and negation are
quite straightforward.  The propositional axiom rule requires the notion
of two formulas $A$ and $B$ being syntactically equivalent modulo the
renaming of bound variables.  Thus, the syntactic equivalence: $(\forall x, y:
(\lambda z: f(y, z))(x) < y) \equiv (\forall z, x: (\lambda y: f(x,
y))(z) < x)$, holds.  The Propositional Axiom rule is then given as:

\begin{center}
$\Infrule{}{\Gamma, A\,\vdash\,B,\Delta}{Ax}$
\hspace{0.5in}\mbox{\smaller\smaller where $A\equiv B$}
\end{center}

The Cut rule can be seen as a mechanism for introducing a case-split
into a proof of a sequent $\Gamma\vdash\Delta$ to yield the subgoals
$\Gamma, A\vdash\Delta$ and $\Gamma\vdash A, \Delta$, which can be seen
as assuming $A$ along one branch and $\neg A$ along the other.

\begin{center}
$\Infrule{\Gamma,A \vdash\Delta\qquad\Gamma\vdash A, \Delta}
         {\Gamma\vdash\Delta}{Cut}$
\end{center}

There are two rules for each of the propositional connectives of
conjunction ($\wedge$), disjunction ($\vee$), implication ($\imp$), and
negation ($\neg$), corresponding to the antecedent and consequent
occurrences of these connectives.

\begin{center}
\begin{tabular}{c@{\hspace{0.5in}}c}
$\Infrule{A, B, \Gamma\vdash \Delta}
         {A\wedge B, \Gamma\vdash\Delta}{\wedge\vdash}$
&
$\Infrule{\Gamma\vdash A, \Delta\hspace{1cm}\Gamma\vdash B, \Delta}
         {\Gamma\vdash A\wedge B, \Delta} {\vdash\wedge}$
\\[0.3in]
$\Infrule{A, \Gamma\vdash \Delta\hspace{1cm}B, \Gamma\vdash \Delta}
         {A\vee B, \Gamma\vdash \Delta} {\vee\vdash}$
&
$\Infrule{\Gamma\vdash A, B, \Delta}
         {\Gamma\vdash A\vee B, \Delta} {\vdash\vee}$
\\[0.3in]
$\Infrule{B, \Gamma\vdash \Delta\hspace{1cm} \Gamma\vdash A,\Delta}
         {A\imp B, \Gamma\vdash \Delta} {\imp\,\vdash}$
&
$\Infrule{\Gamma, A \vdash B, \Delta}
         {\Gamma\vdash A\imp B, \Delta} {\vdash\,\imp}$
\\[0.3in]
$\Infrule{\Gamma\vdash A, \Delta}
         {\Gamma,\neg A \vdash \Delta} {\neg\vdash}$
&
$\Infrule{\Gamma, A \vdash \Delta}
         {\Gamma\vdash \neg A, \Delta} {\vdash\neg}$
\\
\end{tabular}
\end{center}

\section{The Equality Rules}
The rules for equality can be stated as below.  The rules of
transitivity and symmetry for equality can be derived from these rules.
The notation $A[e]$ is used
to highlight one or more 
occurrences of $e$ in the formula $A$.  The notation $\Delta[e]$ similarly highlights occurrences
of $e$ in $\Delta$. 

\begin{center}
\begin{tabular}{c@{\hspace{0.5in}}c}
$\Infrule{}{\Gamma\vdash a=b,
\Delta}{Refl}$\hspace{.3cm}\mbox{\smaller\smaller if $a \equiv b$}
&
$\Infrule{a=b, \Gamma[b]\vdash\Delta[b]}
         {a=b, \Gamma[a]\vdash\Delta[a]} {Repl}$
\end{tabular}
\end{center}


\section{The Quantifier Rules}
The quantifier rules are stated below.
The notation $A\{x \gets t\}$ represents the result of substituting the
term $t$ for all the free occurrences of $x$ in $A$ with the possible
renaming of bound variables in $A$ to avoid capturing any free variables
in $t$.  
In the ${\bf \vdash\forall}$ and
${\bf \exists\vdash}$ rules, $a$ must be a new constant that does not
occur in the conclusion sequent.  

\begin{center}
\begin{tabular}{c@{\hspace{0.5in}}c}
$\Infrule{\Gamma, A\{x\gets t\}\vdash \Delta}
         {\Gamma, (\forall x: A)\vdash\Delta} {\forall\vdash}$
&
$\Infrule{\Gamma\vdash A\{x\gets a\}, \Delta}
         {\Gamma\vdash (\forall x: A),\Delta} {\vdash\forall}$
%\hspace{.5cm}\mbox{\smaller\smaller where $a$ is a new constant}
\\[0.3in]
$\Infrule{\Gamma, A\{x\gets a\}\vdash \Delta}
         {\Gamma, (\exists x: A)\vdash\Delta} {\exists\vdash}$
%\hspace{.5cm}\mbox{\smaller\smaller where $a$ is a new constant}
&
$\Infrule{\Gamma \vdash A\{x\gets t\}, \Delta}
         {\Gamma\vdash (\exists x: A),\Delta} {\vdash\exists}$
\end{tabular}
\end{center}

\section{Rules for \indtt{IF}}

It is extremely useful to have the branching operation \indtt{IF} in the
language for expressing conditional expressions.  For each type
$\alpha$, there is an \indtt{IF} operation with the signature $[\texttt{bool}, \alpha, \alpha \rightarrow \alpha]$.    The
transformation of $A[e]$ to $A[b]$ represents the replacement of the
highlighted occurrences of $e$ in $A$ by $b$.  
Note that for the ${\indtt{IF}\uparrow\:\vdash}$ and
${\vdash\:\texttt{IF}\uparrow}$ rules, the  $A$ in
$B[\texttt{IF}(A, b, c)]$ must not contain any free variable occurrences
that are bound in $B[\texttt{IF}(A, b, c)]$.  
The inference rules for
\indtt{IF} are:

\begin{center}
\begin{tabular}{c@{\hspace{0.5in}}c}
$\Infrule{\Gamma, \texttt{IF}(A, B[b], B[c])\vdash \Delta}
         {\Gamma, B[\texttt{IF}(A, b, c)]\vdash\Delta}
                  % The empty \tt seems to be needed; o.w. the following
                  % \texttt{IF} is the wrong size
                  {\texttt{IF}\uparrow\:\vdash}$
&
$\Infrule{\Gamma\vdash \texttt{IF}(A, B[b], B[c]), \Delta}
         {\Gamma\vdash B[\texttt{IF}(A, b, c)], \Delta}
                  {\vdash \texttt{IF} \uparrow}$
\\[0.3in]
$\Infrule{\Gamma, A, B\vdash\Delta\hspace{1cm}\Gamma, \neg A, C\vdash\Delta}
         {\Gamma, \texttt{IF}(A, B, C)\vdash \Delta}
                  {\texttt{IF} \vdash}$
&
$\Infrule{\Gamma, A\vdash B,\Delta\hspace{1cm}\Gamma, \neg A \vdash C, \Delta}
         {\Gamma\vdash \texttt{IF}(A, B, C), \Delta}
                      {\vdash \texttt{IF}}$
\end{tabular}
\end{center}

The PVS proof checker is founded on the sequent calculus rules described
above, but the actual proof construction steps provided by PVS are very
different.  We will point out those commands which relate to the rules
given above in the {\bf notes} section of the command description.


\chapter{The PVS Proof Commands}\index{Proof commands}
\label{commands}

The sequent calculus inference rules displayed in Chapter~\ref{logic} form
the basis for the proof commands used to construct proofs with PVS\@.  The
PVS proof commands are however significantly more powerful than these
simple inference rules so as to make the proof construction process more
illuminating and less tedious.  Proof commands can be typed in by the user
at the \texttt{Rule?}\ prompt or they can be automatically applied by PVS
as part of a proof strategy.  A PVS proof command when applied to a goal
sequent either
\begin{enumerate}
  \item Succeeds in proving the goal sequent
  \item Generates one or more subgoal sequents
  \item Does nothing, which provides crucial control information to
the strategy mechanism
  \item Signals a failure that is propagated up the proof tree in order
to control proof search
  \item Postpones proof construction on the current goal sequent,
transferring focus to the next remaining subgoal.
\end{enumerate}

For example, in the list of commands below, a command like
\indtt{bddsimp}  succeeds in proving goal sequents that are
just propositionally true, whereas the \indtt{case} command typically
generates two or more subgoals.  The  \indtt{skip} command does nothing, but
many other commands can also have no effect on the state of the proof
particularly when the arguments to the command cause the parser or
typechecker to signal errors.   The \indtt{fail} command is the only
command that signals failure.  Failure is used either to backtrack or
to abandon a proof.  The \indtt{postpone} command is the only
command that causes the current subgoal to be postponed. 

The commands implemented by the PVS proof checker can be classified as:
\begin{enumerate}\raggedright
  \item Help: \indtt{help}.

  \item Annotation: \indtt{comment}, \indtt{label}, \indtt{unlabel}, and
  \indtt{with-labels}.

  \item Control: \indtt{fail}, \indtt{postpone}, \indtt{quit},
  \indtt{rewrite-msg-off}, \indtt{rewrite-msg-on},
  \indtt{set-print-depth}, \indtt{set-print-length},
  \indtt{set-print-lines}, \indtt{skip}, \indtt{skip-msg}, \indtt{trace},
  \indtt{track-rewrite}, \indtt{undo}, \indtt{untrace}, and
  \indtt{untrack-rewrite}.

  \item Structural rules: \indtt{copy}, \indtt{delete}, \indtt{hide},
  \indtt{hide-all-but}, and \indtt{reveal}.

  \item Propositional rules: \indtt{bddsimp}, \indtt{case}, \indtt{case*},
  \indtt{flatten}, \indtt{flatten-disjunct}, \indtt{iff}, \indtt{lift-if},
  \indtt{prop}, \indtt{propax}, \indtt{split}, and \indtt{merge-fnums}.

  \item Quantifier rules:
    \begin{enumerate}

    \item Existential: \indtt{inst}, \indtt{inst-cp}, \indtt{inst?},
    \indtt{instantiate}, and \indtt{instantiate-one}.

    \item Universal: \indtt{detuple-boundvars}, \indtt{generalize},
    \indtt{generalize-skolem-constants}, \indtt{skolem}, \skobang{},
    \indtt{skolem-typepred}, \indtt{skosimp}, and \indtt{skosimp*}.

    \end{enumerate}

  \item Equality rules: \indtt{beta}, \indtt{case-replace}, \indtt{name},
  \indtt{name-case-replace}, \indtt{name-replace}, \indtt{name-replace*},
  \indtt{replace}, \indtt{replace*}, and \indtt{same-name}.

  \item Rules for using definitions and lemmas:

\begin{enumerate}
\item Definition expansion: \indtt{expand}, and \indtt{expand*}.

\item Using lemmas: \indtt{forward-chain}, \indtt{forward-chain*},
\indtt{forward-chain@}, \indtt{forward-chain-theory}, \indtt{lemma},
\indtt{use} and \indtt{use*}.

\item Rewriting with definitions/lemmas: \indtt{rewrite},
\indtt{rewrite-lemma}, and \indtt{rewrite-with-fnum}.
\end{enumerate}

  \item Extensionality~rules: \indtt{apply-eta},
\indtt{apply-extensionality}, \indtt{decompose-equality}, \indtt{eta},
\indtt{extensionality}, \indtt{replace-eta}, and
\indtt{replace-extensionality}.

  \item Induction rules: \indtt{induct}, \texttt{induct-and-rewrite},
\indbang{}, \indtt{induct-and-simplify}, \indtt{measure-induct},
\indtt{measure-induct+}, \indtt{measure-induct-and-simplify},
\indtt{name-induct-and-rewrite}, \indtt{rule-induct},
\indtt{rule-induct-step}, \indtt{simple-induct}, and
\indtt{simple-measure-induct}.

    
  \item Rules for simplification using decision procedures and rewriting:
\indtt{assert}, \indtt{bash}, \indtt{both-sides}, \indtt{decide},
\indtt{do-rewrite}, \indtt{grind}, \indtt{grind-with-ext},
\indtt{grind-with-lemmas}, \indtt{ground}, \indtt{lazy-grind}, \indtt{record},
\indtt{reduce}, \indtt{reduce-with-ext}, \indtt{simplify},
\indtt{simplify-with-rewrites}, and \indtt{smash}.

  \item Installation and Removal of rewrite rules: \indtt{auto-rewrite},
\indttbang{auto-rewrite}, \indttdbang{auto-rewrite},
\indtt{auto-rewrite-defs}, \indtt{auto-rewrite-explicit},
\indtt{auto-rewrite-theories}, \indtt{auto-rewrite-theory},
\indtt{auto-rewrite-theory-with-importings}, \indtt{install-rewrites},
\indtt{stop-rewrite}, and \indtt{stop-rewrite-theory}.

  \item Making type constraints explicit: \indtt{all-typepreds},
\indtt{typepred}, and \indttbang{typepred}.

  \item Abstraction and Model Checking: \indtt{abstract},
  \indtt{abstract-and-mc}, \indtt{abs-simp},
   \indtt{model-check}, and \indtt{musimp}.

  \item Converting a strategy to a rule: \indtt{apply}.

  \item Default strategy: \indtt{default-strategy}.

  \item Strategies: \indtt{branch}, \indtt{checkpoint}, \indtt{else},
  \indtt{if}, \indtt{just-install-proof}, \indtt{let}, \indtt{query*},
  \indtt{quote}, \indtt{repeat}, \indtt{repeat*}, \indtt{rerun},
  \indtt{spread}, \indttbang{spread}, \indtt{spread@}, \indtt{then},
  \indtt{then@}, \indtt{time}, \indtt{try}, and
  \indtt{try-branch}


\end{enumerate}

\section{Formal and Actual Parameters of Rules}
Each of the proof commands takes a list of zero or more required and
optional parameters.  Each optional parameter has an associated default
value.  If the  \cargdflt{}{[default]} part of an optional parameter is
missing, it is taken to be \texttt{nil}.  A rule with its formal parameter
list is presented in the form:
\begin{center}
  \texttt{(\carg{\bkt{rulename} \bkt{required}$^{\textstyle *}$
        \optl\ \bkt{\textrm{\emph{optional}}\default{default}}$^{\textstyle *}$
        \rest\ \bkt{argument}})}
\end{center}
The \optl\ and \rest\ are metalanguage keywords used in this reference
guide to indicate how the arguments are to 
be provided; they are never legal arguments themselves.\footnote{Those
with a background in Lisp will note the resemblance.  However, note that
\optl\ as used in PVS is a combination of \optl\ and {{\smaller\sc
{\smaller\smaller \&}key}}.} The \optl\ keyword indicates that the
arguments which follow it are \emph{optional}.  Such arguments may be
provided either by \emph{position} or by \emph{keyword}.  To provide
the argument by position, simply include values for all the preceding
arguments followed by the value of the argument in question.  This is
usually the most convenient way to use the commands.  Occasionally, you
will want the default taken for most of the optional arguments, and only
want to specify a different value for one near the end of the list.  In
this case, you may provide a pair of arguments, the first being the name
of the argument preceded by a colon, and the second the value for the
argument.  This will be made clear in the examples below.  The \rest\
keyword indicates that zero or more values may be provided for the
indicated argument and these are accumulated into a list.  The \rest\
argument can also by supplied as a list by keyword.  

Note that many proof rules have arguments indicating the number or numbers
of the sequent formulas where the rule is to be applied.  The syntactic
convention is that when a single such number is expected, we indicate the
argument as being an \emph{fnum} (for ``sequent formula number''), and
where a list of such numbers is expected, we indicate the argument as
\emph{fnums}.  Typically, a single number is acceptable where a list is
expected, and denotes the singleton list containing that number.  The list
of antecedent sequent formulas can be indicated by `\texttt{-}', the list
of consequent sequent formulas can be indicated by `\texttt{+}', and the
list of all sequent formulas can be indicated by `\texttt{*}'.  The use of
this notation will be illustrated in the examples below.  Lists here mean
a sequence of formula numbers separated by whitespace (space, tab or
carriage return) and surrounded by parentheses.  The \texttt{-},
\texttt{+}, \texttt{*} indicators are preferable to specific numbers since
they are more robust in the face of changes affecting the formula being
proved.

The value provided for a \emph{name}, \emph{expr}, or \emph{type}
argument should be a legal corresponding PVS expression enclosed in
a pair of string quotes (\texttt{"}).  As with \emph{fnums}, lists of
these may be expected when the argument is \emph{names}, \emph{exprs},
or \emph{types}.

 When interacting with the prover you are
essentially interacting with Lisp, and it is possible to give arguments
that are ill-formed enough to cause problems.  One such problem occurs
when parentheses or string quotes are unbalanced.  The immediate sign of
this is that the system does not respond.  To verify this, look on the
right hand side of the status line of the \texttt{*pvs*} buffer; it will
display \texttt{:ready} when waiting for a (complete) command, and \texttt{:run} when processing.  Until it says \texttt{:run}, you may freely edit
the command, even if it takes multiple lines.  Other keystrokes can
cause problems that break into Lisp (for example, typing a period at the
\texttt{Rule?}\ prompt).  If this happens, type \texttt{(restore)}, which
causes the focus to return to the last point of interaction 
with the \texttt{Rule?}\ prompt.
Rarely, the system will not respond correctly to the \texttt{(restore)}
function, in which case you will have to abort to the top level (by
typing \texttt{:reset}).  In this case, the proof attempt is lost and
you will have to start the proof over---though it still has the
previously saved proof attempt.

Here are some examples of rules with their formal parameter lists:
\begin{itemize}
\item \texttt{(lemma \carg{name} \optl\ \carg{subst})}
\item \texttt{(replace \carg{fnum} \optl\
      \cargdflt{fnums}{*} \cargdflt{dir}{LR} \carg{hide?}\ \carg{actuals?})}
\item \texttt{(delete \rest\ \carg{fnums})}
\end{itemize}
The following are possible invocations of the above proof rules:
\begin{itemize}
\item \texttt{(lemma "assoc")}
\item \texttt{(lemma "assoc" ("x" "1" "y" 2 "z" 3))}
\item \texttt{(lemma "assoc" :subst ("x" "1" "y" 2 "z" 3))}
\item \texttt{(replace -1)}
\item \texttt{(replace -1 :dir RL)}
\item \texttt{(replace -1 (2 -2 3) RL)}
\item \texttt{(delete)}
\item \texttt{(delete 1)}
\item \texttt{(delete -2 1 -3)}
\item \texttt{(delete :fnums (-2 1 -3))}
\end{itemize}



\subsection{Rules versus Strategies}
\index{Proof Strategies}
\index{Proof Rules}

A PVS proof command given at the \texttt{Rule?}\ prompt can either invoke a
rule or a strategy.  A rule in PVS is an atomic operation that typically
generates zero or more subgoals from the given goal.  A strategy need not
be atomic.  An application of a strategy expands into a number of atomic
steps.  The atomic proof steps resulting from this expansion of the
strategy are saved in the final proof and these are executed directly when
the proof is rerun.  The \indtt{apply} rule applies a given strategy as an
atomic step thus converting a strategy into a rule.   Rules are
either primitive or defined, and the defined rules are defined as
strategies but applied as atomic proof steps.  For example, the rule for
replacement using an antecedent equality, \indtt{replace}, is a primitive
rule whereas \indtt{rewrite} is a defined rule and is defined by a
strategy that uses the \indtt{replace} rule.  Several proof
commands that are rules have non-atomic analogues given by strategies:
\indtt{prop} is the atomic propositional simplification rule and \texttt{prop\char36} is the corresponding strategy.

In pragmatic terms, strategies should be used when the expanded proof is
of interest and  otherwise, rules should be used.  So for instance, \texttt{prop} should almost always be favored over \texttt{prop\char36} since the
details of propositional simplification are seldom interesting.
It is also useful to invoke the strategy corresponding to a rule 
in order to observe the inner workings of the strategy.  

PVS features a strategy language for defining new rules and strategies.
There is a corresponding interpreter for the strategy expressions defined
using this  language.  The strategy language contains constructs for
selecting among alternative proof strategies (\indtt{if}), for backtracking
(\indtt{try}), and for invoking Lisp code (\indtt{let}).  Strategies can also
be defined using recursion.


\subsection{Proof Checker Pragmatics}


It is not necessary to master all the proof commands in order to use the
PVS proof checker effectively.  It is advisable to learn the most
powerful commands first and try these and only rely on the simpler
commands when the powerful ones fail.  Broadly speaking, there are two
typical kinds of proofs: those that require induction and those that do
not.  For proofs by induction, one of the induction commands is usually
the first step, and \indtt{induct-and-simplify} is the most powerful and
useful of these.  The commands \indtt{induct-and-rewrite} and \indbang{}
are variants of \indtt{induct-and-simplify}.  

The \indtt{grind} command is usually a good way to complete a proof that
does not require induction, and only requires definition expansion, and
arithmetic, equality, and quantifier reasoning.  The behavior of
\indtt{grind} can be controlled through its various optional arguments,
particularly \texttt{if-match} and \texttt{defs}.   Simpler forms of
\indtt{grind} such as \indtt{bash}, \indtt{reduce}, and \indtt{smash} can
be used when \texttt{grind} becomes difficult to control.   The \indtt{grind}
command can sometimes instantiate existential strength quantifiers
prematurely, and when this happens, it is often more appropriate
to first apply \texttt{(grind :if-match nil)}, which performs all the
simplifications of \texttt{grind} except quantifier instantiation,
followed by \texttt{(grind)} to pick up the instantiations exposed by
the first \indtt{grind}.  

In a more interactive proof attempt, the initial step in a proof is
usually the introduction of Skolem constants, and the preferred and most
powerful form here is \indtt{skosimp*}.  Note that a universal quantifier 
is needed for induction and in such cases, \indtt{skosimp*} might
go too far and \skobang{}  or \indtt{skosimp} might be more appropriate.

The decision procedure command \indtt{assert} is used very frequently
particularly since it does simplification, automatic rewriting, and
records type information and the sequent formulas in the decision
procedure database for use in future simplifications.  The more
restrictive forms of \indtt{assert}, namely, \indtt{simplify},
\indtt{do-rewrite}, and \indtt{record}  also come in handy.
The command \indtt{simplify-with-rewrites} can be used to temporarily
install and apply rewrite rules using \indtt{assert}.  

The \indtt{inst?}\ command is the most powerful way to automatically
instantiate quantifiers of existential strength.  It has several options
to control the selection of suitable instances.   

The \indtt{bddsimp} command is the most efficient way to do propositional
simplification, but \indtt{prop} will do when efficiency is not important.
Propositional simplification has to be used with care since it can often
generate lots of subgoals that share the same proof.  The \indtt{flatten}
and \indtt{split} commands must be used to do the propositional
simplification more delicately.  The \indtt{case} command is very useful as
a way of introducing case splits into a proof.  The \indtt{lift-if} command
is typically needed to bring the case analyses in an expanded definition
to the surface of the sequent where it can be propositionally simplified.

Of the control commands, \indtt{postpone} is used to cycle through the
pending subgoals in the proof, and \indtt{undo} is  used to
recover from fruitless paths in a proof.

In addition to the above commands, it helps to be
familiar with the prelude theories which contain a lot
of useful background mathematics.  Advanced users wishing
to define their own proof strategies should examine the definitions
of the basic strategies supplied with PVS.\@  A file containing
these definitions is distributed with the system.  


We now describe each of these groups of rules.  The table at the beginning
of each group briefly summarizes the effect of each command and
indicates whether the rule is \emph{primitive} or \emph{defined}.
This distinction is not crucial to the use of the theorem prover.
The defined commands can be redefined by the user, but the primitive
commands capture the underlying PVS logic and therefore cannot be
changed.  Each rule is an atomic step in the proof.  There are
`glass-box' versions for some of the defined
rules where the rule is executed as a strategy.
The name for such a proof strategy is typically the rule
name with a `\texttt{\char36}' suffix. 
For example, the
glass-box version of \indtt{induct-and-simplify} is
\texttt{induct-and-simplify\char36}.   The documentation indicates
the presence of both the black-box and glass-box versions
of this rule by listing the name as \texttt{induct-and-simplify/\char36}.


\section{The Help Rule}
\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{help} & \emph{primitive} & provide brief documentation\\\hline
\end{tabularx}

\prsubsection{help}{Help for Proof Commands}
\begin{description}
\item[syntax:] \texttt{(help \optl\ \cargdflt{name}{*})}

\item[effect:] Displays a brief description of a specific primitive proof
command, defined rule, or strategy, or of all of the rules, defined rules,
and strategies.  Apart from displaying help information, the \indtt{help}
rule behaves as a \texttt{(skip)}\indextt{skip}, \ie\ it has no effect on
the proof.

\begin{usage}{}
\item[\texttt{(help)} :] Displays help on all of the rules, defined rules,
and strategies
\item[\texttt{(help rules)} :] Displays help on all the primitive rules.
\item[\texttt{(help defined-rules)} :] Displays help on all of the defined rules.
\item[\texttt{(help strategies)} :] Displays help on all of the strategies.
\item[\texttt{(help skolem)} :] Displays help on the \texttt{skolem} rule.
\item[\texttt{(help prop\char36)} :] Displays help on the \texttt{prop\char36} strategy.
\end{usage}

\item[notes:] This command should only be used interactively.  It is
usually better to use the Emacs commands \emacstt{help-pvs-prover},
\emacstt{help-pvs-prover-command},\newline \emacstt{help-pvs-prover-strategy},
or \emacstt{help-pvs-prover-emacs}, since they display the information in
a buffer for repeated reference.  The Emacs commands
\emacstt{x-prover-commands} when used in conjunction with X Windows
displays a mousable window listing the prover commands.

\end{description}

\section{The Annotation Rules}
\index{Proof Rules!Annotation|)}


\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{comment} & \emph{primitive} & attach comments to proof sequents\\\hline
\indtt{label} & \emph{primitive} & attach labels to sequent formulas\\\hline
\indtt{unlabel} & \emph{primitive} & remove labels from sequent formulas\\\hline
\indtt{with-labels} & \emph{defined} & label resulting formulas \\\hline
\end{tabularx}

\prsubsection{comment}{Attach Comments to a Proof Sequent}
\begin{description}
\item[syntax:] \texttt{(comment \carg{string})}

\item[effect:] Attaches a comment string to the current proof sequent that
is printed with preceding semi-colons above the sequent formulas.  This
comment string is also saved with the proof.  The \texttt{comment} command
can be nested within strategies and the comments are retained on the
subgoals generated by the strategy.

\begin{usage}{}
\item[\texttt{(comment "3rd induction case")} :] Prints the comment string
 between the sequent label and the sequent formulas.  
\end{usage}

\end{description}

\prsubsection{label}{Attach a Label to Sequent Formulas}
\begin{description}
\item[syntax:] \texttt{(label\ \carg{string-or-symbol} \carg{fnums} \optl\
\carg{push?})}

\item[effect:] It is often useful to group and label a collection of
related formulas in a proof sequent.  The \indtt{label} command is used
for this purpose.  Each sequent formula can have a set of labels, in
addition to its \emph{fnum}.  The labels are printed alongside the
\emph{fnum} whenever a proof sequent is displayed.  A label can be used
wherever an \emph{fnum} is expected.  A label can supplied as either a
symbol, e.g., \texttt{(label indhyp)} or a string, e.g., \texttt{(label
"indhyp")}, though it is stored internally as a symbol.  Labels are
automatically inherited by any subformulas of a sequent formulas that
appear through the application of an inference rule, e.g.,
\texttt{flatten} applied to a consequent formula $A \vee B$ labelled
\texttt{main} results in two sequent formulas $A$ and $B$ both labelled
\texttt{main}.

When \emph{push?}\ is \texttt{t}, the new label is added to any existing
labels on the formula.  Otherwise, the given label replaces any existing
ones.

\begin{usage}{}
\item[\texttt{(label uniqueness -3)} :] Labels the formula numbered
\texttt{-3} by the label \texttt{uniqueness}.

\item[\texttt{(label type-constraints (-1 -3 -4))} :] Labels the formulas
numbered \texttt{-1}, \texttt{-3}, and \texttt{-4} by the label
\texttt{type-constraints}.

\item[\texttt{(label antecedents - :push? t)} :] Adds the label
\texttt{type-constraints} in addition to any other labels on the formulas
numbered \texttt{-1}, \texttt{-3}, and \texttt{-4}.

\item[\texttt{(bddsimp type-constraints)} :] Applies BDD-based
propositional simplification to the formulas labelled
\texttt{type-constraints}.
\end{usage}

\item[errors:] The label may not be a number, or \texttt{nil},
\texttt{quote}, \texttt{*}, \texttt{+}, or \texttt{-}.

\item[notes:] Note that the \texttt{bddsimp} command does not retain
labels since there is no simple way to retain the connection between the
formula returned by BDD-simplification and its original parent formula.
\end{description}
\prsubsection{unlabel}{Remove Labels from Sequent Formulas}
\begin{description}
\item[syntax:] \texttt{(unlabel\ \optl\ \carg{fnums} \carg{label})}

\item[effect:] Removes specified \emph{label} (or all labels if none
specified) from the formulas in \emph{fnums}.  When \emph{fnums} is not
specified, label(s) are removed from all formulas.

\end{description}
\index{Proof Rules!Annotation|)}


\prsubsection{with-labels}{Label New Sequent Formulas}
\begin{description}
\item[syntax:] \texttt{(with-labels\ \carg{rule} \carg{labels} \optl\
\carg{push?})}

\item[effect:] Given a proof step \emph{rule} and a list of
list of \emph{labels} $((l_{11} \ldots)\ldots (l_{n1} \ldots))$,
if the rule generates $n$ subgoals, then the $j$'th new
sequent formula in the $i$'th subgoal is assigned the label
$l_{ij}$.  If there are more subgoals than label lists, then
the last label list is applied to the remaining subgoals.
In each pairing of new formulas with labels in a list, if there are
more formulas than labels, the last label is applied to the remaining
new formulas.  A singleton list of labels can be replaced by a
single label.

When \emph{push?}\ is \texttt{t}, the new label is added to any existing
labels on the formula.  Otherwise, the given label replaces any existing
ones.

\begin{usage}{}
\item[\texttt{(with-labels (flatten) ((l1 l2 l3)))}:]
Applies \texttt{flatten} rule to the current proof subgoal and labels
the new sequent formulas thus produced as \texttt{l1}, \texttt{l2},
and \texttt{l3}, respectively.

\item[\texttt{(with-labels (prop) ((l11 l12 l13) (l21 l22)))}:]
Applies the \texttt{prop} rule and labels the new formulas in the
first subgoal by labels \texttt{l11}, \texttt{l12}, and \texttt{l13}, and
the new formulas in any remaining subgoals are labelled by
labels \texttt{l21} and \texttt{l22}.

\item[\texttt{(with-labels (prop) "prop-formulas")}:] Labels all the
new sequent formulas resulting from the application of \texttt{prop}
by the label \texttt{prop-formulas}. 
\end{usage}

\end{description}


\section{The Control Rules}
\index{Proof Rules!Control|(}
\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{fail} & \emph{primitive} & signal a failure\\\hline
\indtt{postpone}& \emph{primitive} & cause the current goal to be
left pending\\\hline
\indtt{quit} & \emph{primitive} & quit a proof attempt \\\hline
\indtt{rewrite-msg-off} & \emph{defined} & inhibit rewriting
commentary\\\hline
\indtt{rewrite-msg-on} & \emph{defined} & turn on rewriting
commentary\\\hline
\indtt{set-print-depth} & \emph{defined} & set the print-depth for formulas \\\hline
\indtt{set-print-length} & \emph{defined} & set the print-length for formulas \\\hline
\indtt{set-print-lines} & \emph{defined} & set the print-lines for formulas \\\hline
\indtt{skip} & \emph{primitive} & has no effect but is useful in defining
strategies\\\hline
\indtt{skip-msg} & \emph{defined} & like \emph{skip} but generate a
message\\\hline
\indtt{trace} & \emph{defined} & turn on tracing of proof
commands\\\hline
\indtt{track-rewrite} & \emph{defined} & explain why a rewrite was not
applied\\\hline
\indtt{undo} & \emph{primitive} & undo proof steps along a branch of
the proof\\\hline
\indtt{untrace} & \emph{defined} & turn off tracing of proof commands\\\hline
\indtt{untrack-rewrite} & \emph{defined} & turn off rewrite explanation\\\hline
\end{tabularx}

\prsubsection{fail}{Propagate Failure to the Parent}
\begin{description}
\item[syntax:] \texttt{(fail)}

\item[effect:] A failure signal is propagated to the parent proof goal.
If the parent goal is not able to act on this signal, it further
propagates the failure to its parent.  This rule, like \indtt{skip}, is
mainly employed in constructing strategies where it is used to control
backtracking.  Applying \indtt{fail} to the root sequent causes the proof
to be unsuccessfully terminated.  

\item[usage:] \texttt{(fail)}

\item[errors:]  No error messages are generated.

\item[notes:]  See the description of the \indtt{try} strategy in
page~\pageref{trypage} for examples of 
the use of \indtt{fail}.  
\end{description}


\prsubsection{postpone}{Go to Next Remaining Goal}
\begin{description}
\item[syntax:] \texttt{(postpone \optl\ \cargdflt{print?}{t})}

\item[effect:] Marks the current goal as pending to be proved and shifts
the focus to the next remaining goal.  By successively invoking \texttt{postpone} sufficiently often, it is possible to cycle back to the
original focus.  When \emph{print?}\ is \texttt{t} commentary is
suppressed. 

\item[usage:]   \texttt{(postpone)}

\item[errors:]  No error messages are generated.

\item[notes:]  The Emacs command \emacstt{siblings} shows the sibling
subgoals of the current subgoal in an emacs buffer.

\end{description}

\prsubsection{quit}{Terminate the Proof Attempt}
\begin{description}

\item[syntax:] \texttt{(quit)}

\item[effect:] Terminates the current proof attempt, and queries whether
the partial proof in progress should be saved.  This way, it is possible
to break and resume a long proof attempt by saving the partial proof and
rerunning it when the proof attempt is resumed.

\item[notes:] This strategy should only be used interactively.
\end{description}

\prsubsection{rewrite-msg-off}{Inhibit Rewriting Commentary}
\begin{description}

\item[syntax:] \texttt{(rewrite-msg-off)}

\item[effect:] In the default mode, automatic rewriting by commands such
as \texttt{assert} and \texttt{do-rewrite} generate a fairly verbose
commentary.  This can be entirely shut off by the \texttt{rewrite-msg-off}
command.  Behaves like a \texttt{skip} otherwise.

\item[notes:] Finer-grain control over the terseness of the
rewriting commentary is possible with the Emacs commands
\emacstt{set-rewrite-depth} and \emacstt{set-rewrite\-length}.
\end{description}

\prsubsection{rewrite-msg-on}{Turn On Rewriting Commentary}
\begin{description}

\item[syntax:] \texttt{(rewrite-msg-on)}

\item[effect:] The rewriting commentary turned off by
\texttt{rewrite-msg-off} can be restored by this command.  Behaves like a
\texttt{skip} otherwise.
\end{description}

\prsubsection{set-print-depth}{Set the Print Depth}
\begin{description}

\item[syntax:] \texttt{(set-print-depth \optl\ \carg{depth})}

\item[effect:] Sets the print depth for displaying formulas.  \emph{Depth}
must be a number or \texttt{nil}.  0 or \texttt{nil} means print the
entire formula, any other number causes terms below the given depth to be
elided.  Behaves like a \texttt{skip} otherwise.

\item[errors:] The label must be a number or \texttt{nil}.
\end{description}

\prsubsection{set-print-length}{Set the Print Length}
\begin{description}

\item[syntax:] \texttt{(set-print-length \optl\ \carg{length})}

\item[effect:] Sets the print length for displaying formulas.
\emph{Length} must be a number or \texttt{nil}.  0 or \texttt{nil} means
print the entire formula, any other number causes terms longer than the
given number to be elided.  Behaves like a \texttt{skip} otherwise.

\item[errors:] The label must be a number or \texttt{nil}.
\end{description}

\prsubsection{set-print-lines}{Set the Number of Print Lines}
\begin{description}

\item[syntax:] \texttt{(set-print-lines \optl\ \carg{lines})}

\item[effect:] Sets the number of print lines for displaying formulas.
\emph{Lines} must be a number or \texttt{nil}.  0 or \texttt{nil} means
print the entire formula, any other number causes only the first specified
number of lines of each formula of the sequent to be displayed.  Behaves
like a \texttt{skip} otherwise.

\item[errors:] The label must be a number or \texttt{nil}.
\end{description}

\prsubsection{skip}{Do Nothing}
\begin{description}
\item[syntax:] \texttt{(skip)}

\item[effect:] Has no effect on the proof.  The primary utility of \texttt{skip} is in writing strategies where a step is required to have no
effect unless some condition holds.  Typing \texttt{(skip)} in response to
a goal sequent returns the same proof state with a \texttt{"No change."}
message.

\item[usage:] \texttt{(skip)}

\item[errors:] No error messages are generated.
\end{description}


\prsubsection{skip-msg}{Do Nothing but Print}
\begin{description}
\item[syntax:] \texttt{(skip-msg \carg{msg} \optl\ \carg{force-printing?})}

\item[effect:] Has no effect on the proof but prints the given \emph{msg} string.  The main use of \texttt{skip-msg} is in generating error
messages from within strategies, typically as: \texttt{(if good?(input)
\ldots (skip-msg "Bad input."))}.

\begin{usage}{}
\item[\texttt{(skip-msg "Not enough terms given.")}]: Does nothing but
prints the error message \texttt{"Not enough terms given."}.

\item[\texttt{(skip-msg "Not enough terms given." t)}]:
Does nothing but prints the error message \texttt{"Not enough terms
given."} even when the \texttt{skip-msg} appear within an \texttt{apply}
where the printing of such messages is usually suppressed.

\item[]\smaller{\begin{alltt}
(let ((string (format nil
                "No such theory: ~a in current context." theory)))
  (skip-msg string)):
\end{alltt}}Builds the string \texttt{string}
for use within \texttt{skip-msg}. 
\end{usage}


\item[errors:] No error messages are generated.

\end{description}


\prsubsection{trace}{Trace Commands}
\begin{description}
\item[syntax:] \texttt{(trace \rest\ \carg{names})}

\item[effect:] Turns on the tracing of the proof commands named in \emph{names} so that any time any one of the named rules or strategies is used
in a proof, the entry into and exit out of such commands is
traced.  This makes it possible to check if the command is being properly
invoked and has the desired effect.   Behaves like a \texttt{skip} otherwise.


\item[usage:] \texttt{(trace assert inst?\ induct)}

\item[errors:] No error messages.

\item[notes:] \texttt{untrace} turns off tracing initiated by \texttt{trace}.
\end{description}



\prsubsection{track-rewrite}{Explain Failure of Rewrite Rules}
\begin{description}
\item[syntax:] \texttt{(track-rewrite \rest\ \carg{names})}

\item[effect:]  Explains why the attempt to apply a rewrite rule named in
\emph{names} was not applied.  The typical reasons are:
\begin{enumerate}
\item The expression being rewritten did not match the left-hand side of
the rewrite rule.

\item The match succeeded but generated type-correctness proof obligations
that could not be simplified to \texttt{TRUE}\@.  

\item The match succeeded but the corresponding conditions of the rewrite
rule could not be simplified to \texttt{TRUE}.

\item The match succeeded and the corresponding conditions did simplify to
\texttt{TRUE}, but the top-level conditional or \texttt{CASES} branch in the
corresponding right-hand side of the rewrite rule was not simplifiable.
This top-level conditional on the right-hand side should be simplifiable
in the case of recursive definitions and ordinary rewrite rules which are
not installed with the \texttt{always?}\ flag set to \texttt{t}.
\end{enumerate}

Other than setting up the names of the rewrite rules to be tracked during
simplification, \texttt{track-rewrite} behaves like a \texttt{skip}.  It has
no effect on the current proof sequent and is not saved as part of the
partial or completed proof.  


\item[usage:] \texttt{(track-rewrite "assoc" "append" "reverse\_append" )}:
Tracks the given rewrite rules during 
simplification and reports any failures corresponding to when the rewrites
are unsuccessful.

\item[errors:] No error messages.

\item[notes:] \indtt{untrack-rewrite} turns off the tracking of rewrite
rules initiated by track-rewrite.  
\end{description}


\prsubsection{undo}{Undo Proof to an Ancestor}
\begin{description}
\item[syntax:] \texttt{(undo \optl\ \carg{to}{1})}

\item[effect:] The undo command undoes the proof back to an ancestor
node of the current node as indicated by the \emph{to} argument.  The
user is then shown the sequent at that ancestor node, and asked for
verification.  The \emph{to} argument can either be:
\begin{enumerate}
\item A positive number indicating the number of levels in the proof tree
to be undone

\item A label, in which case the proof is undone to the lowest
occurrence of a sequent with that label above the current sequent
(since there can be many sequents in the proof with the same label; 
labels are only extended when there are multiple subgoals)

\item A proof rule or strategy in which case the proof is undone up to
the lowest occurrence of a sequent where the given rule was applied by
the prover or
the given strategy was supplied by the user, or

\item A rule name or strategy name, so that the proof is undone to the
lowest occurrence of a sequent where a rule with the given name was
applied by the prover or a strategy of the given name was supplied by the user.
\end{enumerate}
Undo applies its effects relative to the current node, not the last
command.  Thus undoing immediately after a branch has been proved or
postponed will not, in general, go back to the state of the proof tree
just before the last command.  However, undo can be used to undo
the effect of an undo command if invoked \emph{immediately} afterwards. 

\begin{usage}{}
\item[\texttt{(undo)}] : Undoes a single step of the proof.

\item[\texttt{(undo 3)}] : Undoes three steps in the proof.

\item[\texttt{(undo undo)}] : Undoes an undo, if it was the last command
executed.  If anything has been executed since the undo command, it is not
possible to undo the undo.

\item[\texttt{(undo (skolem 1))}] : Undoes back to the lowest ancestor node
where \texttt{(skolem 1)} was applied.

\item[\texttt{(undo skolem)}] : Undoes back to the lowest ancestor node
where a proof rule or strategy of the form \texttt{(skolem \ldots)} was
issued or applied.

\item[\texttt{(undo skolem!)}] : Undoes back to the lowest ancestor node
where \texttt{skolem!} was issued.

\item[\texttt{(undo "assoc.2")}] :  Undoes back to the lowest ancestor node
labelled with \texttt{assoc.2}, unless \texttt{assoc.2} labels the current node in
which case there is no change.
\end{usage}

\item[notes:]
\begin{itemize}
\item The \indtt{undo} command is only meant to be used
interactively.  Noninteractive strategies should use the \indtt{fail}
command for the same effect.

\item The Emacs command \emacstt{ancestry} shows the chain of proof
goals leading back to the root node of the proof.

\item A \texttt{(rerun)} command immediately after an \indtt{undo}
will cause the undone proof to be rerun and restored.
\end{itemize}
\end{description}

\prsubsection{untrace}{Disable Tracing of Commands}
\begin{description}
\item[syntax:] \texttt{(untrace \rest\ \carg{names})}

\item[effect:] Turns off the tracing of proof commands named
in \emph{names}, as initiated by \texttt{(trace)}.  Behaves like
a \texttt{skip} otherwise.

\item[usage:] \texttt{(untrace assert)}

\item[errors:] No error messages
\end{description}

\prsubsection{untrack-rewrite}{Disable Tracking of Rewrite Rules}
\begin{description}
\item[syntax:] \texttt{(untrack-rewrite \rest\ \carg{names})}

\item[effect:] Disables the tracking of rewrite rules invoked by
\indtt{track-rewrite}.  When untrack-rewrite is invoked with no arguments,
then tracking is discontinued for all currently tracked rewrite rules.
Other than removing the given \emph{names} from list of rewrite rules to
be tracked during simplification, \texttt{untrack-rewrite} behaves like a
\texttt{skip}.  It has no effect on the current proof sequent and is not
saved as part of the partial or completed proof.

\begin{usage}{}
\item[\texttt{(untrack-rewrite "assoc" "append" "reverse\_append" )}:]
Disables tracking on the given rewrite rules. 

\item[\texttt{(untrack-rewrite)}:]  Disables tracking on all currently
tracked rewrites rules.
\end{usage}

\item[errors:] No error messages.
\end{description}

\index{Proof Rules!Control|)}

\section{The Structural Rules}
\index{Proof Rules!Structural|(}

Sequent calculus based proof systems employ structural rules to rearrange
the formulas in a sequent.  The typical structural rules are described in
Chapter~\ref{logic}.  In PVS, the Exchange rule is entirely omitted since
the PVS proof commands already ignore the order of formula occurrences
in a sequent except for the use of formula numbers.  The Contraction rule
is not built into PVS and only appears in a limited form; the rule for
instantiating quantifiers of existential strength permits the copying of
these quantified formulas so that they can be reused, if needed.  Some use
of Contraction is already built into the rules so that the non-principal
formulas are shared between the premises of a rule.  The defined rule
\indtt{copy} also implements Contraction.  The Weakening rule is present
in PVS as the \indtt{delete} rule below.  The \indtt{hide} rule is a
more cautious form of \indtt{delete}, where certain sequent formulas can
be suppressed and recovered later in the proof using the \indtt{reveal}
rule.  The emacs command \emacstt{show-hidden-formulas} displays hidden
formulas along with their numbers.

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indttdol{copy} & \emph{defined} & insert a copy of a sequent formula \\\hline
\indtt{delete} & \emph{primitive} &  delete selected formulas from a goal sequent\\\hline
\indtt{hide} & \emph{primitive} & temporarily hide selected formulas from the displayed goal \\\hline
\indtt{reveal} & \emph{primitive} & reveal hidden formulas\\\hline
\end{tabularx}

\prdolsubsection{copy}{Copy Selected Formula}
\begin{description}
\item[syntax:] \texttt{(copy \carg{fnum})}

\item[effect:] Inserts a copy of the sequent formula numbered \emph{fnum}
into the sequent.  If the given formula is an antecedent formula, then the
copy becomes the first antecedent formula, and if it is a consequent
formula, then the copy becomes the first consequent formula.

\begin{usage}{}
\item [\texttt{(copy -3)}] : Makes a copy of the formula numbered -3
and inserts it as the first antecedent formula.

\end{usage}

\item[errors:] {\bf Could not find formula number \emph{foo}}: attempt
to copy a formula which does not exist.
\end{description}

\prsubsection{delete}{Delete Selected Formulas}
\begin{description}
\item[syntax:]  \texttt{(delete \rest\ \carg{fnums})}

\item[effect:] Returns the subgoal that is the result of deleting all
of the sequent formulas in the current goal that are indicated by \emph{fnums}.  If there are no formulas in the sequent corresponding
to those indicated in \emph{fnums}, then the effect is that of a
\texttt{(skip)}.

\begin{usage}{}
\item [\texttt{(delete *)}] : Deletes every formula in the sequent yielding a
subgoal that is an empty sequent.  This invocation of the rule is not
advisable because the empty sequent is unprovable.

\item[\texttt{(delete +)}] :  Yields the subgoal where all the
consequent formulas in the current goal sequent have been deleted. 

\item[\texttt{(delete -)}] : Same as above with antecedent formulas.

\item[\texttt{(delete 2)}] : Yields the subgoal where formula number \texttt{2}
in the current subgoal is deleted.

\item[\texttt{(delete (-1 4 -3 2))}] : Yields the subgoal where formulas
numbered \texttt{-1}, \texttt{4}, \texttt{-3}, and \texttt{2} in the current subgoal
are deleted.

\item[\texttt{(delete -1 4 -3 2)}] : Same as above.
\end{usage}

\item[errors:] No error messages are generated.

\item[notes:] When in doubt, use \indtt{hide} instead of \indtt{delete}.
\end{description}

\prsubsection{hide}{Hide Selected Formulas}
\begin{description}
\item[syntax:] \texttt{(hide \rest\ \carg{fnums})}

\item[effect:] This is a more cautious version of \indtt{delete}.  The \texttt{hide} rule saves the deleted sequent formulas that are indicated by \emph{fnums} so that they can be restored to a descendant of the current sequent
by the \indtt{reveal} rule (see below).  Note that the non-copying version of
the \indtt{instantiate} rule and the \indtt{inst} rule automatically hide the
quantified formula so that quantifiers can be later reinstantiated
along the same branch of the proof if needed.


\begin{usage}{}
\item[\texttt{(hide 2)}] : Yields the subgoal sequent that results from hiding the
formula number \texttt{2} in the current goal sequent.

\item[\texttt{(hide (-1 4 -3 2))}] : Yields the subgoal sequent that results from
hiding the formulas numbered \texttt{-1}, \texttt{4}, \texttt{-3}, and \texttt{2} in
the current goal sequent.

\item[\texttt{(hide -1 4 -3 2)}] : Same as above.
\end{usage}

\item[errors:] No error messages are generated.

\item[notes:] Hidden formulas play no role in a proof until they are
revealed.  Thus in addition to eliminating ``clutter'' in the display,
they can also affect the performance of the ground prover which contains
decision procedures for equality and linear arithmetic.
\end{description}

\prdolsubsection{hide-all-but}{Hide Unselected Formulas}
\begin{description}
\item[syntax:] \texttt{(hide-all-but\ \optl\ \carg{keep-fnums} \cargdflt{fnums}{*})}

\item[effect:] This is a variant of the \indtt{hide} rule that hides all
the formulas indicated by \emph{fnums} except those indicated by \emph{keep-fnums}\@.  As with \indtt{hide}, hidden sequent formulas are saved
and can be restored to a descendant of the current sequent by the
\indtt{reveal} rule.

\begin{usage}{}
\item[\texttt{(hide-all-but (-1 -4) -)}] : Yields the subgoal sequent that
results from hiding all the antecendent formulas except the formulas
numbered \texttt{-1} and \texttt{-4} in the current sequent.

\item[\texttt{(hide-all-but * (-2 1))}] : Hides formulas numbered \texttt{-2} and
\texttt{1} in the current sequent.  

\item[\texttt{(hide-all-but :keep-fnums (-2 3))}] :  Hides all formulas except those
numbered \texttt{-2} and \texttt{3} in the current sequent.
\end{usage}

\item[errors:] No error messages are generated.

\end{description}


\prsubsection{reveal}{Reveal Hidden Formulas}
\begin{description}
\item[syntax:] \texttt{(reveal \rest\ \carg{fnums})}

\item[effect:] The Emacs command \emacstt{show-hidden-formulas} displays
the hidden formulas in sequent form, including the formula numbers that
may be used in \texttt{reveal}.  Invoking \indtt{reveal} yields a subgoal
that reintroduces the hidden formulas numbered \emph{fnums} into the
current sequent.  The formulas thus revealed are not removed from the list
of hidden formulas.

\begin{usage}{}
\item[\texttt{(reveal -2)}] : Reveals the formula numbered \texttt{-2} in
the sequent displayed by \emacstt{show-hidden-formulas}.

\item[\texttt{(reveal (-1 4 -3 2))}] : Reveals the formulas numbered \texttt{-1}, \texttt{4}, \texttt{-3}, \texttt{2} in the sequent displayed by
\emacstt{show-hidden-formulas}.

\item[\texttt{(reveal -1 4 -3 2)}] : Same as above.
\end{usage}

\item[errors:] No error messages are generated.
\end{description}
\index{Proof Rules!Structural|)}

\section{The Propositional Rules}
\index{Proof Rules!Propositional|(}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{bddsimp} & \emph{primitive} & propositional simplification rule\\\hline
\indtt{case} & \emph{primitive} & introduce a case split (the Cut rule)\\\hline
\indttdol{case*} & \emph{defined} & introduce case splits \\\hline
\indtt{flatten} & \emph{defined} & disjunctive simplification\\\hline
\indtt{flatten-disjunct} & \emph{primitive} & controlled disjunctive simplification\\\hline
\indtt{iff} & \emph{primitive} & convert boolean equalities to \emph{if and only if} form\\\hline
\indtt{lift-if} & \emph{primitive} & the \texttt{IF}-lifting rule \\\hline
\indtt{merge-fnums} & \emph{defined} & combine sequent formulas\\\hline
\indttdol{prop} & \emph{defined} & propositional simplification rule \\\hline
\indtt{propax} & \emph{primitive} & the propositional axiom rule\\\hline
\indtt{split} & \emph{primitive} & the conjunctive splitting rule\\\hline
\end{tabularx}


\prsubsection{bddsimp}{Propositional Simplification using BDDs}
\begin{description}

\item[syntax:] \texttt{(bddsimp \optl\ \cargdflt{fnums}{*}
\carg{dynamic-ordering?}\ \cargdflt{irredundant?}{t})}

\item[effect:] Generates subgoals by applying propositional simplification
using an external package written in C and based on binary decision
diagrams (BDDs).  Each distinct atomic Boolean formula in the sequent is
converted into a literal and the top-level propositional structure is
translated into input that is accepted by the BDD package.  The result is
translated back into the a list of subgoal sequents.

The \emph{dynamic-ordering?}\ flag when set to \texttt{t}, allows the
BDD package to reorder literals to reduce the BDD size.

The \emph{irredundant?}\ flag, when set to \texttt{t}, normalizes the BDD so
that the generated subgoals are independant, \ie\ no subgoal is subsumed
by any of the others.  This is quite expensive, and large BDDs can take a
long time to process, but without it proofs may need to be repeated on
multiple subgoals.

\item[usage:]  \texttt{(bddsimp)}: Repeatedly applies the propositional rules to
all the formulas in the sequent to generate zero or more subgoals.

\texttt{(bddsimp +)}: Applies propositional rules to the consequent formulas.

\texttt{(bddsimp + T)}:  Uses the dynamic reordering heuristic to control BDD
size while applying propositional simplification to  the consequent
formulas.

\item[errors: ]   No error messages.

\end{description}


\prsubsection{case}{Case Analysis on Formulas}
\begin{description}
\item[syntax:] \texttt{(case \rest\ \carg{formulas})}

\item[effect:] If the current sequent is of the form
$\Gamma\vdash\Delta$, then the rule \texttt{(case $A_1$ \ldots $A_n$)}
generates the subgoals
\begin{eqnarray*}
A_n, \ldots, A_1, \Gamma & \vdash & \Delta \\
A_{n-1}, \ldots, A_{1},\Gamma & \vdash & A_n,\Delta \\
A_{n-2}, \ldots, A_{1}, \Gamma & \vdash & A_{n-1}, \Delta \\
& \vdots & \\
A_1, \Gamma & \vdash & A_2,\Delta \\
\Gamma & \vdash & A_1, \Delta
\end{eqnarray*}
Note that the \texttt{case} command generates $n+1$ subgoals given $n$
formulas.  This allows us to assume a formula or a collection of formulas
and subsequently prove these formulas to be true.  The formulas $A_i$ are
given as strings, \eg, \texttt{"x > 0 AND y > 0"}.  The given formulas
$A_1, \ldots, A_n$ are parsed and typechecked and are expected to be of
type \texttt{bool}.  The typechecking of these formulas could generate
additional subgoals corresponding to the type correctness conditions \eg\
\texttt{(case "(1/x) > 0")} would generate an additional subgoal with the
proof obligation requiring that \texttt{x /= 0}.  It is quite common for
this command to generate parser and typechecker errors which simply return
control back to the proof checker without affecting the state of the
proof.

This command is extremely useful for transforming an undesirable
expression $t$ into a more desirable form $s$ when this cannot be achieved
by the other proof commands.  The command \texttt{(case "$t$ = $s$")}
followed by \indtt{replace} can achieve the desired transformation.  This
combination is encapsulated in the defined rule \indtt{case-replace}
(page~\pageref{case-replace})\@.


\begin{usage}{}
\item[\texttt{(case)}] : same as a \texttt{(skip)}.

\item[\texttt{(case "x > 0")}] :  splits into two cases, assuming \texttt{x > 0} as
an antecedent on one branch of the proof and placing \texttt{x > 0} as a
proof obligation along the other branch of the proof.  There might be
additional branches if the typechecking of the formula in place of \texttt{x > 0} generates type correctness proof obligations.

\item[\texttt{(case "x > 0" "y > 0")}] : splits a goal $\Gamma\vdash\Delta$ into
three subgoals:
\begin{itemize}
\item $\texttt{y > 0}, \texttt{x > 0},  \Gamma\:\vdash\:\Delta$
\item $\texttt{x > 0}, \Gamma\:\vdash\: \texttt{y > 0}, \Delta$
\item $\Gamma\:\vdash\: \texttt{x > 0}, \Delta$
\end{itemize}
\end{usage}

\item[errors:] The \indtt{case} rule can generate the following error
messages:
\begin{description}

\item[{\bf No formulas given.}] This means the argument list was empty.

\item[{\bf Irrelevant free variables \ldots occur in formulas.}] No
sequent in a PVS proof can have free variables in it.  They can only
contain bound variables, ordinary constants, and Skolem constants.  The
formulas given as arguments to the
\indtt{case} rule must not contain any free variables.

\item[{\bf boolean expected here.}] This indicates that one of the given
formulas did not typecheck to the expected type \texttt{boolean}.

\item[{\bf Parser error: \ldots}] One of the given formulas did not
parse correctly.

\item[{\bf Typecheck error: \ldots}]The typechecking of the given
formulas failed in one of a variety of ways.

\end{description}

\item[notes:] The \indtt{case} rule corresponds to applications of the Cut rule.
This command is surprisingly useful for explicitly controlling case splits in
a proof, and for introducing assumptions that will eventually be discharged.
\end{description}

\prdolsubsection{case*}{Full Case Analysis on Formulas}
\begin{description}
\item[syntax:] \texttt{(case* \rest\ \carg{formulas})}

\item[effect:]  Like the \texttt{case} command, but performs a fully
branching case analysis.  
If the current sequent is of the form
$\Gamma\vdash\Delta$, then the rule \texttt{(case* $A_1$ \ldots $A_n$)}
generates the subgoals
\begin{eqnarray*}
A_n, \ldots, A_1, \Gamma & \vdash & \Delta \\
A_{n-1}, \ldots, A_{1},\Gamma & \vdash & A_n,\Delta \\
A_n, A_{n-2}, \ldots, A_{1}, \Gamma & \vdash & A_{n-1},\Delta \\
A_{n-2}, \ldots, A_{1}, \Gamma & \vdash & A_n, A_{n-1},\Delta \\
& \vdots &  \\
A_n, \Gamma & \vdash & A_{n-1}, \ldots, A_1, \Delta \\
\Gamma & \vdash & A_n, \ldots, A_1, \Delta
\end{eqnarray*}
 Note that the \texttt{case*} command generates $2^n$
subgoals given $n$ formulas.  
This allows us to assume a formula or a collection of formulas and
subsequently prove these formulas to be true.  

\begin{usage}{}
\item[\texttt{(case*)}] : same as a \texttt{(skip)}.

\item[\texttt{(case* "x > 0" "y > 0")}] : splits a goal $\Gamma\vdash\Delta$ into
four subgoals:
\begin{itemize}
\item $\texttt{y > 0}, \texttt{x > 0},  \Gamma\:\vdash\:\Delta$
\item $\texttt{x > 0}, \Gamma\:\vdash\: \texttt{y > 0}, \Delta$
\item $\texttt{y > 0}, \Gamma\:\vdash\: \texttt{x > 0}, \Delta$
\item $\Gamma\:\vdash\: \texttt{y > 0}, \texttt{x > 0}, \Delta$
\end{itemize}
\end{usage}

\item[errors:] The \indtt{case*} rule can generate the same
error message as the \indtt{case} command. 

\end{description}


\prsubsection{flatten}{Disjunctive Simplification}
\begin{description}
\item[syntax:] \texttt{(flatten \rest\ \carg{fnums})}

\item[effect:] A sequent formula is a disjunct if it is either an
antecedent formula of the form $\neg A$ or $A\wedge B$, or a consequent
formula of the form $\neg A$, $A\supset B$, or $A\vee B$.  Disjunctive
simplification transforms each indicated formula into a list of formulas
that contains no disjuncts by repeatedly transforming
\begin{enumerate}
\item An antecedent formula $\neg A$ into the consequent formula $A$

\item An antecedent formula $A\wedge B$ into the two antecedent formulas $A$
and $B$

\item A consequent formula $\neg A$ into the antecedent formula $A$

\item A consequent formula $A\supset B$ into the antecedent
formula $A$ and the consequent formula $B$

\item A consequent formula $A\vee B$ into the two consequent formulas
$A$ and $B$

\item An antecedent formula $A\iff B$ into the two antecedent
formulas $A\supset B$ and $B\supset A$.
\end{enumerate}
The \indtt{flatten} rule yields a subgoal where the indicated formulas in
the current goal are disjunctively simplified.    The rule behaves as a
\texttt{(skip)} if none of the indicated formulas can be disjunctively
simplified.  The current goal is proved if disjunctive simplification
yields an antecedent formula {\sc false} or a consequent formula {\sc
true}.

\begin{usage}{}
\item [\texttt{(flatten)}] : disjunctively simplifies every formula in the
current goal sequent yielding a subgoal that contains no disjuncts that are
sequent formulas.

\item[\texttt{(flatten 2)}] : disjunctively simplifies formula number \texttt{2} in the current goal sequent.

\item [\texttt{(flatten +)}] : disjunctively simplifies all the consequent
formulas in the current goal sequent. 

\item[\texttt{(flatten (-1 4 -2))}] : disjunctively simplifies the formulas
numbered \texttt{-1}, \texttt{4}, and \texttt{-2} in the current goal sequent.

\item[\texttt{(flatten -1 4 -2)}] : Same as above.
\end{usage}

\item[errors:] No error messages are generated.

\item[notes:] This command corresponds to repeated applications of the
inference rules $\wedge\vdash$, $\vdash\vee$, $\vdash\supset$,
$\neg\vdash$, and $\vdash\neg$ in Chapter~\ref{logic}.  Note that these
are all the propositional rules which do not cause branching.  Since
this command does not cause any branching, it is always safe to use and
generally makes the sequent easier to read.

\end{description}

\prsubsection{flatten-disjunct}{Controlled Disjunctive Simplification}
\begin{description}
\item[syntax:] \texttt{(flatten-disjunct \optl\ \carg{fnums} \carg{depth})}

\item[effect:] As per \texttt{(flatten)}, but with an optional \emph{depth}
argument which can be used to control the depth to which the top-level
disjuncts in a sequent formula are flattened.  If the depth is not given,
then the disjunctive simplification is carried out without any bound
on the depth.

\begin{usage}{}

\item[\texttt{(flatten-disjunct + :depth 2)}] : flattens the consequent
disjunctive formulas, but only up to a depth of 2.

\end{usage}
\item[errors:] No error messages are generated.

\end{description}

\prsubsection{iff}{Convert Boolean Equality to Equivalence}
\begin{description}
\item[syntax:] \texttt{(iff \rest\ \carg{fnums})}

\item[effect:] Yields a subgoal where any boolean equalities of the form
$A = B$, among the formulas in the current sequent that are indicated by
\emph{fnums} are converted to $A\iff B$.\footnote{Recall that
$\iff$ is written as \texttt{iff} or \texttt{<=>} in the raw PVS
language.} Treating all boolean equalities as equivalences is not a good
idea since that leads to a combinatorial explosion when the
propositional steps are applied, and  in many such cases,  equality
reasoning is
sufficient to complete the proof.

\begin{usage}{}

\item[\texttt{(iff)}] : same as \texttt{(iff *)}.  Converts any boolean
equalities among the sequent formulas into equivalences.  Behaves like
\texttt{(skip)} if there are no such boolean equalities.

\item[\texttt{(iff -3)}] : converts the formula numbered \texttt{-3} into an
equivalence.

\item[\texttt{(iff (4 2 -1))}] : converts the formulas number \texttt{4}, \texttt{2}, and \texttt{-1} into equivalences.

\item[\texttt{(iff 4 2 -1)}] : Same as above.
\end{usage}

\item[errors:]  No error messages are generated.
\end{description}


\prsubsection{lift-if}{Lift Embedded IF Connectives}
\begin{description}
\item[syntax:] \texttt{(lift-if \optl\ \carg{fnums} \cargdflt{updates?}{t})}

\item[effect:] In proving properties of programs, the proof often splits
up into cases according to the branching structure of the program.  This
branching structure is typically expressed using the
\texttt{IF}-connective or the \indtt{CASES} construct.  Since these
\indtt{IF} and \indtt{CASES} branches could occur embedded within the
formula, this branching structure must be lifted to the top level of the
formula where the propositional simplification steps can be applied (see
the \indtt{flatten} and \texttt{split} commands above).  The
\indtt{lift-if} rule lifts the leftmost-innermost contiguous \indtt{IF} or
\indtt{CASES} \emph{branching structure} out to the top level.  An example
of such a transformation is the rewriting of
$f(\texttt{IF}(A,B,\texttt{IF}(C,D,E)))$ to
$\texttt{IF}(A,f(B),\texttt{IF}(C,f(D),f(E)))$.  On the other hand,
$f(\texttt{IF}(\texttt{IF}(A, B, C), D, E))$ is transformed by
\indtt{lift-if} to $\texttt{IF}(A, f(\texttt{IF}(B, D, E)),
f(\texttt{IF}(C, D,E)))$, reflecting the selection of the conditionals of
the leftmost-innermost \texttt{IF}-expression.  Note that
$f($\texttt{IF}$(A,$ \texttt{IF}$(B, C, D),$ \texttt{IF}$(E, F, G)))$ is
transformed to $\texttt{IF}(A, \texttt{IF}(B, f(C), f(D)), \texttt{IF}(E,
f(F), f(G)))$ reflecting the preservation of the contiguous
\texttt{IF}-branching structure.  It is more effective to lift a
contiguous block of \indtt{IF} branches since it more accurately reflects
the case structure of the resulting argument and results in a more
efficient \texttt{IF}-expression (since the branches $B$ and $E$ in
previous example are kept independent).  Note that only conditionals
without bound variables can be lifted, and this is used as a criterion by
the \indtt{lift-if} rule in selecting the branching structure.  The
leftmost-innermost branching structure typically turns out to be the most
appropriate one.  If this choice of branching structure turns out to be
inappropriate, the \indtt{case} command (see below) can be used to carry
out the desired case analysis.

\label{if-lift-updates} Unless the \emph{update?}\ flag is \texttt{nil},
the \indtt{lift-if} command has been extended to extract the case
structure from an array or function update.  An expression of the form
\texttt{(f WITH [(x)(u) := 3, (y)(v) := 5])(z)(w)} is converted to
\begin{alltt}
   (IF z = y THEN
       (IF w = v THEN 5
        ELSIF z = x THEN (IF w = u THEN 3 ELSE f(z) ENDIF) 
        ELSE f(z)
        ENDIF)
    ELSIF z = x THEN 3
    ELSE f(z)
    ENDIF)
\end{alltt}
The resulting IF-expression is then lifted by the \indtt{lift-if} command.


\begin{usage}{}

\item[\texttt{(lift-if)}] : same as \texttt{(lift-if *)}.  Yields the subgoal
got by lifting the leftmost-innermost branching structure in each of the
formulas in the current sequent.  Applications where the operator is an
update are converted into IF-expressions which are also lifted.  

\item[\texttt{(lift-if +)}] : yields the subgoal got by lifting the
leftmost-innermost branching structure in each of the consequent formulas
in the current sequent.  

\item[\texttt{(lift-if -3)}] : lifts the branching structure from the formula
numbered \texttt{-3} in the current sequent.

\item[\texttt{(lift-if (-1 3 -2))}] : lifts the branching structure from the
formulas numbered \texttt{-1}, \texttt{3}, and \texttt{-2} in the current sequent.

\item[\texttt{(lift-if (-1 3 -2)) :updates? nil}] : Same as above without the
conversion of applications of updates to IF-expression form.  
\end{usage}

\item[errors:] No error messages are generated.

\item[notes:] This command roughly corresponds to the $\texttt{IF}\uparrow\vdash$
and $\vdash \texttt{IF} \uparrow$ rules of Chapter~\ref{logic}.
 The \indtt{simplify}, \indtt{record}, and \indtt{assert} commands do a limited
amount of ``if-lifting.''

\end{description}

\prdolsubsection{merge-fnums}{Combine Sequent Formulas}
\begin{description}
\item[syntax:] \texttt{(merge-fnums \carg{fnums})}

\item[effect:] If the sequent is of the form $A_1,\ldots,A_m\vdash
C_1,\ldots, C_n$, and \emph{fnums} picks out the sequent formulas
$A_i$, $A_j$, $C_k$, and $C_l$, then in the resulting sequent, these
formulas are replaced by the single formula $A_i \wedge A_j \supset C_k
\vee C_l$\@.   Presently, this command is mainly useful in defining the
\indtt{generalize} command which needs sequent formulas merged into
one formula so that a universal quantifier can be wrapped around  it.
Applying \texttt{merge-fnums} to a single formula has no effect.  

\begin{usage}{}
\item[\texttt{(merge-fnums (-1 -3 4))}:] Merges and replaces the sequent
formulas numbered \texttt{-1}, \texttt{-3}, and \texttt{4} by a single formula,
namely a consequent formula asserting the implication between the
conjunction of \texttt{-1} and \texttt{-3} and \texttt{4}\@.   
\end{usage}

\item[notes:] The \indttdol{merge-fnums} command is used in defining the
\texttt{generalize} strategy in order to collect together the formulas where
the term to be generalized by a universally quantified variable appears.
\end{description}

\prdolsubsection{prop}{Propositional Simplification}
\begin{description}

\item[syntax:] \texttt{(prop)}

\item[effect:] Carries out propositional simplification on the current
goal returning just those subgoals that are not propositional axioms and
do not have any top-level propositional connectives.  Using \indtt{prop}
indiscriminately could lead to a combinatorial explosion of cases caused
by splitting irrelevant conjunctions.  This in turn could lead to a
number of subgoals requiring identical proofs so \texttt{prop} should be used with some care.  The recursive definition
for \texttt{(prop)} is simply
\begin{alltt}
  (try (flatten) (prop) (try (split)(prop) (skip)))
\end{alltt}

\item[notes:] \indtt{prop} can be used for small-scale propositional
simplification.  For larger formulas, the primitive rule \indtt{bddsimp} which
uses a BDD-based propositional simplifier is usually more efficient.  

The \indtt{prop} rule should almost always be preferred to its strategy version
\texttt{prop\char36}.  
\end{description}

\prsubsection{propax}{Propositional Axioms}
\begin{description}
\item[syntax:] \texttt{(propax)}

\item[effect:] An application of \indtt{propax} either proves the sequent
or behaves like a \texttt{(skip)}.  Invoking \indtt{propax} proves sequents
of the form
\begin{enumerate}
\item $\ldots, \mbox{\sc false}, \ldots \vdash \Delta$,
\item $\Gamma\vdash\ldots, \mbox{\sc true}, \ldots$,
\item $\Gamma\vdash\ldots, t=t, \ldots$, or
\item $\ldots, A, \ldots\vdash\ldots, B, \ldots$, where the
sequent formulas $A$ and $B$ are syntactically equivalent (\ie\
identical upto the renaming of bound variables).
\end{enumerate}
The first two forms are not actually propositional axioms as described
in Chapter~\ref{logic}, but may easily be inferred.  The third form
above is actually an equality rule, but it is useful to group it with
the other propositional steps.  These forms correspond to sequents that
are structurally true, but it might be difficult to notice these forms
in a complicated looking sequent.

\item[usage:] \texttt{(propax)}

\item[errors:] No error messages are generated.

\item[notes:] It is important to note that the \indtt{propax} step is
automatically applied to every sequent that is ever generated in a
proof, so that there is never any need to actively invoke it.  It is
simply included here for the sake of completeness.

\end{description}

\prsubsection{split}{Conjunctive Splitting}
\begin{description}
\item[syntax:] \texttt{(split \optl\ \cargdflt{fnum}{*} \carg{depth})}

\item[effect:] Selects and splits a conjunctive formula in the current
goal sequent based on the information given in \emph{fnum}.  The \texttt{split} command splits every top-level conjunction in the selected
formula so that the resulting formulas are no longer conjunctions.  A
conjunctive formula $A$ in a goal sequent of the form $\Gamma,
A\vdash\Delta$ or $\Gamma\vdash A, \Delta$ is split by collecting lists
of antecedent and consequent formulas by recursively collecting
subformulas of $A$ as follows:
\begin{enumerate}
\item If $A$ is an antecedent formula of the form $B\vee C$, then
collect antecedent formulas $B$ and $C$

\item If $A$ is an antecedent formula of the form $B\supset C$, then
collect antecedent formula $C$ and consequent formula $B$

\item If $A$ is a consequent formula of the form $B\wedge C$, then
collect consequent formulas $B$ and $C$

\item If $A$ is a consequent formula of the form $B\iff C$, then
collect consequent formulas $B\supset C$ and $C\supset B$

\item If $A$ is an antecedent formula of the form $\texttt{IF}(B,C,D)$,
then collect antecedent formulas $B\wedge C$ and $\neg B\wedge D$

\item If $A$ is a consequent formula of the form $\texttt{IF}(B,C,D)$,
then collect consequent formulas $B\supset C$ and
$\neg B\supset D$.
\end{enumerate}
If this process yields the collection of antecedent formulas
$A_1,\ldots, A_m$ and the consequent formulas $B_1,\ldots, B_n$, then the
\indtt{split} command yields the subgoals $\Gamma, A_i\vdash\Delta$ for $0 <
i\leq m$, and $\Gamma\vdash B_j,\Delta$ for $0 < j \leq n$.  When there
is no conjunction in the current sequent as indicated by \texttt{fnum},
then the \indtt{split} rule behaves as a \texttt{(skip)}.

When the \emph{depth} argument is given, the top-level conjuncts are only
split to that given depth.  

\begin{usage}{}
\item[\texttt{(split)}] : (Same as \texttt{(split *)}.)  Yields the subgoals
resulting from splitting the first conjunction found in the current
sequent.  It is not easy to tell which conjunct would be split since a
sequent is internally represented as a list of formulas, but is
displayed in sequent form where the negated formulas appear in the
antecedent part, and the unnegated formulas appear in the consequent
part.  The \texttt{(split +)} and \texttt{(split -)} rules (see below) might
be more appropriate when such a confusion exists.

\item[\texttt{(split +)}] : splits the first consequent conjunctive formula
in the current goal sequent.

\item[\texttt{(split -)}] : splits the first antecedent conjunctive formula
in the current goal sequent.

\item[\texttt{(split -3)}] : splits the formula numbered \texttt{-3} in the
current sequent.

\item[\texttt{(split + :depth 2)}] : splits the top-level consequent conjuncts
to a maximum of two levels.
\end{usage}

\item[errors:] No error messages are generated.

\item[notes:]
\begin{itemize}
\item This command causes branching, so should be used with
caution; otherwise you will find yourself doing essentially the same
proof on many different branches.

\item The \indtt{split} command corresponds to the $\vdash\wedge$,
$\vee\vdash$, $\supset\vdash$, $\texttt{IF}\vdash$, and $\vdash\texttt{IF}$
inference rules given in Chapter~\ref{logic}.  These are all the
inference rules which cause branching.

\item To get the effect of repeatedly applying  \indtt{flatten} and \texttt{split}, use the \indtt{prop} or \indtt{bddsimp} commands.
\end{itemize}
\end{description}

\index{Proof Rules!Propositional|)}

\section{The Quantifier Rules}
\index{Proof Rules!Quantifier|(}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indttdol{detuple-boundvars} & \emph{defined}
  & distribute bound variables over tuple and record types \\\hline
\indttdol{generalize} & \emph{defined}
  & generalize a term by universal quantification \\\hline
\indttdol{generalize-skolem-constants} & \emph{defined}
  & generalize Skolem constants by universal quantification\\\hline
\indttdol{inst} & \emph{defined}
  & instantiate an existentially quantified formula without copying \\\hline
\indttdol{inst-cp} & \emph{defined}
  & copy and instantiate an existentially quantified formula \\\hline
\indttdol{inst?} & \emph{defined}
  & heuristically instantiate an existentially quantified formula \\\hline
\indtt{instantiate} & \emph{primitive}
  & instantiate an existentially quantified formula with a list of terms \\\hline
\indtt{instantiate-one} & \emph{defined}
  & instantiate an existentially quantified formula without duplicating results \\\hline
\indtt{skolem} & \emph{primitive}
  & \emph{Skolemize} a universal formula with specified names\\\hline
\skobangdol & \emph{defined}
  & \emph{Skolemize} a universal formula with generated names \\\hline
\indtt{skolem-typepred} & \emph{primitive}
  & \emph{Skolemize} a universal formula with generated names and include type constraints\\\hline
\indttdol{skosimp} & \emph{defined}
  & \emph{Skolemize} a universal formula with generated names and flatten \\\hline
\indttdol{skosimp*} & \emph{defined}
  & repeatedly \emph{Skolemize} with generated names and flatten \\\hline
\end{tabularx}

\prdolsubsection{detuple-boundvars}{Distribute Bound Variables}
\begin{description}

\item[syntax:] \texttt{(detuple-boundvars \optl\ \cargdflt{fnums}{*}
\carg{singles?})}

\item[effect:] A top-level sequent formula of the form \texttt{(FORALL
(x:\ [S1, S2]):\ g(x))} or \texttt{(FORALL (x:\ [\# s:\ S, t:\ T \#]):\
g(x))} is replaced by \texttt{(FORALL (x1:\ S1), (x2:\ S2):\ g(x1, x2))}
and \texttt{(FORALL (x1:\ S), (x2:\ T)):\ g((\# s := x1, t := x2 \#)))}\@.
This decomposition of tuple and record quantification is needed, for
example, to carry out an induction over one of the components.  Tuple
quantification can be introduced when instantiating parameterized theories
such as the \texttt{function} theory in the prelude.  This command is used
within the \indtt{measure-induct} strategy.

\end{description}


\prdolsubsection{generalize}{Universally Generalize a Term}
\begin{description}

\item[syntax:] \texttt{(generalize \carg{term} \carg{var} \optl\
\carg{type} \carg{fnums}{*} \cargdflt{subterms-only?}{t})}

\item[effect:] If the sequent is of the form
\texttt{a1(t), a2(t) $\vdash$ c1(t), c2(t)}, then applying the
\indtt{generalize} 
term \texttt{t} with variable \texttt{x} yields a sequent of the form
\texttt{$\vdash$ (FORALL x:~(a1(x) AND a2(x)) IMPLIES (c1(x) OR c2(x)))}\@.
More specifically, the \indtt{generalize} command collects together
all the sequent formulas from the given \emph{fnums} containing the
term \emph{term}, applies \indtt{merge-fnums} to obtain a single
formula which is then generalized by replacing  \emph{term}
by a universally quantified variable \emph{var}.

The \emph{type} option is to indicate that the universally quantified
variable should be bound with the given \emph{type}.  This is useful if
the term has a more specific type than is required of the generalization.

The generalization applies only to the subterms that are not within types
or actuals.  If a more sweeping generalization is needed, then the
\emph{subterms-only?}\ flag should be set to \texttt{nil}\@.

\end{description}

\prdolsubsection{generalize-skolem-constants}{Generalize from Skolem Constants}
\begin{description}

\item[syntax:] \texttt{(generalize-skolem-constants \optl\
\cargdflt{fnums}{*})}

\item[effect:] Applies universal generalization to the Skolem constants
that occur in the given \emph{fnums}\@.  Such a step is useful in
rearranging quantifiers by introducing skolem constants and generalizing
them over selected formulas.   

\end{description}

\prdolsubsection{inst}{Instantiate a Formula without Copying}
\begin{description}

\item[syntax:] \texttt{(inst \carg{fnum} \rest\ \carg{terms})}

\item[effect:]  This is simply a convenient form of the \indtt{instantiate}
rule where the quantified formula is not copied and the terms are
given in \rest\ form.

\item[usage:] \texttt{(inst - "a + 3" "\_" "b")}: Instantiates the first
universally quantified antecedent formula with exactly
three bound variables with \texttt{a + 3} for the first bound variable and
\texttt{b} for the third bound variable while leaving the second bound
variable uninstantiated.  
\end{description}

\prdolsubsection{inst-cp}{Copy and Instantiate a Formula}
\begin{description}

\item[syntax:] \texttt{(inst-cp \carg{fnum} \rest\ \carg{terms})}

\item[effect:]  This is simply a convenient form of the \indtt{instantiate}
rule where the quantified formula is copied and the terms are
given in \rest\ form.  
\end{description}

\prdolsubsection{inst?}{Instantiate a Formula by Matching}
\begin{description}

\item[syntax:] \texttt{(inst?~\optl\ \cargdflt{fnums}{*} \carg{subst}
\cargdflt{where}{*} \carg{copy?}\ \carg{if-match} \carg{polarity?}\
\newline \cargdflt{tcc?}{t})}

\item[effect:] This rule extends the capabilities of the \indtt{inst}
rule.  Here the given substitution \emph{subst} is used to select a
quantified formula of existential strength where the quantifier binds all
of the variables in \emph{subst}.  The rule then collects those atomic
subformulas or subterms in this formula that contain free occurrences of
all the outermost existentially quantified variables and tries to find a
match (extending \emph{subst}) for these in the sequent (or as
constrained by the \emph{where} argument).  These pattern subterms of the
quantified formula are collected as successive lists of templates
containing all the quantified variables, all but one of the quantified
variables, and so on.  The templates are essentially collected starting
from the leftmost-outermost one except for implications where the
templates for the conclusion part of the implication precede those from
the hypotheses.

In the default case when \emph{if-match} is \texttt{nil}, the first 
successful match (for all or some of the quantified variables)
for the first template with a successful match is used to generate one 
or more, partial or total instances of the chosen quantified formula.  
If a partial substitution is given but no match is found and \emph{if-match} is \texttt{nil}, then the rule goes ahead and instantiates
using the given partial substitution \emph{subst}.  If \emph{if-match}
is \texttt{t}, then the instantiation only takes place if the matching process
succeeds.  If \emph{if-match} is \texttt{all}, then the command 
returns all possible instantiations for all of the templates in the
first list of templates that yields a successful match.  Note that these
lists of templates are ordered by the number of quantified variables
that occur free in them.    If the \emph{if-match} flag is \texttt{best}, then the command chooses an
instantiation from the \texttt{all} case that generates the
fewest TCCs when typechecked.  If the \emph{if-match} flag is
\texttt{first*}, the command chooses all the instantiations of the first
successful template.

The \emph{polarity?}\ argument can be either \texttt{t} or \texttt{nil}\@.
When this is set to \texttt{t}, the \texttt{inst?}\ command is sensitive
to the polarity with which the patterns occur and it matches these
patterns only against expressions of opposing polarity.  The
polarity-sensitive matching pays attention to both boolean polarity (i.e.,
whether the expression occurs under an even or odd number of negations) as
well as arithmetic polarity (i.e., whether the expression occurs on the
lesser or greater side of an inequality.

If the \emph{tcc?}\ argument is \texttt{nil}, only instantiations that do
not lead to TCCs are selected.  There is no check to see if the TCCs are
true in the given context.

Sometimes a single \indtt{inst?}\ can only find a partial
instantiation where successive invocations of \indtt{inst?}\ 
can succeed in fully instantiating all of the quantified variables.

Note that if a bound variable name contains \texttt{\char36}, it is
sufficient to only give that part of the name preceding \texttt{\char36} in \emph{subst}.  The \emph{copy?}\ argument works exactly as in \indtt{quant} and
is used to retain a copy of the quantified formula.  Note that an
uncopied, quantified formula is automatically hidden.

\item[usage: ] \texttt{(inst?\ -1 ("x" 1) + T)}: Tries to instantiate the
quantified variables in the formula number \texttt{-1} by pattern-matching
against the subexpressions in the consequent formulas using
the given partial substitution where \texttt{x} is instantiated to \texttt{1}.
The first acceptable substitution found by pattern matching is returned.
A copy of the original formula is retained.

\texttt{(inst?\ - :if-match best)}: Tries to instantiate the first universally
quantified antecedent formula by pattern-matching the subexpressions
of this formula against all the formulas in the sequent.  
The best substitution, namely one that generates the fewest TCCs when
typechecked, is returned.

\item[errors: ] {\bf Given Substitution \ldots is not of the form \ldots:}
A substitution 
must be of the form \texttt{(\emph{var} \emph{term} \emph{var} \emph{term} \ldots)}.

{\bf Couldn't find a suitable quantified formula:}  No instantiable
formula found in the range specified by \emph{fnums}.

{\bf Couldn't find a suitable instantiation for any
quantified  formula.  Please provide partial instantiation: }
Pattern-matching was unable to instantiate the quantified variables so
that a further  hint in the form of a partial substitution might be
needed.

{\bf Given substitution \ldots
is not of the form: (<var> <term>...): }  An odd length substitution was
given.

{\bf The supplied terms should not contain free variables:}
Terms in given substitution should not contain free variables.

{\bf The types of the substituted variables contain free occurrences
of the following quantified variables: \ldots :} If the type of one
variable given in a substitution contains another quantified variable,
then that variable must also be instantiated in the substitution.

\end{description}


\prsubsection{instantiate}{Primitive Instantiation}
\begin{description}
\item[syntax:] \texttt{(instantiate \carg{fnum} \carg{terms} \optl\
\carg{copy?})}

\item[effect:] As the sequent calculus rules indicate, the universally
quantified formulas in the antecedent and the existentially quantified
formulas in the consequent are reduced by instantiating the quantified
variables with the terms that are being \emph{existentially
generalized} in the proof.  In an application of the \indtt{instantiate} rule,
\emph{fnum} is used to select the suitable quantified formula that is
either an antecedent formula of the form $(\forall x_1, \ldots, x_n :
A)$ or a consequent formula of the form $(\exists x_1, \ldots, x_n :
A)$.  The argument \emph{terms} provides the list of $n$ terms
$t_1,\ldots, t_n$ so that the chosen quantified formula is replaced by
$A[t_1/x_1,\ldots, t_n/x_n]$ in the generated subgoal.  Note that each
$t_i$ is typechecked to be of the type of $x_i$, and this typechecking
could generate additional goals corresponding to the type correctness
conditions.  As with \indtt{skolem}, it is possible to leave some
of the $x_i$ uninstantiated by supplying \texttt{"\_"} for the
corresponding $t_i$ in the \emph{terms} argument.

When the \emph{copy?}\ parameter is \texttt{t}, then a copy of the
quantified formula is saved in the subgoal sequent so that the
quantifier can be reused.  When the \emph{copy?}\ parameter is \texttt{nil}, the quantified formula is automatically hidden so that the
quantifier can be reused by revealing the hidden formulas using the \texttt{reveal} rule.

\begin{usage}{}

\item[\texttt{(instantiate * ("x + 3" "y - z"))}] : Finds the first formula in the
sequent that is either an antecedent formula of the form $(\forall x_1,
x_2 : A)$, or a consequent formula of the form $(\exists x_1, x_2 : A)$
and replaces this formula with $A[\texttt{x + 3}/x_1, \texttt{y - z}/x_2]$.

\item[\texttt{(instantiate - ("x + 3" "y - z"))}] : Searches for the first suitable
antecedent formula in the current sequent, and has the same effect as
the above invocation of \indtt{instantiate}.

\item[\texttt{(instantiate -3 ("x + 3" "y - z") T)}] :  Has the same
effect as above on the formula numbered \texttt{-3}, but also
makes a copy of the formula numbered \texttt{-3} provided it
is a formula of the form $(\forall x_1, x_2 : A)$.  

\item[\texttt{(instantiate -3 ("x + 3" "y - z") :copy?\ T)}] :  Same as above.
\end{usage}

\item[errors:]
\begin{description}

\item[{\bf No suitable quantified formula found}:] There was no formula
of existential strength in the range given by \emph{fnum} with the same
number of bound variables as the length of the supplied list of \emph{terms}.

\item[{\bf Expecting \ldots\ terms, but \ldots\ terms provided}:]\hfill Wrong
number of terms given in the \emph{terms} argument.

\item[{\bf The supplied terms should not contain free variables}:] There
can be no free variables in a PVS sequent and none are allowed to
sneak in through the \indtt{instantiate} rule.

\item[{\bf The types of the substituted variables contain free occurrences
\ldots}:]  If $x$ and $y$
are both bound by the top quantifier where the type of $y$ contains
free occurrences of $x$, then if the \indtt{instantiate} rule supplies a
substitution for $y$, it must also include a substitution for $x$.
\end{description}
In addition to the above, the \indtt{instantiate} rule can generate parser
and typecheck errors.

\item[notes:] The defined rule \indtt{inst} is generally preferred, as the
terms do not have to be in a list, and it avoids creating instances that
are already in the sequent.  In particular, \texttt{instantiate} is not
suitable for use in recursive strategies as it may simply generate the
same instance repeatedly.   To copy the quantified formula (so that it
may be instantiated with different terms) use the rule \indtt{inst-cp}.
In the related \indtt{inst?}\ rule, if the \emph{terms} argument is
missing then the rule attempts to find a suitable instantiation by
matching selected subterms of $A$ with subterms in the rest of the
sequent.  Note that \indtt{inst?}\ does not always succeed with the right
match.  It typically succeeds when there are very few possible matches.
The \indtt{instantiate} rule captures the $\forall\vdash$ and
$\vdash\exists$ sequent rules.

\end{description}

\prsubsection{instantiate-one}{Instantiate Existential Formula without Duplication}
\begin{description}
\item[syntax:] \texttt{(instantiate-one \carg{fnum} \carg{terms} \optl\
\carg{copy?})}

\item[effect:] Same as \texttt{instantiate}, but behaves as a
\texttt{skip} if the instantiation would yield a formula already in the
sequent.  \texttt{instantiate-one} may be used in \texttt{repeat} in
situations where \texttt{instantiate} would never terminate.
\end{description}

\prsubsection{skolem}{\emph{Skolemize} with Specified Names}
\begin{description}
\item[syntax:] \texttt{(skolem \carg{fnum} \carg{constants} \optl\
\carg{skolem-typepreds?})}

\item[effect:] If the formula in the current sequent indicated by \emph{fnum} is either an antecedent formula of the form $(\exists
x_1,\ldots, x_n : A)$ or a consequent formula of the form $(\forall x_1,
\ldots, x_n : A)$, and \emph{constants} is a list of new identifiers of
the form \texttt{($c_1$ \ldots $c_n$)}, then the \indtt{skolem} rule
generates a subgoal where the indicated formula has been replaced by
$A[c_1/x_1,\ldots, c_n/x_n]$.\footnote{This is slightly inaccurate since
in PVS, the type for the bound variable $x_i$ in $(\forall x_1,
\ldots, x_n : A)$ can contain free occurrences of $x_j$ where $j<i$
which is not reflected by the substitution instance $A[c_1/x_1,\ldots,
c_n/x_n]$.}   When \emph{fnum} is \texttt{*}, then the
first appropriate sequent formula (\ie\ either an antecedent existential
formula or a consequent universal formula binding $n$ variables) is
chosen for quantifier elimination.  The parameter \emph{fnum} can also be
either \texttt{+} or \texttt{-}.  If any of the $c_i$ are given as \texttt{"\_"},
then those bound variables are left alone and no corresponding skolem
constants are introduced.  If \emph{skolem-typepreds?}\ is \texttt{t}, then
typepreds will be introduced for the new constants.

\begin{usage}{}

\item[\texttt{(skolem * ("a3" "b3" "c3"))}] : The first suitable formula in
the sequent with the form $(\forall/\exists x_1, x_2, x_3 : A)$
is replaced by $A[\texttt{a3}/x_1, \texttt{b3}/x_2, \texttt{c3}/x_3]$.  As
mentioned earlier, it is not always easy to determine the first such
suitable formula in the sequent since the displayed sequent only
captures the correct order between and antecedent formulas and between
consequent formula.  The ordering of all formulas is not visible from the
displayed sequent.

\item[\texttt{(skolem - ("a3" "b3" "c3"))}] : Same as above, but for the
first suitable antecedent formula.

\item[\texttt{(skolem -3 ("a3" "b3" "c3"))}] : Same as above, but only for
formula number \texttt{-3} in the current sequent.

\item[\texttt{(skolem - ("a3" "\_" "c3"))}] : Replaces the first antecedent
formula of the form $(\exists x_1, x_2, x_3 : A)$ with $(\exists x_2 :
A)[\texttt{a1}/x_1, \texttt{a3}/x_3]$.

\end{usage}

\item[errors:]

\begin{description}

\item[{\bf No suitable quantified expression found}:] Either there is no
antecedent existentially quantified formula or consequent universally
quantified formula, or the list of skolem constants is of the wrong
length.

\item[{\bf Formula \ldots is not skolemizable}:] The indicated formula in
\emph{fnum} is not of the right form.

\item[{\bf Expecting \ldots skolem constant(s), but \ldots supplied}:]
The number of supplied skolem constants does not correspond to the
number of bound variables in the formula specified by \emph{fnum}.

\item[{\bf The supplied skolem constants must all be new names}:]\hfill
Either a skolem constant given as part of the \emph{constants} argument was
not a name or was already present in the context.

\item[{\bf Duplicate use of skolem constants}:] The list of skolem
constants contained a duplicate.

\item[\textbf{The types of the skolemized variables contain free \ldots}:]
This error is triggered when the top quantifier binds variables $x$ and
$y$ where the type of $y$ contains a free occurrence of $x$.  It is not
legal in this situation to supply a skolem constant for $y$ without
providing one for $x$.
\end{description}

\item[notes:] The \skobang{} rule  automatically
generates skolem constants and is usually an easier alternative to the
\indtt{skolem} rule.  The \indtt{skolem} rule is useful when adopting 
certain conventions about naming skolem constants within proof
strategies.  The \indtt{skolem} rule captures the $\exists\vdash$ and
$\vdash\forall$ sequent rules.  

\end{description}

\prdolsubsection{skolem!}{\emph{Skolemize} with Generated Names}

\begin{description}

\item[syntax:] \texttt{(skolem!\@ \optl\ \cargdflt{fnum}{*}
\carg{keep-underscore?})}

\item[effect:] Automatically generates Skolem names for the \emph{names} argument for the \indtt{skolem} rule.  These names have the
form \texttt{x!$n$} when the bound variable being named is \texttt{x}.  This
rule is a dangerous one to include in defined rules or within an \texttt{apply} rule since the names being generated could change when a proof is
rerun.  
When the \emph{fnum} argument is \texttt{*}, \texttt{+}, or \texttt{-}, the
first Skolemizable formula in this range is selected.
There is a small loss of robustness with the commands
\skobang{}, \indtt{skosimp}, and \indtt{skosimp*} since
any changes in the constants generated due to a change in the
formula or a reordering of proof steps can affect the behavior
of subsequent commands that explicitly mention these constants.

The \emph{keep-underscore?}\ flag when \texttt{t} ensures that
the bound variable \texttt{x\_1} is replaced by a skolem constant
of the form \texttt{x\_1!n} rather than the default \texttt{x!n} for
some number \texttt{n}\@.  
\end{description}

\prdolsubsection{skolem-typepred}{\emph{Skolemize} with Type Constraints}
\begin{description}

\item[syntax:] \texttt{(skolem-typepred  \optl\ \cargdflt{fnum}{*})}

\item[effect:] This is a variant of \indttbang{skolem}
where  the type constraints on the generated
skolem constants are introduced as antecedent formulas. 
\end{description}


\prdolsubsection{skosimp}{\emph{Skolemize} then Flatten}
\begin{description}

\item[syntax:] \texttt{(skosimp \optl\ \cargdflt{fnum}{*} \carg{preds?})}

\item[effect:] This is a short form for \texttt{(then (skolem \emph{fnum})
(flatten))}.  When \texttt{preds?}\ is \texttt{t}, \texttt{skolem-typepred} is used
in place of \texttt{skolem} so that the type constraints on the generated
skolem constants are introduced as antecedent formulas. 
\end{description}


\prdolsubsection{skosimp*}{Repeatedly \emph{Skolemize} then Flatten}
\begin{description}

\item[syntax:] \texttt{(skosimp* \optl\ \carg{preds?})}

\item[effect:] This is a short form for \texttt{(repeat (then (skolem)
(flatten)))}.  As with \texttt{skosimp}, when the \texttt{preds?}\ flag is \texttt{t}, the command \texttt{skolem-typepred} is used in place of \texttt{skolem}\@.
\end{description}


\index{Proof Rules!Quantifier|)}


\section{The Equality Rules}
\index{Proof Rules!Equality|(}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{beta} & \emph{primitive}
  & reduce $\lambda$-, record, tuple, cotuple, update, and datatype redexes\\\hline
\indttdol{case-replace} & \emph{defined}
  & case-split and replace using an equation\\\hline
\indtt{name} & \emph{primitive}
  & introduce a name for an expression\\\hline
\indttdol{name-case-replace} & \emph{defined}
  & replace one expression with another, then rename \\\hline
\indttdol{name-replace} & \emph{defined}
  & replace an expression with a name\\\hline
\indttdol{name-replace*} & \emph{defined}
  & replace expressions with names\\\hline
\indtt{replace} & \emph{primitive}
  & replace using an equation\\\hline
\indtt{replace*} & \emph{primitive}
  & replace using equations\\\hline
\indtt{same-name} & \emph{primitive}
  & equate two constants with distinct but equal actuals\\\hline 
\end{tabularx}

\prsubsection{beta}{Beta Reduce}
\begin{description}
\item[syntax:] \texttt{(beta \optl\ \cargdflt{fnums}{*}
\carg{rewrite-flag} \cargdflt{let-reduce?}{t})}

\item[effect:] The \indtt{beta} rule rewrites certain expressions called
\emph{redexes} to their reduced forms.  The various forms of redexes
and their reduced forms are:
\begin{itemize}

\item $(\lambda x_1 \ldots x_n : e)(t_1,\ldots,t_n)$ reduces to
$e[t_1/x_1,\ldots,t_n/x_n]$.  Note that \texttt{LET} and \texttt{WHERE}
expressions are syntactic sugar for $\lambda$-redexes and will also
be beta-reduced by \texttt{beta}\@.  

\item \texttt{proj}$_i(t_1,\ldots,t_n)$ reduces to $t_i$.

\item $\textit{label}_i(\texttt{(\#} \emph{label}_1 \texttt{:=} t_1, \ldots,
                              \emph{label}_n \texttt{:=} t_n \texttt{\#)})$
reduces to $t_i$.

\item \texttt{out}$_i($\texttt{in}$_i(t))$ reduces to $t$.

\item \texttt{in}$_i($\texttt{out}$_i(t))$ reduces to $t$.

\item $\emph{accessor}_i(\emph{constructor}(t_1,\ldots, t_n))$ reduces
to $t_i$, where \emph{constructor} is an abstract datatype constructor,
and \emph{accessor}$_i$ is an accessor of that constructor.

\item \texttt{CASES $c(t_1,\ldots, t_n)$ OF
               \ldots, $c(x_1,\ldots, x_n)\ : e$,
               \ldots\ ENDCASES\hfill}
reduces to $e[t_1/x_1,\ldots,t_n/x_n]$, where $c$ is a constructor for
some datatype.

\item \texttt{\emph{label}$(r$ WITH [\ldots, \emph{label} := e,\ldots]$)$}
reduces to $e$, provided \texttt{\emph{label} := $e$} is the last
update of \emph{label} in the assignment above.

\item \texttt{$(f$ WITH [\ldots, $(i)$ := $e$, \ldots]$)(j)$} reduces to $e$ if
it can be shown that $i=j$, and the assignments following \texttt{$(i)$ := $e$} do not affect $f(j)$.  If it can be shown using the
decision procedures that none of the updates affect the value of $f$
at $j$, then the expression simply reduces to $f(j)$.

\end{itemize}

The \emph{rewrite-flag} argument is typically omitted.  When its value
is \texttt{lr}, it indicates that only the right-hand side of a formula
that is an equality should be simplified using beta-reduction.
Similarly, if the value of \emph{rewrite-flag} is \texttt{rl}, then only
the left-hand side of any equality is simplified.

The \emph{let-reduce?}\ flag indicates whether \texttt{LET} expressions
should also be reduced.

\begin{usage}{}
\item[\texttt{(beta)}] : Same as \texttt{(beta *)}.  Yields the subgoal obtained
by reducing all of the redexes in the current sequent.

\item[\texttt{(beta +)}] : Reduces all the redexes in the
consequent formulas in the current sequent.

\item[\texttt{(beta (-1 2 3))}] : Reduces all of the redexes in the formulas
numbered \texttt{-1}, \texttt{2}, and \texttt{3} in the current sequent.
\end{usage}

\item[errors:] There are no error messages generated.  If there are no
redexes to be reduced in the given range \emph{fnums}, then the message
\texttt{No suitable redexes found} is generated.

\item[notes:] The commands \indtt{assert} and \indtt{simplify}
also carry out beta-reduction among many other 
simplifications.  
\end{description}

\prdolsubsection{case-replace}{Introduce Equation and Replace}
\begin{description}
\item[syntax:] \texttt{(case-replace \carg{formula} \optl\ \carg{hide?})}

\item[effect:] This is defined as \texttt{(then@ (case \carg{formula})
(replace -1 :hide?\ \carg{hide?}))}.  It case splits on an equality (note
that a non-equality $A$ is interpreted as an equality $A = \mbox{\sc
true}$) and replaces the LHS by the RHS in the rest of the sequent in the
branch where the equality is an antecedent.  The \emph{hide?}\ flag
indicates that the equality should be hidden after the replacement in this
branch.

\item[usage:] \texttt{(case-replace "c = 0")}: Replaces \texttt{c} by
\texttt{0} in the current subgoal and generate a second subgoal with the
proof obligation \texttt{c = 0}\@.

\item[errors: ] This command can generate a parse or type error if the
given \emph{formula} is not well-formed.
\end{description}


\prsubsection{name}{Introduce a Name for an Expression}
\begin{description}
\item[syntax:] \texttt{(name \carg{name} \carg{expr})}

\item[effect:] Yields a subgoal where a formula of the form $\textit{expr}
= \textit{name}$ is added as a new antecedent formula.  This is typically
useful as a step towards generalizing a formula by replacing expressions
with constants (using the \indtt{replace} rule).  The given \emph{name}
must be new.  In addition to the new antecedent, a definition is generated
for the name, which may subsequently be expanded or rewritten.
It is also treated as an \texttt{AUTO\_REWRITE-}, so that it is not
expanded accidentally with the next \texttt{grind}, for example.

\item[usage:] \texttt{(name "d5" "(a + b + c)")} : Introduces the
antecedent formula \texttt{(a + b + c) = d5}.

\item[errors:]  This command can generate a parse or type error
if the given \emph{expr} is not well-formed.

{\bf \ldots is not a symbol:}  The \emph{name} argument must be a symbol.

{\bf \ldots is already declared: } The name argument must be a new name.
\end{description}

\prdolsubsection{name-case-replace}{Replace one Expression by Another,
then Rename}
\begin{description}
\item[syntax:] \texttt{(name-case-replace \carg{expr1} \carg{expr2}
\emph{name})}

\item[effect:]  This command creates the equality \texttt{\emph{expr1} =
\emph{expr2}}, does a \indtt{case-replace} on it, and then does a
\indtt{(name-replace \emph{name} \emph{expr2})}.
\end{description}

\prdolsubsection{name-replace}{Replace an Expression by a Name}
\begin{description}
\item[syntax:] \texttt{(name-replace \carg{name} \carg{expr} \optl\
\cargdflt{hide?}{t})}

\item[effect:]  This command is just the strategy
\texttt{(then@ (name \emph{name} \emph{expr}) (replace -1))}.
It replaces the expression \emph{expr} by \emph{name}
everywhere in the current sequent.  The equality between 
\texttt{name} and \texttt{expr} is hidden by default, unless
\emph{hide?}\ is \texttt{nil}\@. 
\end{description}

\prdolsubsection{name-replace*}{Replace Expressions by Names}
\begin{description}
\item[syntax:] \texttt{(name-replace* \carg{name-and-exprs} \optl\
\cargdflt{hide?}{t})}

\item[effect:]  This command is an iterated form of name-replace.

The \texttt{name-and-exprs} argument must be
of the form \texttt{($\pair{{\it name}_1}$ $\pair{{\it expr}_1}$
\ldots)}\@.  The command 
replaces each ${\it expr}_i$ in the current sequent with the corresponding
${\it name}_i$\@.  
\end{description}


\prsubsection{replace}{Replace using an Equation}
\begin{description}
\item[syntax:] \texttt{(replace \carg{fnum} \optl\ \cargdflt{fnums}{*}
\carg{dir} \carg{hide?}\ \carg{actuals?}\ \carg{dont-delete?})}

\item[effect:] The \texttt{replace} rule is typically used to rewrite some
selection of the formulas in the current sequent using an antecedent
equality formula of the form $l=r$.  The equality formula to be used is
indicated by the \emph{fnum} argument.  The targets of the rewrites are
listed in the \emph{fnums} argument.  When the \emph{direction} argument
is \texttt{rl} (denoting ``right-to-left''), the target occurrences of $r$
in the sequent are rewritten to $l$.  Otherwise, when the \emph{direction}
parameter is different from \texttt{rl}, the target occurrences of $l$ are
rewritten to $r$.  If \emph{fnum} is the number for an antecedent formula
$A$ that is not an equality, then the formula is regarded as an equality
of the form $A = \mbox{\sc true}$.  If \emph{fnum} is the number of a
consequent formula $A$, then the formula is regarded by \indtt{replace} as
an equality of the form $A = \mbox{\sc false}$.  Note that the formula
indicated by \emph{fnum} is unaffected by \indtt{replace}.

When \emph{hide?}\ is \texttt{t}, the formula indicated by \emph{fnum}
that is used for replacement is hidden using the \indtt{hide} command.
When \emph{actuals?}\ is \texttt{t}, the replacement is carried out within
actual parameters of names, including types.  Otherwise, the replacement
only occurs at the expression level.  When the \emph{dont-delete?}\ flag is
\texttt{t}, top-level sequent formulas are not deleted through being
replaced by \texttt{TRUE} or \texttt{FALSE}.

\begin{usage}{}

\item[\texttt{(replace -1)}] : If the formula numbered \texttt{-1} in the
current sequent has the form $l = r$, then this application of the
replace rule generates a subgoal where every occurrence of a term
syntactically equivalent to $l$ is replaced by $r$ in every formula of
the sequent other than in formula number \texttt{-1}.  If the formula
numbered \texttt{-1}, call it $A$, is not an equality, then it is treated
as being an equality of the form $A = \mbox{\sc true}$.

\item[\texttt{(replace -1 (-1 2 3) RL)}] : If the formula numbered \texttt{-1}
in the current sequent has the form $l = r$, then this application of
\indtt{replace} generates a subgoal where all the occurrences of $r$ in
the formulas numbered \texttt{2} and \texttt{3} are replaced by $l$.  Note that
formula number \texttt{-1} remains untouched.

\item[\texttt{(replace 2)}] : Yields the subgoal got by replacing all
occurrences of the formula numbered \texttt{2} in the rest of the current
sequent, by {\sc false}.  Note that in the sequent representation,
it is okay to use the negation of a consequent formula as an assumption.
\end{usage}

\item[errors:]
\begin{description}

\item[{\bf No sequent formula corresponding to \ldots}:] This means that
the \emph{fnum} argument was out of range and did not refer to a
formula in the current sequent.

\item[{\bf \ldots must be $*, +, -,$ an integer, or list of integers}:]
The given \emph{fnums} argument did not meet the
criterion listed in the error message.
\end{description}

\item[notes:] One open issue regarding the \indtt{replace} rule is whether
it is useful to have more refined control over the target occurrences of
the rewrite than is provided by the \emph{fnums} argument.
The defined rule \indtt{case-replace} is used to assume an
equality and apply it in the form of a replacement.  The \indtt{replace}
rule corresponds to the sequent rule {\bf Repl}.  

\end{description}

\prsubsection{replace*}{Replace using Equations}
\begin{description}
\item[syntax:] \texttt{(replace* \rest\ \carg{fnums})}

\item[effect:] Iteratively applies the \texttt{replace} command
to each of the formulas indicated by the numbers in \texttt{fnums}\@.
Unlike \texttt{replace}, only left-to-right replacement is possible
and the formulas used in the replacement cannot be hidden.
\end{description}

\prsubsection{same-name}{Equate Names with Distinct Actuals}
\begin{description}
\item[syntax:] \texttt{(same-name \carg{name1} \carg{name2} \optl\
\carg{type})}

\item[effect:] Two names such as $\texttt{cons[\{i:\ nat | i > 0\}]}$ and
$\texttt{cons[\{i:\ nat | i /= 0\}]}$ can be denotationally equal yet
syntactically distinct.  The command \indtt{same-name} can be used to
introduce an antecedent formula asserting the equality of two such names,
\eg, $\texttt{cons[\{i:\ nat | i > 0\}]} = \texttt{cons[\{i:\ nat | i /=
0\}]}$, while generating the proof obligations required to show that the
actuals coincide.  In the above case, the obligation would be to show that
\texttt{FORALL (i:\ nat):\ i > 0 IFF i /= 0}\@.

The \emph{type} argument can be used to disambiguate the \emph{name}
references in case it has been overloaded.

\item[errors:]
{\bf Argument \ldots is not a name:} Names can have a theory prefix
and/or actuals, but cannot be compound expressions.

{\bf Argument \ldots does not typecheck uniquely:} Need to supply
either theory prefixes and/or actuals for the name, or the \emph{type}
argument to disambiguate the name reference.

{\bf Argument \ldots must have actuals:} It does not make sense to use
\indtt{same-name} unless the names have actuals that can be
demonstrated to be equal.

{\bf Arguments \ldots and \ldots must have identical identifiers:}
Only the actuals can be syntactically different between \emph{name1} and
\emph{name2}\@.
\end{description}
\index{Proof Rules!Equality|)}

\section{Using Definitions and Lemmas}
\index{Proof Rules!Introducing Lemmas|(}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{expand} & \emph{primitive}
  & expand (and simplify) a function definition\\\hline
\indttdol{expand*} & \emph{defined}
  & expand several function definitions\\\hline
\indttdol{forward-chain} & \emph{defined}
  & forward chain on an implication lemma\\\hline
\indttdol{forward-chain*} & \emph{defined}
  & forward chain on a list of lemmas repeatedly\\\hline
\indttdol{forward-chain@} & \emph{defined}
  & forward chain on a list of lemmas until one succeeds \\\hline
\indttdol{forward-chain-theory} & \emph{defined}
  & forward chain on formulas of a theory\\\hline
\indtt{lemma} & \emph{primitive}
  & introduce an axiom, lemma, or definition instance\\\hline
\indttdol{rewrite} & \emph{defined}
  & match and rewrite using a lemma or antecedent \\\hline
\indttdol{rewrite-lemma} & \emph{defined}
  & rewrite using an instance of lemma \\\hline
\indttdol{rewrite-with-fnum} & \emph{defined}
  & rewrite using an antecedent \\\hline
\indttdol{use} & \emph{defined}
  & introduce a lemma and instantiate/reduce \\\hline
\indttdol{use*} & \emph{defined}
  & introduce lemmas and instantiate/reduce \\\hline
\end{tabularx}

\prsubsection{expand}{Expand a Definition}
\begin{description}
\item[syntax:] \texttt{(expand \carg{function-name} \optl\
\cargdflt{fnum}{*} \carg{occurrence} \carg{if-simplifies}
\newline\hspace*{1in}
\carg{assert?})}

\item[effect:] Expands (and simplifies) the definition of \emph{name} at a
given \emph{occurrence}.  If \emph{occurrence} is not given, then all
instances of the definition are expanded.  The \emph{occurrence} is given
as a number $n$ referring to the $n${th} occurrence of the function symbol
counting from the left, or as a list of such numbers.  If the
\emph{if-simplifies} flag is \texttt{t}, then any expansion within a
sequent formula occurs only if the expanded form can be simplified (using
the decision procedures).  The \emph{if-simplifies} flag is needed to
control infinite expansions in case \indtt{expand} is used repeatedly
inside a strategy.  In the default case when \emph{assert?}\ is
\texttt{nil}, \indtt{expand} applies the \indtt{simplify} step with the
default settings to any sequent formula in which a definition is expanded.
When \emph{assert?}\ is \texttt{t}, \indtt{expand} applies the
\indtt{assert} version of \indtt{simplify} to any sequent formulas
affected by definition expansion.  The \emph{assert?}\ flag can also be
\texttt{none} in which case no simplification is applied to the sequent
formula following expansion.

If the \emph{function-name} is more than just an identifier, it is treated
as a pattern, and any unspecified part of the \emph{function-name} is
treated as matching anything.  Thus \texttt{th.foo} will match
\texttt{foo} only if it is from theory \texttt{th}, but will match any
instance or mapping of \texttt{th}.  \texttt{foo[int]} will match any
occurrence of \texttt{foo} of any theory, as long as it has a single
parameter matching \texttt{int}.  The \emph{occurrence} number counts only
the matching instances.

\begin{usage}{}

\item[\texttt{(expand "sum")}] : Expands the definition of \texttt{sum}
throughout the current sequent, whether they simplify or not.  The
resulting expressions are all simplified using decision procedures
and rewriting. 

\item[\texttt{(expand "sum" 1)}] : Expands \texttt{sum} throughout the formula
labeled \texttt{1}.

\item[\texttt{(expand "sum" 1 2)}] : Expands the second occurrence of \texttt{sum} in the formula labeled \texttt{1}.

\item[\texttt{(expand "sum" :if-simplifies t)}] : Expands those occurrences
of \texttt{sum} whose definitions can be simplified by means of the
decision procedures.  This is only relevant in the situation where the
definition is a \indtt{CASES} or \indtt{IF} expression.  The definition
expansion only occurs if such an expression  simplifies to one of
its branches.  


\item[\texttt{(expand "sum" :assert?\ T)}] : Expands \texttt{sum}, but
uses \indtt{assert} instead of \indtt{simplify} in the simplification process. 
\end{usage}

\item[errors:]
{\bf Occurrence \ldots\ must be nil, a positive number or a 
list of positive numbers:} Self-explanatory.

\item[notes:]  Typically, the defined rule \indtt{rewrite} can be used instead of
\indtt{expand} but \indtt{expand} has some advantages:
\begin{itemize}
\item \indtt{expand} is faster, since definitions are simple
(unconditional) equations.

\item \indtt{expand} does not require \emph{name} to be fully resolved;
it can use the occurrence to get the type information needed.

\item \indtt{expand} allows a specific \emph{occurrence}
or occurrences 
of a function symbol to be expanded.

\item \indtt{expand} can rewrite subterms containing variables that are
bound in some superterm, \eg, If $f(x)$ is defined as $g(h(x))$, then
\indtt{expand} would be able to rewrite $(\forall x. f(x) = 0)$ as
$(\forall x. g(h(x)) = 0)$, but \indtt{rewrite} would not.  
\end{itemize}

\end{description}

\prdolsubsection{expand*}{Expand Several Definitions}
\begin{description}
\item[syntax:] \texttt{(expand* \rest\ \carg{names})}

\item[effect:] An iterated version of \texttt{expand} that applies
the \texttt{expand} command to each of a list of function names.

\end{description}

\prdolsubsection{forward-chain}{Forward Chain}
\begin{description}
\item[syntax:] \texttt{(forward-chain \carg{lemma-or-fnum} \optl\
\carg{quiet?})}

\item[effect:] This rule is used to forward chain on the given lemma or
antecedent formula number.  If the given lemma or antecedent formula has
the form $A_1 \wedge \ldots\wedge A_n \supset C$, then this rule tries to
match the formulas $A_i$ against the antecedent formulas of the current
sequent.  If the match succeeds, the corresponding instance of $C$ is
added to the as an antecedent formula to current sequent.  If this
instance of $C$ is already in the current sequent, then the
\indtt{forward-chain} rule looks for other instances of the $A_i$ in the
current sequent.  An \emph{fnum} argument can be either \texttt{-},
\texttt{*}, or an antecedent formula number.  Backtracking messages are
printed unless \emph{quiet?}\ is \texttt{t}.

\end{description}

\prdolsubsection{forward-chain*}{Forward Chain Repeatedly}
\begin{description}
\item[syntax:] \texttt{(forward-chain \rest\ \carg{lemmas-or-fnums})}

\item[effect:] This rule is used to forward chain on the list of lemmas or
antecedent formula numbers (they can be freely mixed).  It 
invokes \indtt{forward-chain} on each element of the list until no more
changes occur.  If any element is successful, it starts over at the
beginning of the list.  Of course, there is no guarantee of termination.
\end{description}

\prdolsubsection{forward-chain@}{Forward Chain on a List}
\begin{description}
\item[syntax:] \texttt{(forward-chain@ \rest\ \carg{lemmas-or-fnums})}

\item[effect:] This rule is used to forward chain on a given list of
lemmas or formula numbers (they may be freely mixed) until one of them
succeeds.

\end{description}

\prdolsubsection{forward-chain-theory}{Forward Chain on a Theory}
\begin{description}
\item[syntax:] \texttt{(forward-chain \carg{theory})}

\item[effect:] This rule is used to forward chain on the lemmas of the
given theory.  It collects lemmas of the form $A_1 \wedge \ldots\wedge A_n
\supset C$ from the specified \emph{theory}, then invokes
\indtt{forward-chain*} to repeatedly forward chain until no more changes
occur.  Of course, it is easy to create lemmas for which forward chaining
will never terminate.

\end{description}

\prsubsection{lemma}{Introduce a Lemma}
\begin{description}
\item[syntax:] \texttt{(lemma \carg{name} \optl\ \carg{subst})}

\item[effect:] This rule introduces an instance of the lemma named \emph{name} corresponding to the substitutions supplied in \emph{subst} as
a new formula in the sequent.  Axioms, assumptions, and function
definitions are also seen as lemmas for the purpose of this rule.  There
can be several forms for the definition of a function.  For example,
there are four possible forms for the definition of a function $f$ such
that $f(x,y)(u)(v)$ is given to be $e$, for some term $e$:
\begin{enumerate}
\item $f(x,y)(u)(v) = e$

\item $f(x,y)(u) = (\lambda v : e)$

\item $f(x,y) = (\lambda u : (\lambda v : e))$

\item $f = (\lambda x, y : (\lambda u : (\lambda v : e)))$
\end{enumerate}
In such a situation, the \indtt{lemma} rule picks the first form if \emph{subst} contains substitutions for $x, y, u$, and $v$, and in general,
it picks the last definition (in the order of presentation above) in
which all the variables in the substitution \emph{subst} occur free in
the definition.

In using the \indtt{lemma} rule, \emph{name} must name a lemma that is
visible in the context of the statement being proved, and \emph{substs}
must be a list of substitutions of the form $(x_1\ t_1\ \ldots\ x_n\
t_n)$.  Let $A$ be the universally closed form of the lemma named \emph{name}, the lemma rule checks that each $x_i$ in \emph{subst} is a
\emph{substitutable} variable in $A$, \ie\ $A$ must have the form
$(\forall y_1,\ldots, y_m : B)$ and $x_i$ is either identical to some
$y_j$ or is substitutable in $B$.  PVS checks that each $t_i$ is
of the type of the corresponding $x_i$ and does not contain any free
variables.  Note that it is possible that there are many possible
instances of lemmas named \emph{name} either because these lemmas come
from different theories that are both visible in the current context or
from different instances of the same parametric theory.  The \indtt{lemma}
rule attempts to resolve such an ambiguity by using the information
given by the substitution \emph{subst}.  If this information is not
enough to unambiguously choose the named lemma, then the lemma name must
be supplied in a more complete form.  The form \emph{identifier[actuals]} for \emph{name} can be used in the case when the
generic theory where  \emph{name} occurs is unique, but the required
instantiation for the parameters of the theory is not obvious from the
context (\ie\ the sequent).  The
form \emph{theoryname.identifier[actuals]} is to be used to further
disambiguate the reference to the lemma.

The lemma rule can generate additional subgoals due to the type
correctness conditions.  As a consequence of the substitution,
this rule can also generate parsing and typechecking errors.

\begin{usage}
{\hspace*{0.2in}Consider the situation where the theory
\texttt{boolean\_props} contains a lemma named \texttt{assoc} stating the
associativity of conjunction, and the theory \texttt{listprops} with a
type parameter \texttt{t} has a lemma also named \texttt{assoc} stating
the associativity of \texttt{append}.  Both associativity lemmas are
stated in terms of the variables \texttt{x}, \texttt{y}, and \texttt{z}.}

\item[\texttt{(lemma "assoc")}] : This generates an error message asserting
that the given name could not be resolved, and behaves like \texttt{(skip)}, otherwise.

\item[\texttt{(lemma "boolean\_props.assoc")}] : Adds the formula
\begin{center}
\texttt{(FORALL x, y, z:\ ((x AND y) AND z) = (x AND (y AND z)))}
\end{center}
to the antecedent of the current sequent.

\item[\texttt{(lemma "assoc" ("x" "TRUE" "z" "FALSE"))}] : Adds the
formula
\begin{center}
\texttt{(FORALL  y:\ ((TRUE AND y) AND FALSE) = (TRUE AND (y AND FALSE)))}
\end{center}
to the ante\-ce\-dent of the current sequent.  Notice that the
substitution has been used to resolve the lemma name.

\item[\texttt{(lemma "assoc" ("x" "true" "z" "false" "y" "A"))}] : Adds the
formula
\begin{center}
\texttt{((TRUE AND A) AND FALSE) = (TRUE AND (A AND FALSE))}
\end{center}
to the antecedent of the current sequent.

\item[\texttt{(lemma "assoc[list[nat]]")}] : Adds the statement of the
associativity of \texttt{append} for lists of natural numbers to the
antecedent of the current sequent.
\end{usage}

\item[errors:]
\begin{description}
\item[{\bf The following are not possible variables \ldots}:]  One of the
expressions in a variable position in the given substitution was not a
name.  Check the substitution to see if it has the form \texttt{($x_1$
$t_1$ \ldots $x_n$ $t_n$)}, where the $x_i$ are all variable names.

\item[{\bf The form of a substitution is \ldots}:] This means that the
substitution argument was a list of odd length and did not have the form
\texttt{($x_1$ $t_1$ \ldots $x_n$ $t_n$)}.

\item[{\bf Irrelevant free variables \ldots in substitution}:] As with
other rules that introduce new expressions into the sequent, no free
variables can be allowed.

\item[{\bf Couldn't find a definition or a lemma named \ldots}:] There
is no lemma or definition with the given name in the current context.
Check the name.

\item[{\bf Unable to resolve \ldots relative to substitution}:] The
given name led to an ambiguity that could not be resolved from the given
substitutions.  Check the name or the substitutions, make the name more
explicit, or provide additional substitutions.
\end{description}

\item[notes:] The defined rules \indtt{rewrite} and \indtt{rewrite-lemma}
employ the \indtt{lemma} and \indtt{replace} rules to apply a lemma as a
rewrite rule.  The 
rules \indtt{rewrite}, \indtt{rewrite-lemma}, and \indtt{expand} are ways to
expand definitions without introducing any new antecedents.

The \indtt{lemma} rule is a form of the Cut rule where one of the
branches has been separately proved.
\end{description}


\prdolsubsection{rewrite}{Match/Rewrite with a Lemma or Antecedent}
\begin{description}

\item[syntax:] \texttt{(rewrite \carg{lemma-or-fnum} \optl\
\cargdflt{fnums}{*} \carg{subst} \cargdflt{target-fnums}{*}
\newline\hspace*{1in}
\cargdflt{dir}{lr} \cargdflt{order}{in} \carg{dont-delete?})}

\item[effect:] The \indtt{rewrite} rule extends \indtt{rewrite-lemma}.  It
tries to automatically determine the required substitutions by matching
the conclusion of the lemma against expressions in the formulas in
\emph{fnums}.  This rule is always to be preferred to
\indtt{rewrite-lemma} since it does the hard work of figuring out the
substitutions.  The \emph{target-fnums} corresponds to the \emph{fnums}
argument of \texttt{rewrite-lemma}.  If the \emph{order} argument is
\texttt{in} (which is the default), then the matching is to be done
inside-out, and if it is \texttt{out}, the matching is done outside in.
When the \emph{dont-delete?}\ flag is \texttt{t}, top-level sequent
formulas are not deleted through being replaced by \texttt{TRUE} or
\texttt{FALSE}.

\item[usage:]
\begin{description}
\item[\texttt{(rewrite "assoc")}: ] Finds and rewrites a single instance of
the lemma \texttt{assoc} throughout the current goal.

\item[\texttt{(rewrite "assoc" +)}: ]  Looks for a matching instantiation for
the lemma \texttt{assoc} in the consequent formulas but rewrites with
this lemma instance throughout the current goal.

\item[\texttt{(rewrite "assoc" + ("x" "A" "z" "B") -)}: ]
Looks for a matching instantiation in the consequent formulas
for the lemma \texttt{assoc} 
that extends the given substitution
but only rewrites with this instance over the antecedent formulas.

\item[\texttt{(rewrite "assoc" :dir RL :order OUT)}:]
Searches for a matching instance of the right-hand side of the
lemma \texttt{assoc} in a leftmost-outermost order and rewrites
the  instance of the right-hand side by the corresponding
instance of the left-hand side.
\end{description}

\item[errors:]
\begin{description}
\item[No resolution for \ldots:] No such lemma was found in the current
context.

\item[Substitution \ldots must be an even length list:] Self-explanatory.

\item[No sequent formulas for \ldots:] The \emph{fnums} argument is
incorrectly given.

\item[No matching instance for \ldots found:] The current goal does not
contain any instances of the rewritable part of the given lemma.
\end{description}

\item[notes:]  It is usually more effective to install a rewrite rule
using \indtt{auto-rewrite} (or its variants) than to use the
\indtt{rewrite} command.  The \indtt{rewrite} command is typically useful when
the rewrite generates a condition or a TCC proof obligation that cannot be
discharged automatically.  
\end{description}


\prdolsubsection{rewrite-lemma}{Match/Rewrite using a Lemma}
\begin{description}
\item[syntax:] \texttt{(rewrite-lemma \carg{lemma} \carg{subst}
\optl\ \cargdflt{fnums}{*} \cargdflt{dir}{lr} \carg{dont-delete?})}

\item[effect:] This is an extension of the \indtt{lemma} rule that carries
out rewriting given the required substitutions.  Here \emph{name} is
either the name for a lemma or a definition that can be used as a rewrite
rule or 
\emph{subst} is a substitution list of the form \texttt{($x_1$ $a_1$
\ldots\ $x_n$ $a_n$)}.  Each $t_i$ must be a term with no free variables,
and each $x_i$ is the identifier for a substitutable variable in \emph{name}, \ie\ one that is either a free variable or is universally
quantified at the block of universal quantifiers at the outermost level
of the formula.  The substitution list must provide substitutions for
all the substitutable variables, otherwise the rule will not carry out a
rewrite.  In the case of definitions of curried operators, this rule
picks the least curried form whose left-hand side includes all the
variables for which substitutions have been provided.  The formula
numbers in \emph{fnums} are the target formulas for where the rewriting
occurs.  The \emph{dir} is either \texttt{lr} (by default) indicate a
left-to-right use of the lemma as a rewrite rule, or \texttt{rl} for a
right-to-left use.  The \indtt{rewrite-lemma} rule also has some
capability of resolving the \emph{name} from the given
substitutions, \ie\ it tries to figure out the theory instance for the
lemma to be used.  When the \emph{dont-delete?}\ flag is \texttt{t},
top-level sequent formulas are not deleted through being replaced by
\texttt{TRUE} or \texttt{FALSE}.

\item[usage:] This command is similar to \indtt{rewrite} except that the
\emph{subst} argument is required and the entire substitution has to be
provided.

\item[notes:] This command is rarely used since the
\indtt{rewrite} command (which is defined in terms of \indtt{rewrite-lemma})
is almost always preferable.

\end{description}

\prdolsubsection{rewrite-with-fnum}{Match/Rewrite using an Antecedent}
\begin{description}

\item[syntax:] \texttt{(rewrite-with-fnum \carg{fnum} \optl\ \carg{subst}
\cargdflt{fnums}{*} \cargdflt{dir}{lr}
\newline\hspace*{1in}
\carg{dont-delete?})}

\item[effect:] Applies the \texttt{rewrite} command to an antecedent
formula indicated by \emph{fnum} which is used as a rewrite rule.  The
input substitution \emph{subst} is used to guide the matching process to
find a match that extends \emph{subst}\@.  The optional \emph{fnums}
argument is used to direct the command to look for matches within the
sequent formulas indicated by \emph{fnums}\@.  When \emph{dir} is
\texttt{lr}, the antecedent formula is used a rewrite rule in the
left-to-right direction, and when it is \texttt{rl}, the rewriting occurs
in the right-to-left direction.  When the \emph{dont-delete?}\ flag is
\texttt{t}, top-level sequent formulas are not deleted through being
replaced by \texttt{TRUE} or \texttt{FALSE}.

\end{description}

\prdolsubsection{use}{Introduce a Lemma and Instantiate/Reduce}
\begin{description}

\item[syntax:] \texttt{(use \carg{lemma} \optl\ \carg{subst}
\cargdflt{if-match}{best} \cargdflt{instantiator}{inst?}\
\newline\hspace*{1in}
\carg{polarity?}\ \carg{let-reduce?})}

\item[effect:] An extension of the \indtt{lemma} command where the formula
introduced is subject to repeated instantiation and beta-reduction using
the specified \emph{instantiator} (default \indtt{inst?})\ and
\indtt{beta} commands.  This is usually an effective alternative to the
\indtt{lemma} command.  The \emph{subst} argument is as in the
\indtt{lemma} command.  The \emph{let-reduce?}\ argument is as for the
\texttt{beta} command, and controls whether \texttt{LET} expressions are
reduced.

The \emph{instantiator} argument allows an instantiator to be provided; it
defaults to \texttt{inst?}, but may be any (user-defined) strategy that
performs instantiation.  The provided instantiator may accept the
\emph{if-match} and \emph{polarity?}\ arguments, which are as in the
\texttt{inst?}\ command.  The possible values for \emph{if-match} are:
\begin{itemize}
\item \texttt{all}: Find all instances of the first matching template in
the formula being instantiated.

\item \texttt{best}: Find the best instance (i.e., one that generates the
fewest TCCs) for the first matching template.

\item \texttt{t}: Ignore the partial substitution given unless some
matching template was found.

\item \texttt{nil}: Apply the partial substitution even if none of the
templates yielded a match.
\end{itemize}
\end{description}

\prdolsubsection{use*}{Introduce Lemmas and Instantiate/Reduce}
\begin{description}

\item[syntax:] \texttt{(use* \rest\ \carg{names})}

\item[effect:]  An iterated form of the \indtt{use} command which
applies \indtt{use} with default arguments to a sequence of lemmas.
\end{description}

\index{Proof Rules!Introducing Lemmas|)}


\section{Using Extensionality}
\index{Proof Rules!Extensionality|(}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indttdol{apply-eta} & \emph{defined}
  & use eta form extensionality \\\hline
\indttdol{apply-extensionality} & \emph{defined}
  & use extensionality to prove equality \\\hline
\indttdol{decompose-equality} & \emph{defined}
  & reduce equality to component equalities \\\hline
\indttdol{eta} & \emph{defined}
  & introduce eta version of extensionality\\\hline
\indtt{extensionality} & \emph{primitive}
  & introduce extensionality axiom scheme\\\hline
\indttdol{replace-eta} & \emph{defined}
  & replace using eta\\\hline
\indttdol{replace-extensionality} & \emph{defined}
  & replace using extensionality \\\hline
\end{tabularx}


\prdolsubsection{apply-eta}{Apply Eta Form of Extensionality}
\begin{description}

\item[syntax:] \texttt{(apply-eta \carg{term} \optl\ \carg{type})}

\item[effect:] This rule is an extension of the \indtt{extensionality}
rule.  Given a succedent in the form of an equation $l = r$, where the
type of $l$ and $r$ has a corresponding extensionality axiom scheme, \texttt{apply-extensionality} will generate a new succedent that is the result
of using \indtt{replace-extensionality} on $l$ and $r$.

\end{description}

\prdolsubsection{apply-extensionality}{Apply Extensionality}
\begin{description}

\item[syntax:] \texttt{(apply-extensionality \optl\ \cargdflt{fnum}{+}
\carg{keep?}\ \carg{hide?})}

\item[effect:] This rule is an extension of the \indtt{extensionality}
rule.  Given a succedent in the form of an equation $l = r$, where the
type of $l$ and $r$ has a corresponding extensionality axiom scheme,
\texttt{apply-extensionality} will generate a new succedent that is the
result of using \indtt{replace-extensionality} on $l$ and $r$.

If the \emph{keep?}\ flag is set to \texttt{t}, the antecedent equality
introduced by this command is retained in the resulting goal sequent.

If the \emph{hide?}\ flag is set to \texttt{t}, the equality formula
to which the apply-extensionality command has been applied, is hidden
in the resulting sequent.  It is more typical to require this formula to
be hidden than not, which means that the default value of \texttt{nil} for this
flag is poorly chosen.  
\end{description}

\prdolsubsection{decompose-equality}{Reduce Equality to Component Equalities}
\begin{description}
\item[syntax:] \texttt{(decompose-equality \optl\ \cargdflt{fnum}{*} \cargdflt{hide?}{t})}

\item[effect:]  Decomposes an antecedent or consequent equality of the
form \texttt{t1 = t2} where the terms are of function, record, tuple, or
a datatype constructor type.  If the terms are of function type,
the decomposition returns the universal quantification
\texttt{(FORALL x:\ t1(x) = t2(x))}\@.  If the terms are of record type, 
the decomposition returns the conjunction of equalities of the individual
fields of the terms.  The decomposition is similar for tuple types.
The decomposition on datatype constructors returns the equalities on the
corresponding accessor fields.  If the equality is on the consequent side,
or is a disequality on the antecedent side, then the
\indtt{decompose-equality} rule is the same as \texttt{apply-extensionality}\@.    
\end{description}

\prdolsubsection{eta}{Introduce Eta Axiom Scheme}
\begin{description}
\item[syntax:] \texttt{(eta \carg{type})}

\item[effect:] This is a variant of the \indtt{extensionality} rule where
the \emph{eta} version of the axiom scheme is introduced as an antecedent
formula.

\item[usage:]
\begin{description}
\item[\texttt{(eta "[nat, nat -> nat]")}: ] Introduces the antecedent formula
\begin{alltt}
 (FORALL (u\_2: [[nat, nat] -> nat]):
         LAMBDA (x\_3: [nat, nat]): u\_2(x\_3) = u\_2)
\end{alltt}

\item[\texttt{(eta "[\# a:\ nat, b:\ int \#]")}: ]  Introduces the antecedent
formula
\begin{alltt}
(FORALL (r\_8: [# a: nat, b: int #]):
  (# a := a(r\_8), b := b(r\_8) #) = r\_8)
\end{alltt}

\item[\texttt{(eta "(cons?[nat])")}] :
Introduces the antecedent formula
\begin{alltt}
(FORALL (cons?_var: (cons?[nat])):
         cons(car(cons?_var), cdr(cons?_var)) = cons?_var)
\end{alltt}
\end{description}
\item[errors:] {\bf No suitable eta formula for given type:}
Self-explanatory. 
\end{description}


\prsubsection{extensionality}{Introduce Extensionality Axiom}
\begin{description}
\item[syntax:] \texttt{(extensionality \carg{type})}

\item[effect:] The \indtt{extensionality} rule is similar to the \texttt{lemma} rule in that it introduces an extensionality axiom for the given
\emph{type} as an antecedent formula.  An extensionality axiom can be
generated corresponding to function, record, and tuple types, and
constructor subtypes of PVS abstract datatypes.

\begin{usage}{}
\item[ \texttt{(extensionality "[nat, nat -> nat]")}] :
Yields a subgoal got by adding an antecedent formula of the form
\begin{alltt}
  (FORALL (f, g: [nat, nat -> nat]) :
      (FORALL (i, j: nat) : f(i,j) = g(i,j))
         IMPLIES f = g)
\end{alltt}
to the current sequent.

\item[\texttt{(extensionality "[nat, int]")}] :
Adds an antecedent formula of the form
\begin{alltt}
  (FORALL (u : [nat, int]), (v : [nat, int]):
      proj\_1(u) = proj\_1(v) AND proj\_2(u) = proj\_2(v)
   IMPLIES u = v)
\end{alltt}

\item[\texttt{(extensionality "[\# a:\ nat, b:\ int \#]")}] :
Adds an antecedent formula of the form
\begin{alltt}
  (FORALL (r : [\# a: nat, b: int \#]),
          (s : [\# a: nat, b: int \#]) :
      a(r) = a(s) AND b(r) = b(s)
   IMPLIES r = s)
\end{alltt}

\item[\texttt{(extensionality "(cons?[nat])")}\footnotemark] :
Adds an antecedent formula of the form
\begin{alltt}
  (FORALL (x: (cons?[nat])), (y: (cons?[nat])) :
      car(x) = car(y) AND cdr(x) = cdr(y)
   IMPLIES x = y)
\end{alltt}
The extensionality rule applied to other constructor subtypes
for PVS datatypes behaves similarly.
\end{usage}
\footnotetext{\texttt{cons?}\ is defined in the PVS prelude; use the
command \emacstt{view-prelude-theory} on the theory \texttt{list\_adt} for its
definition.}

\item[errors:] In addition to parsing and typechecking errors,
the following error messages are generated:
\begin{description}
\item[{\bf The following irrelevant free variables occur in \ldots\ }:] As
with the other rules, no free variables can be introduced into a proof
sequent through a rule application.

\item[{\bf Could not find a suitable extensionality axiom for \ldots\ }:]
This means that there is no extensionality axiom for the given type
expression.

\item[{\bf Could not find ADT extensionality axiom for \ldots\ }:] The
given type was a subtype of a PVS datatype but not a constructor
subtype as is required for generating an extensionality axiom.
\end{description}

\item[notes:] The defined rule \indtt{apply-extensionality} makes it
possible to directly apply the extensionality scheme to show two terms
to be equal.  The defined rule \indtt{replace-extensionality}
uses extensionality to replace one term by another.  
\end{description}

\prdolsubsection{replace-eta}{Replace using Eta}
\begin{description}

\item[syntax:] \texttt{(replace-eta \carg{term} \optl\ \carg{type} \carg{keep?})}

\item[effect:] This rule extends the \indtt{eta} rule.  The eta axiom
scheme is instantiated with the given term, which is then used in
a replace command.  A specific type for term may be specified where
typechecking the term may give rise to ambiguity.

When \emph{keep?}\ is \texttt{t}, the instantiated eta axiom scheme that is
introduced as an antecedent is retained in the goal sequent, and
otherwise, it is discarded.  
\end{description}

\prdolsubsection{replace-extensionality}{Replace using Extensionality}
\begin{description}

\item[syntax:] \texttt{(replace-extensionality \carg{expr1} \carg{expr2}
\optl\ \carg{expected} \carg{keep?})}

\item[effect:] This rule is an extension of the \indtt{extensionality}
rule.  It uses the relevant extensionality axiom scheme to demonstrate
the equality of \emph{expr1} and \emph{expr2} and replaces \emph{expr1} in the sequent with \emph{expr2}.  In some cases, the optional
\emph{expected} type might have to be supplied to resolve any
ambiguities in the typechecking of the given expressions.

When \emph{keep?}\ is \texttt{t}, the extensionality scheme that is
introduced as an antecedent is retained in the goal sequent, and
otherwise, it is discarded.  
\end{description}

\section{Applying Induction}
\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indttdol{induct} & \emph{defined}
  & induct over a variable\\\hline
\indttdol{induct-and-rewrite} & \emph{defined}
  & induct and rewrite\\\hline
\indbang{} & \emph{defined}
  & induct and rewrite with definitions\\\hline
\indttdol{induct-and-simplify} & \emph{defined}
  & induct and rewrite/simplify \\\hline
\indttdol{measure-induct} & \emph{defined}
  & support for measure induction\\\hline
\indttdol{measure-induct+} & \emph{defined}
  & measure induction\\\hline
\indttdol{measure-induct-and-simplify} & \emph{defined}
  & measure induction with simplification\\\hline
\indttdol{name-induct-and-rewrite} & \emph{defined}
  & induct on a named scheme and rewrite\\\hline
\indttdol{rule-induct} & \emph{defined}
  & induction on inductive relation\\\hline
\indttdol{rule-induct-step} & \emph{defined}
  & support for induction on inductive relations\\\hline
\indttdol{simple-induct} & \emph{defined}
  & introduce an instance of an induction scheme\\\hline
\indttdol{simple-measure-induct} & \emph{defined}
  & introduce an instance of a measure induction scheme\\\hline
\end{tabularx}
\prdolsubsection{induct}{Invoke Induction}
\begin{description}

\item[syntax:] \texttt{(induct \carg{var} \optl\ \cargdflt{fnum}{1}
\carg{name})}

\item[effect:] The formula indicated by \emph{fnum} must be a
universally quantified, consequent formula.  The variable name \emph{var} must be quantified at the outermost level of this formula.
As with the substitutions in \indtt{inst?}, it is sufficient to give
that part of the variable name preceding the last \texttt{\_} mark, if there
is one in the bound variable name and it is followed by a number.  The
bound variable must be of type, i.e., must include as a supertype,
\texttt{nat} or a PVS abstract datatype for the induction scheme to be
selected automatically.  The induction scheme corresponding to the
type is then instantiated with an induction predicate constructed
from  the formula \emph{fnum} and the
resulting base and induction subgoals are generated.  The induction
scheme can also be explicitly provided by naming it using the optional
\emph{name} argument.  Typically, this name will have to be fully
instantiated with the actual theory parameters.  Note that
user-supplied induction schemes must have a form similar to the
induction schemes in the prelude or those generated by the abstract
datatype mechanism: \texttt{(FORALL (p:\ pred[T]):\ {\it induction subgoal}
IMPLIES {\it goal})}, where \texttt{p} is to be instantiated
by the induction predicate.

\begin{usage}{}
\item[\texttt{(induct "i")}] :
Given that \texttt{i} is of type \texttt{nat}, and the formula numbered \texttt{1}
has the form \texttt{(FORALL \ldots, i, \ldots: \emph{p}(\ldots, i,
\ldots))},
we get the instantiation of the natural number induction scheme with
the induction predicate \texttt{(LAMBDA i:\ (FORALL \ldots: \emph{p}(\ldots,
i, \ldots)))}\@.  The resulting formula is then beta-reduced and
simplified into the base and induction subcases.  If the type of
\texttt{i} is a subtype of \texttt{nat} such as, say, \texttt{(even?)}, then
the subtype predicate is added to the induction predicate to get
\texttt{(LAMBDA (i:\ nat):\ even?(i) IMPLIES (FORALL \ldots: \emph{p}(\ldots,
i, \ldots)))}\@.  If \texttt{i} has type that is a datatype such as binary trees or
lists, then the induction scheme for that datatype is used by default.

\item[\texttt{(induct "x" :fnum 2 :name "below\_induction[N]")}] :
 Employs the induction scheme named \texttt{below\_induction} and
instantiates it with a predicate taken from the sequent
formula number \texttt{2}\@.  
\end{usage}

\item[errors:]
\begin{description}
\item[{\bf Could not find suitable induction scheme}] : The \texttt{simple-induct} rule invoked by this step failed to find an induction
scheme for the given variable \emph{var}, \emph{fnum}, and \emph{name}\@.  Check that \emph{var} occurs as an outermost universally
quantified variable whose type contains no free occurrences of other bound
variables, and that has a supertype that matches what is required by the
(default or named) induction scheme.

\item[{\bf No formula corresponding to \ldots}] : A bad \emph{fnum} was
given. 
\end{description}


\end{description}

\prdolsubsection{induct-and-rewrite}{Induct then Rewrite}
\begin{description}

\item[syntax:] \texttt{(induct-and-rewrite \carg{var} \optl\
\cargdflt{fnum}{1} \rest\ \carg{rewrites})}

\item[effect:] This command has been superseded by the more general
\indtt{induct-and-simplify} but is retained for backward compatibility.
It employs \indtt{induct} on \emph{variable} and \emph{fnum} to select,
instantiate, and introduce an induction scheme, and then uses the rewrite
rules given in \emph{rewrites} to simplify the resulting base and
induction cases employing \indtt{skosimp*}, \indtt{assert},
\indtt{lift-if}, \indtt{inst?}, and \indtt{bddsimp}\@.

\begin{usage}{}
\item[\texttt{(induct-and-rewrite "x" 1 "append" "reverse")}] :
Introduces an instance of the induction scheme according to variable \texttt{x} obtained by instantiating it with the predicate formed from formula
number \texttt{1}, simplifies the resulting base and induction cases using
skolemization, rewriting, decision procedures, if-lifting, and heuristic
instantiation.

\item[\texttt{(induct-and-rewrite "x" :rewrites ("append" "reverse"))}] :
Same as above.  
\end{usage}

\end{description}

\prdolsubsection{induct-and-rewrite!}{Induct then Rewrite with Definitions}
\index{induct-and-rewrite"!@{\texttt{induct-and-rewrite"!}}|ii}
\begin{description}
\item[syntax:] \texttt{(induct-and-rewrite!\ \carg{var} \optl\ \cargdflt{fnum}{1} \rest\ \carg{rewrites})}

\item[effect:]  This is a variant of \indtt{induct-and-rewrite}
which automatically  uses all the definitions in the given sequent
in its rewriting/simplification.  These definitions are used in
their \texttt{!} form so that explicit definitions are always rewritten
regardless of whether the right-hand sides are simplifiable.
Additional rewrite rules can be given can be give using the
\emph{rewrites} argument.  The usage is similar to
\indtt{induct-and-rewrite}\@.  

\end{description}

\prdolsubsection{induct-and-simplify}{Induct and Rewrite/Simplify}
\begin{description}
\item[syntax:] \texttt{(induct-and-simplify \carg{var} \optl\
\cargdflt{fnum}{1} \carg{name} \cargdflt{defs}{t}
\newline\hspace*{1in}
\cargdflt{if-match}{best} \carg{theories} \carg{rewrites} \carg{exclude}
\cargdflt{instantiator}{inst?})}

\item[effect:] This is an extremely useful proof command for directing
proofs involving induction followed by simplification.  It uses
\indtt{install-rewrites} to install the rewrites in \emph{defs},
\emph{theories} and \emph{rewrites} while excluding those in
\emph{exclude}, invokes the the \indtt{induct} command on \emph{var},
\emph{fnum} and \emph{name} to get the base and induction cases, which are
then simplified by repeated application of \indtt{skosimp*},
\indtt{assert}, \indtt{lift-if}, \indtt{bddsimp}, and the specified
\emph{instantiator} (default \indtt{inst?}) which is controlled by the
\emph{if-match} argument.

The \emph{instantiator} argument allows an instantiator to be provided; it
defaults to \texttt{inst?}, but may be any (user-defined) strategy that
performs instantiation.  The provided instantiator may accept the
\emph{if-match} argument, which is as in the \texttt{inst?}\ command.

\begin{usage}{}
\item[]\texttt{(induct-and-simplify "i" :defs !\ :theories "real\_props"
:rewrites "assoc" :exclude ("div\_times" "add\_div"))}:
If \texttt{i} has type \texttt{nat}, then the natural number induction
scheme is instantiated with a predicate constructed from sequent
formula \texttt{1}, and the resulting cases are simplified using
definitions in the given sequent (unconditionally expanding
explicit definitions), the rewrites in the  prelude theory \texttt{real\_props} but excluding 
\texttt{div\_times} and \texttt{add\_div}, and the rewrite rule \texttt{assoc}.

\item[\texttt{(induct-and-simplify "A" :defs nil :if-match nil)}]:
Inducts according the induction scheme given by the type of \texttt{A}
and then simplifies without rewriting any of the definitions or
rewrite rules, and does not perform any heuristic instantaion.
The \texttt{:if-match} nil option is useful when the heuristic instantiation
fails to find the right quantifier substitutions.
\end{usage}

\end{description}

\prdolsubsection{measure-induct}{Support for Measure Induction}
\begin{description}
\item[syntax:] \texttt{(measure-induct \carg{measure} \carg{vars} \optl\
\cargdflt{fnum}{1} \carg{order}
\newline\hspace*{1in}
\carg{skolem-typepreds?})}

\item[effect:] This is actually a helper command; \texttt{measure-induct+}
is the preferred way to invoke measure induction.  The
\texttt{measure-induct} command takes a \emph{measure} expression and a
list of the \emph{induction} variables \emph{vars} in which the measure is
defined.  These variables must occur universally quantified in the formula
numbered \emph{fnum}.  This list of variables is needed in order to
unambiguously identify those universally quantified variables on which the
measure is defined.  As with \indtt{induct}, the \texttt{measure-induct}
command forms the induction predicate by lambda-abstracting the formula
over the variables given in \emph{vars}.  The measure function is also
obtained by lambda-abstracting the given \emph{measure} over the variables
in \emph{vars}.  The
\texttt{measure\_induction}\index{measure\_induction@{\texttt{measure\_induction}}}
scheme from the prelude is then instantiated with domain type of the
measure, the measure, and the ordering on the range of the measure.  The
well-founded ordering is taken by default to be \texttt{<} on natural
numbers or ordinals unless a different ordering is given through the
\emph{order} argument.  The \indtt{lemma} rule is used to introduce the
measure induction scheme instantiated with the selected induction
predicate.  The work so far is actually carried out by the
\indtt{simple-measure-induct} proof step.  The \indtt{measure-induct} step
then beta-reduces, simplifies, and instantiates the measure induction
lemma to discharge the goal sequent and in the process generates an
induction subgoal consisting of an antecedent induction hypothesis and a
consequent induction conclusion.  If \emph{skolem-typepreds?}\ is \emph{t},
then typepreds are introduced for any introduced skolem constants.

The problem with \texttt{measure-induct} is that the arrangement of
quantifiers in the induction hypothesis is unhelpful.  If the formula
numbered \emph{fnum} has the form \texttt{(FORALL x, w:\ p(x, w))} where
the induction variable is \texttt{x} and the measure is \texttt{m}, the
induction predicate is \texttt{(LAMBDA x:\ (FORALL w:\ p(x, w)))}, and the
resulting induction hypothesis has the form \texttt{(FORALL x:\ m(x) <
m(c) IMPLIES (FORALL w:\ p(x, w)))}.  This form nests the universal
quantification on \texttt{w} which might be useful in guiding the
instantiation of \texttt{x}\@.  Therefore a more useful form of the
induction hypothesis is with quantification rearranged as \texttt{(FORALL
x, w:\ m(x) < m(c) IMPLIES p(x, w))}\@.  This rearrangement is carried out
by \indtt{measure-induct+}\@.  See \indtt{measure-induct+} for usage.

\end{description}

\prdolsubsection{measure-induct+}{Measure Induction}
\begin{description}
\item[syntax:] \texttt{(measure-induct+ \carg{measure} \carg{vars} \optl\
\cargdflt{fnum}{1} \carg{order}
\newline\hspace*{1in}
\carg{skolem-typepred?})}

\item[effect:] This is the preferred way to invoke measure induction.  The
\texttt{measure-induct+} command takes a \emph{measure} expression and a
list of the \emph{induction} variables \emph{vars} in which the measure is
defined.  These variables must occur universally quantified in the formula
numbered \emph{fnum}.  The \indtt{measure-induct+} command invokes
\indtt{measure-induct} to introduce the measure induction scheme
instantiated with the selected induction predicate, and then to
beta-reduce, simplify, and instantiate the measure induction lemma to
discharge the goal sequent and in the process generates an induction
subgoal consisting of an antecedent induction hypothesis and a consequent
induction conclusion.  The well-founded ordering is taken by default to be
\texttt{<} on natural numbers or ordinals unless a different ordering is
given through the \emph{order} argument.  If \emph{skolem-typepreds?}\ is
\texttt{t}, then typepreds are introduced for any introduced skolem
constants.

The problem with \indtt{measure-induct} is that the arrangement of
quantifiers in the induction hypothesis is unhelpful.  If the formula
numbered \emph{fnum} has the form \texttt{(FORALL x, w:\ p(x, w))} where
the induction variable is \texttt{x} and the measure is \texttt{m}, the
induction predicate is \texttt{(LAMBDA x:\ (FORALL w:\ p(x, w)))}, and the
resulting induction hypothesis has the form \texttt{(FORALL x:\ m(x) <
m(c) IMPLIES (FORALL w:\ p(x, w)))}.  This form nests the universal
quantification on \texttt{w} which might be useful in guiding the
instantiation of \texttt{x}\@.  A more useful form of the induction
hypothesis is with quantification rearranged as \texttt{(FORALL x, w:\
m(x) < m(c) IMPLIES p(x, w))}\@.  This rearrangement is carried out by
\indtt{measure-induct+}\@.  The command
\indtt{measure-induct-and-simplify} is similar to
\indtt{induct-and-simplify} but uses \texttt{measure-induct+} instead of
\indtt{induct}.

\begin{usage}{}
\item[\texttt{(measure-induct+ "length(x) + length(y)" ("x" "y") 2)}]:
Applies the instance 
of measure induction with measure \texttt{length(x) + length(y)} on the
universally quantified variables \texttt{x} and \texttt{y} in the formula
numbered \texttt{2} to return a goal with an induction conclusion and an
induction hypothesis.

\item[\texttt{(measure-induct+ "m(x)" "x" :order "smaller?")}]:
Applies measure induction on the measure \texttt{m(x)} in the
universally quantified variable \texttt{x} and the well-founded ordering
relation \texttt{smaller?}\ on the range of \texttt{m}\@.  Note that this will
generate a TCC subgoal where the well-foundedness of the ordering relation
has to be established. 
\end{usage}

\end{description}

\prdolsubsection{measure-induct-and-simplify}{Measure Induct and Simplify}
\begin{description}
\item[syntax:] \texttt{(measure-induct-and-simplify \carg{measure}
\carg{vars} \optl\ \cargdflt{fnum}{1} \carg{order}
\newline\hspace*{1in}
\carg{expand}
\cargdflt{defs}{t} \cargdflt{if-match}{best} \carg{theories}
\carg{rewrites} \carg{exclude}
\newline\hspace*{1in}
\cargdflt{instantiator}{inst?}\
\carg{skolem-typepreds?})}

\item[effect:] Invokes the appropriate instance of measure induction using
\indtt{measure-induct+}, skolemizes the resulting induction conclusion,
and expands the definitions listed in the \emph{expand} argument to then
generate the corresponding cases.  The resulting subgoals are then
simplified and the induction hypothesis is instantiated by the
\emph{instantiator} (default \texttt{inst?}) and each subgoal is subject
to further propositional splitting and simplification based on rewriting
and decision procedures.  This command is very similar to
\indtt{induct-and-simplify} but employs measure induction and uses the
\emph{expand} argument to guide the case analysis.  If multiple instances
of the induction hypothesis are needed, the \emph{if-match} argument can
be given as \texttt{first*} to obtain all instances of the first matching
template in the quantified formula, or \texttt{all} to obtain all matches
for all templates.  If \emph{skolem-typepreds?}\ is \emph{t}, then
typepreds are introduced for any introduced skolem constants.

The \emph{instantiator} argument allows an instantiator to be provided; it
defaults to \texttt{inst?}, but may be any (user-defined) strategy that
performs instantiation.  The provided instantiator may accept the
\emph{if-match} argument, which is as in the \texttt{inst?}\ command.

\begin{usage}{}
\item[]\texttt{(measure-induct-and-simplify "length(x) + length(y)" ("x" "y")
\newline :expand "merge" :theories "merge\_sort")}:
This command could for instance be used to try to prove that the merge of
two ordered lists is ordered.  It invokes measure induction on the
sum of the lengths of the two lists, then expands the definition
of \texttt{merge}, and then repeatedly simplifies, instantiates, and rewrites
(using the theory \texttt{merge\_sort}.

\item[]\texttt{(measure-induct-and-simplify "length(x) + length(y)" ("x"
"y") \newline :expand "quicksort" :if-match first* :theories
"quicksort")}: \newline Since there are multiple recursive calls in the
recursive case of \texttt{quicksort}, the \texttt{first*} option to
\emph{if-match} is used.
\end{usage}

\end{description}

\prdolsubsection{name-induct-and-rewrite}{Induct on a Named Scheme and Rewrite}
\begin{description}
\item[syntax:] \texttt{(name-induct-and-rewrite \carg{var} \optl\
\cargdflt{fnum}{1} \carg{name}
\newline\hspace*{1in}
\rest\ \carg{rewrites})}

\item[effect:]  Subsumed by \indtt{induct-and-simplify}.
This command was a variant of a \texttt{induct-and-rewrite} that could
be told to use a particular induction scheme using the \emph{name}
argument.   

\end{description}

\prdolsubsection{rule-induct}{Induct on a (Co)Inductive Relation}
\begin{description}
\item[syntax:] \texttt{(rule-induct \carg{rel} \optl\ \cargdflt{fnum}{*}
\carg{name})}

\item[effect:] Applies the induction scheme given by an inductive relation
\emph{rel} to a sequent of one of the forms $$ \ldots \vdash (\forall x_1,
\ldots, x_n: {\it rel}(x_1, \ldots, x_n) \supset \ldots)$$ or, $$ \ldots,
{\it rel}(c_1, \ldots, c_n), \ldots \vdash \ldots$$, or applies the
coinduction scheme given by a coinductive relation \emph{rel} to a sequent
of one of the forms $$ \ldots \vdash (\forall x_1, \ldots, x_n: \ldots
\supset {\it rel}(x_1, \ldots, x_n))$$ or, $$ \ldots \vdash \ldots, {\it
rel}(c_1, \ldots, c_n), \ldots$$ The generated (co)induction schemes
corresponding to a (co)inductive relation \emph{rel} are
\texttt{\emph{rel}\_weak\_induction} and \texttt{\emph{rel}\_induction}
(or \texttt{\emph{rel}\_weak\_coinduction} and
\texttt{\emph{rel}\_coinduction}).

This command applies repeated skolemization and flattening to the
specified \emph{fnum} (or the first positive, skolemizable consequent or
negative, skolemizable antecedent) before invoking the command
\indtt{rule-induct-step} on the resulting subgoal.  The strategy uses the
weak induction scheme by default but can be told to use strong induction
by supplying \texttt{\emph{rel}\_induction} (or
\texttt{\emph{rel}\_coinduction}) as the \emph{name} argument.

\end{description}

\prdolsubsection{rule-induct-step}{Support for Rule (Co)Induction}
\begin{description}
\item[syntax:] \texttt{(rule-induct-step \carg{rel} \optl\
\cargdflt{fnum}{-} \carg{name})}

\item[effect:] Subsumed by \indtt{rule-induct}.  Applies the (co)induction
scheme given by a (co)inductive relation \emph{rel} to a sequent of the form:
$$ \ldots, {\it rel}(c_1, \ldots, c_n), \ldots \vdash \ldots$$
or
$$ \ldots \vdash \ldots, {\it rel}(c_1, \ldots, c_n), \ldots$$

Searches for a sequent formula of the form ${\it rel}(c_1,\ldots, c_n)$
but this formula can also be given explicitly as \emph{fnum}.  The
(co)induction predicate is formulated using all the sequent formulas
containing the constants $c_1$ to $c_n$\@.  The strategy uses the weak
induction scheme by default but can be told to use strong induction by
supplying \texttt{\emph{rel}\_induction}
(\texttt{\emph{rel}\_coinduction}) as the \emph{name} argument.

\end{description}

\prdolsubsection{simple-induct}{Introduce Induction Scheme}
\begin{description}
\item[syntax:] \texttt{(simple-induct \carg{var} \carg{fmla} \optl\
\carg{name})}

\item[effect:]  Subsumed by \indtt{rule-induct}\@.  
Applies the induction scheme given by an inductive
relation \emph{rel} to a sequent of the form:
$$ \ldots, {\it rel}(c_1, \ldots, c_n), \ldots \vdash \ldots$$

Searches for an antecedent formula of the form ${\it rel}(c_1,\ldots,
c_n)$ but this formula can also be given explicitly as \emph{fnum}.  The
induction predicate is formulated using all the sequent formulas
containing the constants $c_1$ to $c_n$\@.  The strategy uses the weak
induction scheme by default but can be told to use strong induction by
supplying \texttt{\emph{rel}\_induction} as the \emph{induction}
argument.

\end{description}

\prdolsubsection{simple-measure-induct}{Introduce Measure Induction Scheme}
\begin{description}
\item[syntax:] \texttt{(simple-measure-induct \carg{measure} \carg{vars} \optl\
\cargdflt{fnum}{1} \carg{order})}

\item[effect:]  Selects and insert as an antecedent, an instance of measure
induction with measure \emph{measure} containing only free variables from
\emph{vars} using formula \emph{fnum} to formulate an induction predicate.
Uses \emph{order} as the well-founded relation.  If the order is not
specified, it defaults to the \texttt{<} relation on nats or ordinals.

\item[usage:] \texttt{(simple-measure-induct "i+j" ("i" "j"))}:
Inserts measure induction on the measure \texttt{i + j} in the variables \texttt{i} and \texttt{j}\@.  

\end{description}


\section{Simplification with Decision Procedures and Rewriting}

The commands here are very powerful, but the names are not very intuitive,
and the term ``simplification'' is overloaded.  The \indtt{simplify}
command is the basis for most of the automation in the prover.  The
\indtt{assert}, \indtt{do-rewrite}, and \indtt{record} commands are simply
invocations of \indtt{simplify} with particular parameters.  The following
table give an idea of the relationship between the progressively more
powerful commands.

\begin{center}
\begin{tabular}{|l|l|}\hline
\textbf{Command} & \textbf{Added Commands}\\ \hline\hline
\indtt{smash} & \indtt{bddsimp}, \indtt{assert}, \indtt{lift-if}\\ \hline
\indtt{bash} & \indtt{inst?}, \indtt{skolem-typepred}, \indtt{flatten}\\ \hline
\indtt{reduce} & \indtt{replace*}\\ \hline
\indtt{grind} & \indtt{install-rewrites}\\ \hline
\end{tabular}
\end{center}

Each command in the left column includes all the added commands of the
commands above it, though the actual invocation and control of these may
be very different.  For example, though \indtt{grind} invokes
\indtt{reduce} directly, beforehand it invokes \indtt{bddsimp},
\indtt{assert}, and \indtt{replace*}.  And \indtt{bash} is defined
independently of \indtt{smash}.

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indttdol{assert} & \emph{defined}
  & use decision procedures to simplify sequent formulas \\\hline
\indttdol{bash} & \emph{defined}
  & \indtt{smash} with quantifier heuristics \\\hline
\indttdol{both-sides} & \emph{defined}
  & apply an operation to both sides of an inequality chain \\\hline
\indtt{decide} & \emph{primitive}
  & run decision procedures without simplification\\\hline
\indttdol{do-rewrite} & \emph{defined}
  & apply installed automatic rewrites\\\hline
\indttdol{grind} & \emph{defined}
  & install rewrites and repeatedly \indtt{reduce} \\\hline
\indttdol{grind-with-ext} & \emph{defined}
  & \indtt{grind} with \indtt{apply-extensionality} \\\hline
\indttdol{grind-with-lemmas} & \emph{defined}
  & \texttt{grind} using lemmas \\\hline
\indttdol{ground} & \emph{defined}
  & propositional and ground simplification \\\hline
\indttdol{lazy-grind} & \emph{defined}
  & \texttt{grind} postponing instantiations \\\hline
\indttdol{record} & \emph{defined}
  & record assumptions for the decision procedures\\\hline
\indttdol{reduce} & \emph{defined}
  & \indtt{bash} repeatedly with replacements\\\hline
\indttdol{reduce-with-ext} & \emph{defined}
  & \indtt{reduce} with extensionality\\\hline
\indtt{simplify} & \emph{primitive}
  & Boolean simplification using decision procedures\\\hline
\indttdol{simplify-with-rewrites} & \emph{defined}
  & install rewrites, simplify, and stop rewrites\\\hline
\indttdol{smash} & \emph{defined}
  & propositional and ground simplification with IF-lifting\\\hline
\end{tabularx}

\prsubsection{assert}{Simplify Using Decision Procedures}

\begin{description}

\item[syntax:] \texttt{(assert \optl\ \cargdflt{fnums}{*}
\carg{rewrite-flag} \carg{flush?}\ \carg{linear?}\ \carg{cases-rewrite?}\
\newline\hspace*{1in}
\cargdflt{type-constraints?}{t} \carg{ignore-prover-output?}\ 
\carg{let-reduce?}\
\newline\hspace*{1in}
\carg{quant-simp?} \carg{implicit-typepreds?})}

\item[effect:] The \indtt{assert} rule is a combination of \indtt{record},
\indtt{simplify}, \indtt{beta}, and \indtt{do-rewrite}.  The use of
decision procedures for equalities and linear inequalities is perhaps the
most significant and pervasive part of PVS@.  These procedures are
invoked to prove trivial theorems, to simplify complex expressions
(particularly definitions), and even to perform matching.  These decision
procedures, originally due to Shostak, employ congruence closure for
equality reasoning, and they also perform linear arithmetic reasoning over
the natural numbers and reals.  They deal solely with \emph{ground}
formulas, namely those that contain no quantifiers.  While they primarily
deal with linear arithmetic, \ie\ expressions of the form \texttt{2*x +
3*y <= 4*z}, there are some modest extensions for dealing with expressions
involving nonlinear subterms using simplifications such as \texttt{(x +
y)*(x - y) = (x*x - y*y)} and simplifications involving division such as
\texttt{x*(y/x) = y}.

The assert rule employs the decision procedures to either simplify
formulas or to assert the formula to the data-structures employed by the
decision procedures.  The assert rule can have one of three effects for
a given formula named in \emph{fnums}:
\begin{enumerate}

\item It can have no visible effect on the formula but could have
asserted the formula to the congruence closure data-structures
employed by the decision procedures.  Antecedent formulas are recorded
as being true, and consequent formulas are recorded as being false.
only those formulas that do not contain branching (\texttt{if} or \texttt{cases}) or propositional structure (unless they are within a
quantifier or a \texttt{lambda} binding) are asserted into the database
since such structures are likely to need further simplification before
they can be processed by the decision procedures.
Unless the \emph{type-constraints?}\ is set to \texttt{nil},  any subtype
constraints on subexpressions of the formulas processed by \texttt{assert} are also automatically recorded by the decision procedures for
the commands \indtt{assert}, \indtt{record}, \indtt{simplify}, and \texttt{do-rewrite}.  The new assertions in the data-structures remain valid
for any descendant proof node of the current sequent and are
automatically employed when assert is invoked at the lower nodes.

\item If the decision procedures succeed in demonstrating a
contradiction from the formula as asserted, then the entire sequent is
regarded as being proved.  If there are no assertable or simplifiable
formulas among those listed in \emph{fnums}, then the rule behaves as a
\texttt{(skip)}.  In every remaining case, a subgoal is generated.

 \item It can simplify the formula by carrying out boolean
simplification, simplify \texttt{if}-expressions by attempting to
reducing the condition part to {\sc true} or to {\sc false}, and
rewrite expressions using the rewrite rules provided by the \texttt{auto-rewrite} and \indtt{auto-rewrite-theory} rules below (see \texttt{do-rewrite}).  In order for any automatic rewrites to take effect, it
must be the case that the conditions of the instance of the rewrite
rule should all simplify to {\sc true}, as should any type correctness
conditions generated by typechecking an instantiating term with
respect to the type of the variable that it instantiates.
As a simple check to prevent such rewrites from looping,
if a rewrite rule rewrites $l$ to $r$ and $r$ is either a \texttt{cases}
or an \texttt{if} 
expression, then the top-most conditional of these expressions
is treated as if it were another condition in a conditional rewrite
rule.  In other words, if $r$ is of the form \texttt{if a then b else c
endif}, then $a$ must simplify to \texttt{true} or \texttt{false}, and
similarly, if $r$ has the form \texttt{cases e of $p_1$ : $c_1$, \ldots
endcases} then $e$ should match one of the patterns $p_i$.  
The simplifications carried out by \indtt{assert} also include various
obvious datatype simplifications and all of the beta-reductions.  the
resulting simplified formula, if suitable, is asserted to the
data-structures.
\end{enumerate}

When the \emph{rewrite-flag} is \texttt{lr}, only the right-hand side of
any equality formula is simplified since simplifying the left-hand side of
a formula to be used by \indtt{replace} in the process of rewriting (see
strategies \indtt{rewrite} and \indtt{rewrite-lemma} below) could cause
the replace to fail.  correspondingly, when the \emph{rewrite-flag} is
\texttt{rl}, only the left-hand side of an equality formula is rewritten.
If the \emph{flush?}\ argument is \texttt{t}, then the existing database
used by the decision procedures is flushed.  This database can get fairly
large in the course of a proof thereby decreasing the efficiency of the
assert rule.  The \emph{flush?}\ flag should be used with caution.  The
decision procedures apply a modest amount of non-linear arithmetic
simplification to multiplication and division expressions.  This can
sometimes get in the way.  the \emph{linear?}\ argument can be set to
\texttt{t} in order to prevent such simplifications.

The \texttt{cases-rewrite?}\ must be set to \texttt{t} in order for
simplification to occur within a branch of a CASES-expression.

The \texttt{type-constraints?}\ flag must be set to \texttt{nil} to
avoid asserting subtype constraints of subexpressions occurring in the
sequent.  If there are several large expressions with subtype constraints,
this phase of simplification can be quite slow.

The ground prover when confronted with a non-convex assertion returns a
disjunction of assertions that are equivalent to the input assertion.  The
simplification commands examine these outputs to see if every path through
them yields a contradiction.  This step can in some cases be expensive.
To avoid the examination of the ground prover outputs the
\texttt{ignore-prover-output?}\ flag can be set to \texttt{nil}.

The \emph{let-reduce?}\ flag indicates whether \texttt{LET} expressions
should also be reduced.

The \emph{quant-simp?}\ flag indicates that quantifier expressions of the
form, for example, \texttt{EXISTS x: x = a AND P(x)} or \texttt{FORALL y:
y = a IMPLIES P(y)} should be simplified to \texttt{P(a)}.  This is not
always desirable because type information may be lost, and the quantified
formula may be useful for doing induction.



\begin{usage}{}

\item[\texttt{(assert)}] : Same as \texttt{(assert *)}.  proves, simplifies, or
asserts all of the formulas in the sequent employing the decision
procedures.

\item[\texttt{(assert -1 lr)}] : Simplifies the right-hand side of the first
antecedent formula, since the \emph{rewrite-flag} is set to \texttt{lr}
(meaning ``left-to-right'').

\item[\texttt{(assert (-1 3 4))}] : Proves, simplifies, or asserts the
formulas numbered \texttt{-1}, \texttt{3}, and \texttt{4} in the sequent.

\item[\texttt{(assert + :flush?\ t)}] : Flushes the existing database of
assertions and asserts the consequent formulas in the current sequent.
\end{usage}

\item[errors:] No error messages are generated.

\item[notes:] One significant point about \indtt{assert} is that it can be sensitive to
the order in which the formulas are asserted.  It is sometimes necessary
to apply \indtt{assert} more than once in order to obtain the desired
effect.  For example, if the formula $a$ is asserted before the formula
$b$, but $b$ is used to simplify $a$, then \indtt{assert} would have to be
reapplied in order to effect this simplification.  Another reason that
\indtt{assert} might need to be repeated is that the subtype constraints
on subexpressions of a formula are silently collected recorded after
\indtt{assert} has processed the formula.  Simplifications
that rely on these constraints can be missed in the first pass of \texttt{assert}.  

Another point about the \indtt{assert} rule is that is that from the
point of view of the control mechanism used for strategies, \texttt{assert} almost always succeeds so that a strategy like \texttt{(repeat
(assert))} is certain to get into an infinite loop.  The typical way
to get around this is to have \indtt{assert} follow some other step \emph{step1} that is guaranteed to not repeat indefinitely, as in:
\begin{alltt}
       (repeat (try \emph{step1} (assert) (skip)))
\end{alltt}
The \indtt{try} strategy ensures that the \indtt{assert} step is invoked
on the subgoals generated by  \emph{step1}.

\end{description}

\prdolsubsection{bash}{\texttt{smash} with Quantifier Heuristics}

\begin{description}
\item[syntax:] \texttt{(bash \optl\ \cargdflt{if-match}{t}
\cargdflt{updates?}{t} \carg{polarity?}\ \cargdflt{instantiator}{inst?}
\newline\hspace*{1in}
\cargdflt{let-reduce?}{t} \carg{quant-simp?})}

\item[effect:] This command executes \indtt{assert}, \indtt{bddsimp}, the
\emph{instantiator} (default \indtt{inst?}), \indtt{skolem-typepred},
\indtt{flatten}, and \indtt{lift-if}, in that order.  This command is the
core of the \indtt{reduce} command which in turn is the workhorse of
\indtt{grind}.

The \emph{instantiator} argument allows an instantiator to be provided; it
defaults to \texttt{inst?}, but may be any (user-defined) strategy that
performs instantiation.  The provided instantiator may accept the
\emph{if-match} and \emph{polarity?}\ arguments, which are as in the
\texttt{inst?}\ command.  Thus the \emph{if-match} option can be
\texttt{nil}, \texttt{t}, \texttt{all}, or \texttt{best} for no, some,
all, or the best instantiation, respectively.  Note that the
\emph{instantiator} precedes \indtt{skolem-typepred}, so that matches that
are in the original sequent are preferred to those that are exposed by
Skolemization.  This has the drawback that quite often, it is better to
instantiate following Skolemization.  To avoid eager instantiation, set
\emph{if-match} to \texttt{nil}.

If the \emph{updates?}\ option is \texttt{nil}, update applications are not
if-lifted.

When the \emph{polarity?}\ flag is \texttt{t}, the \indtt{inst?}\ command
matches templates against complementary subexpressions.

The \emph{let-reduce?}\ flag indicates whether \texttt{LET} expressions
should also be reduced.

The \emph{quant-simp?}\ flag indicates that quantifier expressions of the
form, for example, \texttt{EXISTS x: x = a AND P(x)} or \texttt{FORALL y:
y = a IMPLIES P(y)} should be simplified to \texttt{P(a)}.  This is not
always desirable because type information may be lost, and the quantified
formula may be useful for doing induction.

\end{description}

\prdolsubsection{both-sides}{Apply Operation to Both Sides of Inequality}

\begin{description}
\item[syntax:] \texttt{(both-sides \carg{op} \carg{term} \optl\
\cargdflt{fnum}{1})}

\item[effect:] Here \emph{fnum} is used to find a chained conjunction of
inequalities of the form \texttt{e1 <= e2 AND e2 <= e3 AND e3 <= e4}.  If
the \emph{term} argument is \texttt{t}, the command replaces the above
chain with \texttt{e1 op t <= e2 op t AND e2 op t <= e3 op t AND e3 op t
<= e4 op t}.  If the equivalence between this chain and the previous one
doesn't simplify to \texttt{TRUE} using \indtt{assert} and
\indtt{do-rewrite} with respect to the prelude theory
\texttt{real\_props}, then a proof obligation is generated.
\end{description}

\prsubsection{decide}{Decide without Simplification}

\begin{description}
\item[syntax:] \texttt{(decide \optl\ \cargdflt{fnums}{*})}

\item[effect:] This provides a way to directly invoke the decision
procedures without the simplification inherent in \indtt{simplify}.  It is
not often needed, but can be useful in comparing different decision
procedures, or in trying to determine exactly what a given decision
procedure decides.

\end{description}

\prdolsubsection{do-rewrite}{Apply Installed Automatic Rewrites}

\begin{description}
\item[syntax:] \texttt{(do-rewrite \optl\ \cargdflt{fnums}{*}
\carg{rewrite-flag} \carg{flush?}\ \carg{linear?}\
\newline\hspace*{1in}
\carg{cases-rewrite?}\ \cargdflt{type-constraints?}{t})}

\item[effect:]
This command is another fragment of \indtt{assert}.  It is used to
automatically carry out the rewrites specified by \indtt{auto-rewrite} and
\indtt{auto-rewrite-theory}.  This command uses simplification
as defined by \indtt{assert} 
to discharge the hypotheses of conditional rewrite rules and any
type correctness proof obligations that arise from the use of a rewrite
rule, and also to simplify the rewritten result.  The other arguments are
as in \indtt{assert}\@.  

\begin{usage}{}
  \item[\texttt{(do-rewrite)}] :  Applies the rewrite rules to all the
formulas in the sequent.

  \item[\texttt{(do-rewrite (-1 -3 2))}] : Applies rewrite rules to 
the formulas \texttt{-1}, \texttt{-3}, and \texttt{2}. 
\end{usage}

\item[notes:] No new information is recorded into the data structures
used by the decision procedures, except for the subtype constraints
on subexpressions processed by \indtt{do-rewrite}.  


\end{description}

\prdolsubsection{grind}{Install Rewrites and Repeatedly \texttt{reduce}}
\begin{description}
\item[syntax:] \texttt{(grind \optl\ \cargdflt{defs}{!}\ 
\carg{theories} \carg{rewrites} \carg{exclude} \cargdflt{if-match}{t}
\newline\hspace*{1in}
\cargdflt{updates?}{t} \carg{polarity?}\ 
\cargdflt{instantiator}{inst?}\ \cargdflt{let-reduce?}{t}
\newline\hspace*{1in}
\carg{quant-simp?}\ \carg{no-replace?})}

\item[effect:] This is a catch-all strategy that is frequently used to
automatically complete a proof branch or to apply all the obvious
simplifications till they no longer apply.  The strategy first applies
\indtt{install-rewrites} to install the given theories and rewrite rules
along with all the relevant definitions in the given subgoal.  It then
applies \indtt{bddsimp} followed by \indtt{assert} (similar to
\indtt{ground}) to carry out the first level of simplification.  This is
followed by \indtt{replace*} to carry out all the equality replacements.
This is followed by \indtt{reduce} which repeatedly applies \indtt{bash}
(which invokes \indtt{assert}, \indtt{bddsimp}, the \emph{instantiator}
(default \indtt{inst?}), \indtt{skolem-typepred}, \indtt{flatten}, and
\indtt{lift-if}) followed by \indtt{replace*}\@.

The options to \indtt{grind} can be used to carefully guide its behavior.

The \emph{defs}, \emph{theories}, \emph{rewrites}, and \emph{exclude}
arguments are as in \indtt{install-rewrites}.

The \emph{updates?}\ option is as in \indtt{bash} and \indtt{reduce}.

The \emph{instantiator} argument allows an instantiator to be provided; it
defaults to \texttt{inst?}, but may be any (user-defined) strategy that
performs instantiation.  The provided instantiator may accept the
\emph{if-match} and \emph{polarity?}\ arguments, which are as in the
\texttt{inst?}\ command. Note that by setting \emph{if-match} to
\texttt{nil}, one can avoid the eager instantiation behavior of
\indtt{grind}.  A second \indtt{grind} can then be used to pick up the
instantiations exposed by the first instantiation-free \indtt{grind}.

The \emph{let-reduce?}\ flag indicates whether \texttt{LET} expressions
should also be reduced.

The \emph{quant-simp?}\ flag indicates that quantifier expressions of the
form, for example, \texttt{EXISTS x: x = a AND P(x)} or \texttt{FORALL y:
y = a IMPLIES P(y)} should be simplified to \texttt{P(a)}.  This is not
always desirable because type information may be lost, and the quantified
formula may be useful for doing induction.

The \emph{no-replace?}\ flag indicates whether \indtt{replace*} is
invoked.

\end{description}

\prdolsubsection{grind-with-ext}{\texttt{grind} with Extensionality}
\begin{description}
\item[syntax:] \texttt{(grind-with-ext \optl\ \cargdflt{defs}{!}\ 
\carg{theories} \carg{rewrites} \carg{exclude}
\newline\hspace*{1in}
\cargdflt{if-match}{t} \cargdflt{updates?}{t} \carg{polarity?}\ 
\cargdflt{instantiator}{inst?}\
\newline\hspace*{1in}
\cargdflt{let-reduce?}{t} \carg{quant-simp?}\ \carg{no-replace?})}

\item[effect:] This is like \indtt{grind}, but includes calls to
\indtt{apply-extensionality}.  The arguments are exactly as in
\indtt{grind}.  This is particularly useful when reasoning about functions
(e.g., sets).
\end{description}

\prdolsubsection{grind-with-lemmas}{\texttt{grind} using Lemmas}
\begin{description}
\item[syntax:] \texttt{(grind-with-lemmas \optl\
\cargdflt{lazy-match?}{t} \cargdflt{if-match}{t} \carg{polarity?}\ 
\newline\hspace*{1in}
\cargdflt{defs}{!}\ \carg{rewrites} \carg{theories} \carg{exclude}
\cargdflt{updates?}{t} \rest\ \carg{lemmas})}

\item[effect:] This is like \indtt{grind}, but does a combination of
\texttt{(lemma)} and \texttt{(grind)}; if \emph{lazy-match?}\ is \texttt{t}, postpones instantiations to follow a first round of simplification.
\end{description}

\prdolsubsection{ground}{Propositional and Ground Simplification}
\begin{description}
\item[syntax:] \texttt{(ground \optl\ \cargdflt{let-reduce?}{t}
\carg{quant-simp?})}

\item[effect:] This command invokes propositional simplification followed
by \texttt{assert}.  It is useful in obtaining simplified forms of the
cases arising from propositional simplification.  These simplifications
include those given by \indtt{assert}, namely, the various boolean,
datatype, and arithmetic simplifications, beta-reduction, simplification
using ground decision procedures, and rewriting with respect to the
installed rewrite rules.

The \emph{let-reduce?}\ flag indicates whether \texttt{LET} expressions
should also be reduced.

The \emph{quant-simp?}\ flag indicates that quantifier expressions of the
form, for example, \texttt{EXISTS x: x = a AND P(x)} or \texttt{FORALL y:
y = a IMPLIES P(y)} should be simplified to \texttt{P(a)}.  This is not
always desirable because type information may be lost, and the quantified
formula may be useful for doing induction.

\end{description}

\prdolsubsection{lazy-grind}{\texttt{grind} Postponing Instantiation}
\begin{description}
\item[syntax:] \texttt{(lazy-grind \optl\ \cargdflt{if-match}{t}
\cargdflt{defs}{!}\ \carg{rewrites} \carg{theories} \carg{exclude}
\newline\hspace*{1in}
\cargdflt{updates?}{t} \cargdflt{let-reduce?}{t} \carg{quant-simp?})}

\item[effect:] This is like \indtt{grind}, but postpones heuristic
instantiation until after simplification.  It is essentially \texttt{(then
(grind :if-match nil) (reduce))}.  All arguments are as in \indtt{grind}.
\end{description}


\prdolsubsection{record}{Record Assumptions for the Decision Procedures}
\begin{description}
\item[syntax:] \texttt{(record \optl\ \cargdflt{fnums}{*}
\carg{rewrite-flag} \carg{flush?}\ \carg{linear?}\ \carg{cases-rewrite?}\ 
\newline\hspace*{1in}
\cargdflt{type-constraints?}{t} \carg{ignore-prover-output?})}

\item[effect:] The decision procedures maintain efficient data structures
where the assumptions that are true in the current context are recorded.
The record command is used to add more assumptions to these data
structures.  The only assumptions that can be recorded are those that do
not contain any embedded \texttt{IF}, \texttt{CASES}, or boolean
structure.  The assumptions are antecedent formulas and negations of
consequent formulas.  It is possible for a \indtt{record} command to prove
the sequent if the assumptions are found to be contradictory.  The other
arguments are as in \indtt{assert}.

\begin{usage}{}
  \item[\texttt{(record)}] : records all the assumption formulas in the
sequent into the data structures used by the PVS decision procedures.

  \item[\texttt{(record (-1 -3 2))}] : records the assumptions from
formulas \texttt{-1}, \texttt{-3}, and \texttt{2}. 
\end{usage}

\item[notes:]  a formula is simplified before it is recorded (see \texttt{simplify} and \indtt{assert} below) so that it is possible for \texttt{record} to record an
assumption to contain \texttt{if}, \texttt{cases} or boolean structure that is
eliminated by simplification.   the command \indtt{assert} subsumes \texttt{record} but its behavior is more difficult to explain.

\end{description}

\prdolsubsection{reduce}{\texttt{bash} Repeatedly with Replacements}
\begin{description}
\item[syntax:] \texttt{(reduce \optl\ \cargdflt{if-match}{t}
\cargdflt{updates?}{t} \carg{polarity?}\ \cargdflt{instantiator}{inst?}
\newline\hspace*{1in}
\cargdflt{let-reduce?}{t} \carg{quant-simp?}\ \carg{no-replace?})}

\item[effect:] This command is the main workhorse of the \indtt{grind}
command.  It applies \indtt{bash} followed by \indtt{replace*} in a loop
until neither command has any effect.

The \emph{updates?}\ option is also as in the \indtt{bash} command
and must be set to \texttt{nil} in order avoid the automatic if-lifting
of update applications.

The \emph{instantiator} argument allows an instantiator to be provided; it
defaults to \texttt{inst?}, but may be any (user-defined) strategy that
performs instantiation.  The provided instantiator may accept the
\emph{if-match} and \emph{polarity?}\ arguments, which are as in the
\texttt{inst?}\ command. Note that by setting \emph{if-match} to
\texttt{nil}, one can avoid the eager instantiation behavior of
\indtt{reduce}.  A second \indtt{reduce} can then be used to pick up the
instantiations exposed by the first instantiation-free \indtt{reduce}.

The \emph{let-reduce?}\ flag indicates whether \texttt{LET} expressions
should also be reduced.

The \emph{quant-simp?}\ flag indicates that quantifier expressions of the
form, for example, \texttt{EXISTS x: x = a AND P(x)} or \texttt{FORALL y:
y = a IMPLIES P(y)} should be simplified to \texttt{P(a)}.  This is not
always desirable because type information may be lost, and the quantified
formula may be useful for doing induction.

The \emph{no-replace?}\ flag indicates whether \indtt{replace*} is
invoked.


\end{description}

\prdolsubsection{reduce-with-ext}{\texttt{reduce} with Extensionality}
\begin{description}
\item[syntax:] \texttt{(reduce-with-ext \optl\ \cargdflt{if-match}{t}
\cargdflt{updates?}{t} \carg{polarity?}\
\newline\hspace*{1in}
\cargdflt{instantiator}{inst?}\ \cargdflt{let-reduce?}{t}
\carg{quant-simp?}\ \carg{no-replace?})}

\item[effect:] This command is the main workhorse of the
\indtt{grind-with-ext} command.  It applies \indtt{bash} followed by
\indtt{apply-extensionality} and \indtt{replace*} in a loop until neither
command has any effect.  The arguments are as in \indtt{reduce}.

\end{description}

\prsubsection{simplify}{Simplify using Decision Procedures}

\begin{description}
\item[syntax:] \texttt{(simplify \optl\ \cargdflt{fnums}{*}
\carg{record?}\ \carg{rewrite?}\ \carg{rewrite-flag} \carg{flush?}\
\newline\hspace*{1in}
\carg{linear?}\ \carg{ cases-rewrite?}\
\cargdflt{type-constraints?}{t}
\newline\hspace*{1in}
\carg{ignore-prover-output?}\ 
\cargdflt{let-reduce?}{t} \carg{quant-simp?})}

\item[effect:] \indtt{simplify} is a primitive command used in the
definition of \indtt{assert}, \indtt{do-rewrite}, and \texttt{record}.
\indtt{simplify} includes the arguments to \indtt{assert} along
with two flags: \emph{record?}, and \emph{rewrite?}.  For the
\indtt{assert} command, \emph{record?}\ and \emph{rewrite?}\ must be
\texttt{t}.  To get the \indtt{do-rewrite} command, \emph{record?}\ must
be \texttt{ nil} and \emph{rewrite?}\ must be \texttt{t}.  To get the
\indtt{record} command, \emph{record?}\ must be \texttt{t}, and
\emph{rewrite?}\ must be \texttt{nil}.

The other flags have already been documented with the \indtt{assert}
command.  

Simplification works by maintaining database of currently recorded
information which is then used to simplify and record further information.
The ground decision procedures can be used to decide if a given formula
(that is, a boolean expression) is true or false (or not known to be
either) with respect to the current database and relative to theories such
as those of equality over uninterpreted function symbols and linear
arithmetic.  In a sequent of the form $\seq{a}{m}\vdash\seq{b}{n}$, the
$a_i$ are simplified and recorded as being true, and the $b_i$ are
simplified and recorded as being false.  The simplifications are described
below.  The recording process can yield a refutation in which case the
sequent has been proved.

The theories handled by the ground decision procedures include:
\begin{enumerate}
\item The theory of equality with uninterpreted functions symbols.  This
would enable it to prove a sequent of the form \texttt{x = f(x) $\vdash$
f(f(f(x))) = x}.

\item Quantifier-free linear arithmetic equalities and inequalities, \eg,
\texttt{x < 2*y, y < 3*z $\vdash$ 3*x < 18*z}.  Note that \texttt{x},
\texttt{y}, and \texttt{z} are implicitly universally quantified.


\item Quantifier-free integer linear arithmetic, \eg, \texttt{i > 1, 2*i <
5 $\vdash$ i = 2}.  This procedure is incomplete since the decision
problem for this theory is not known to be polynomial.

\item Arrays and functions with updates.  Examples include:
\begin{enumerate}
\item  \texttt{$\vdash$ f with [(s) := f(s)] = f},
\item  \texttt{$\vdash$ (f with [(s) := x])(s) = x}, and
\item  \texttt{ r/=s $\vdash$ (f with [(s) := x])(s) = f(s)}
\end{enumerate}
\end{enumerate}

The simplifications carried out by \indtt{simplify} are represented
by means of $\longrightarrow$, and  include:
\begin{enumerate}
\item {\bf Beta reduction:}  Examples of such redexes and the
corresponding reductions are:
\begin{itemize}
\item Lambda redex: \texttt{(lambda x : x * x)(2)} $\longrightarrow$ 2 * 2
\item Record redex : \texttt{b((\# a:= 1, b:= 2, c:= 3 \#)) $\longrightarrow$
2}
\item Tuple redex :   \texttt{proj\_2((1, 2, 3))  $\longrightarrow$ 2}
\item Function update redex: For function \texttt{f},
\begin{eqnarray*}
 \texttt{(f\ WITH\ [(i) := 3])(i)} &\Longrightarrow & \texttt{3}\\
   \texttt{(f\ WITH\ [(0) := 3])(1)} &\Longrightarrow & \texttt{f(1)}
\end{eqnarray*}
\item Record update redex: For record \texttt{r},
\begin{eqnarray*}
\texttt{a(r\ WITH\ [(a) := 3])}  & \Longrightarrow& \texttt{3}\\
\texttt{a(r\ WITH\ [(b) := 2])} & \Longrightarrow & \texttt{a(r)}
\end{eqnarray*}
\item Cotuple redex:
\begin{eqnarray*}
\texttt{in\_2(out\_2(x))} & \Longrightarrow & \texttt{x}\\
\texttt{out\_2(in\_2(x))} & \Longrightarrow & \texttt{x}\\
\texttt{in\_2?(in\_2(x))} & \Longrightarrow & \texttt{TRUE}\\
\texttt{in\_1?(in\_2(x))} & \Longrightarrow & \texttt{FALSE}
\end{eqnarray*}
\item Datatype redex: \texttt{car(cons(1, null)) $\Longrightarrow$ 1}
\item Recognizer redex:
\begin{eqnarray*}
\texttt{cons?(null)} & \Longrightarrow & \texttt{FALSE}\\
\texttt{cons?(cons(1, null))} & \Longrightarrow & \texttt{TRUE}
\end{eqnarray*}
\item Subtype redex:  \texttt{even?(i) $\Longrightarrow$ TRUE}, if \texttt{even?}
is one of the subtype predicates in the type of \texttt{i}.
\end{itemize}

\item {\bf Arithmetic simplifications:}  If \texttt{a}, \texttt{b}, \texttt{c} are
arbitrary arithmetic expressions, the following are examples of
simplifications that are
carried out by the \indtt{simplify} command :
\begin{eqnarray*}
 \texttt{ a + 0} &  \Longrightarrow & \texttt{a}\\
 \texttt{ a + 2*a } & \Longrightarrow & \texttt{3*a}\\
 \texttt{1 + a + 3 } & \Longrightarrow & \texttt{a + 4}\\
 \texttt{a*(b + c) } & \Longrightarrow & \texttt{a*b + a*c}\\
 \texttt{0 * a } & \Longrightarrow & \texttt{0}\\
 \texttt{1 * a } & \Longrightarrow & \texttt{a}\\
 \texttt{a + b = b + c } & \Longrightarrow & \texttt{a = c}
\end{eqnarray*}
In addition, sums and products are ordered into a canonical form.

\item {\bf Conditional simplification:}  If \texttt{A} is a formula and   
\texttt{a} and \texttt{b} are expressions, the following are examples of
simplifications applied by \indtt{simplify}:
\begin{eqnarray*}
 \texttt{(IF\ TRUE\ THEN\ a\ ELSE\ b\ ENDIF) } & \Longrightarrow & \texttt{a}\\
 \texttt{ (IF\ FALSE\ THEN\ a\ ELSE\ b\ ENDIF) } & \Longrightarrow & \texttt{b}\\
 \texttt{(IF\ A\ THEN\ b\ ELSE\ b\ ENDIF) } & \Longrightarrow & \texttt{b}\\
 \texttt{(IF\ A\ THEN\ a\ ELSE\ b\ ENDIF) } & \Longrightarrow & \texttt{(IF\ A'\ THEN\ a'\
ELSE\ b')}
\end{eqnarray*}
where: 
\begin{array}[t]{rcl}
 \texttt{A}  \Longrightarrow  \texttt{A}'\\
 \texttt{a}  \Longrightarrow  \texttt{a}' & \mbox{assuming} & \texttt{A}'\\
 \texttt{b} \Longrightarrow \texttt{b}' & \mbox{assuming} & \texttt{NOT A}'
\end{array}

\begin{eqnarray*}
 \texttt{(CASES\ null\ OF\ null:\ a,\ cons(x,y):\ b\ ENDCASES)} & \Longrightarrow& \texttt{a}
\end{eqnarray*}

\item Datatype simplifications:
\begin{eqnarray*}
 \texttt{cons?(a)} \Longrightarrow \texttt{TRUE}, & \texttt{if} &
   \texttt{null?(a)} \Longrightarrow \texttt{FALSE}\\
 \texttt{cons?(a)} \Longrightarrow \texttt{FALSE}, &\texttt{if}&
   \texttt{null?(a)} \Longrightarrow \texttt{TRUE}
\end{eqnarray*}
The datatype simplifications might look circular but the simplifier
uses the decision procedures to check for each recognizer applied to an
expression having a datatype 
as a type, whether the result is true or false or unknown.

\item Boolean simplification:  If the decision procedures determine a
boolean expression to be \texttt{TRUE} or \texttt{FALSE} in the logical context
in which the expression occurs, then it is simplified accordingly.  
If \texttt{A} is a boolean expression, the
following are examples of other simplifications carried out by \indtt{simplify}:
\begin{eqnarray*}
  \texttt{A\ AND\ TRUE\ } & \Longrightarrow & \texttt{\ A}\\ 
  \texttt{A\ AND\ FALSE\ } & \Longrightarrow & \texttt{\ FALSE}\\
  \texttt{A\ OR\ TRUE\ } & \Longrightarrow & \texttt{\ TRUE}\\
  \texttt{A\ OR\ FALSE\ } & \Longrightarrow & \texttt{\ A}\\
  \texttt{TRUE\ IMPLIES\ A\ } & \Longrightarrow & \texttt{\ A}\\
  \texttt{FALSE\ IMPLIES\ A\ } & \Longrightarrow & \texttt{\ TRUE}\\
  \texttt{NOT\ (NOT\ A)\ } & \Longrightarrow & \texttt{\ A}\\
  \texttt{NOT\ TRUE\ } & \Longrightarrow & \texttt{\ FALSE}\\
  \texttt{NOT\ FALSE\ } & \Longrightarrow & \texttt{\ TRUE}\\
  \texttt{a = a\ } & \Longrightarrow & \texttt{\ TRUE}\\
  \texttt{(FORALL\ x:\ TRUE)\ } & \Longrightarrow & \texttt{\ TRUE}\\
  \texttt{(EXISTS\ x:\ FALSE)\ } & \Longrightarrow & \texttt{\ FALSE}
\end{eqnarray*}
\item Quantifier simplifications: some quantified expressions are now
simplified, including the following examples.

\begin{tabular}{rcl}
\texttt{(EXISTS x:\ x = 5)} & $\Longrightarrow$ & \texttt{TRUE}\\
\multicolumn{3}{l}{\texttt{(EXISTS x, y, z:\ x = y + z AND f(x, y, z))}} \\
  & $\Longrightarrow$ & \texttt{(EXISTS y, z:\ f(y + z, y, z))}\\
\texttt{(EXISTS (x:\ T):\ TRUE)} & $\Longrightarrow$ & \texttt{TRUE}\\
\texttt{(FORALL (x:\ T):\ FALSE)} & $\Longrightarrow$ & \texttt{FALSE}\\
\end{tabular}

The last two simplifications only happen when the type \texttt{t} is known
to be nonempty.
\item Rewriting:  The simplifications include conditional rewriting with
respect to the rewrite rules installed by means of \indtt{auto-rewrite},
\indttbang{auto-rewrite}, 
\indtt{auto-rewrite-theory}, \indtt{auto-rewrite-theories}, etc.
The current ordered set of rewrite rules can be viewed using the
PVS Emacs command \emacstt{show-auto-rewrites}.
Rewriting only occurs when the \indtt{rewrite} flag for the \indtt{simplify}
command is \texttt{t}.  If $A$ and $B$ are boolean expressions, and $a$ and
$b$ are expressions, then rewrite rules can be of one of the following
forms:
\begin{enumerate}
\item $a = b$
\item $A\ \texttt{IMPLIES}\ a = b$
\item $A\ \texttt{IMPLIES}\ B$ 
\end{enumerate}
In cases 1 and 2, the left-hand side (lhs) is $a$ and the right-hand side
(rhs) is $b$\@.   In cases 2 and 3, the condition of the rewrite rule is
$A$, whereas for case~1, the condition is \texttt{TRUE}\@.  In case~3, the
lhs is $B$ and the rhs is \texttt{TRUE}\@.

If $a'$ is an instance of the lhs of a rewrite rule so that $b'$ is the
corresponding instance of the rhs and $A'$ is an instance of the
condition, then rewriting simplifies $a'$ to $b''$ provided
$A'$ simplifies to \texttt{TRUE} and $b'$ simplifies to $b''$\@.
If $b'$ is of the form \texttt{(IF $B$ THEN $c$ ELSE $d$ ENDIF)}, then
$B$ must simplify to either \texttt{TRUE} or \texttt{FALSE} for the
rewrite rule to be applicable,   
unless the rewrite rule has been installed with the \texttt{always?}\ flag set
to \texttt{t}\@.   The same constraint also applies if $b'$ is
a \texttt{CASES} expression.  In applying a rewrite rule, the lhs of the
rewrite rule, say $a$, is matched against the expression to be simplified.
If the match succeeds, the typechecking of the instantiation could
generate TCCs.  The simplification process is applied to the TCCs which  
must simplify to \texttt{TRUE} before the rewrite rule is applied.
\end{enumerate}


\begin{usage}{}
  \item[\texttt{(simplify)}] :  Tries to simplify all the formulas in the
sequent using the PVS decision procedures, beta-reduction, boolean
simplification, datatype simplification, arithmetic simplification, and
rewriting.  

  \item[\texttt{(simplify (-1 -3 2))}] : Simplifies the 
formulas \texttt{-1}, \texttt{-3}, and \texttt{2}.

  \item[\texttt{(simplify (-1 -3 2) :flush?\ T)}] : Flushes the decision
procedure database and then simplifies the formulas \texttt{-1}, \texttt{-3},
and \texttt{2}.  This database can sometimes contain information that
interferes with the expected simplification and it helps to flush the
database.

  \item[\texttt{(simplify (-1 -3 2) :linear?\ T)}] :  The PVS decision
procedures have a modest ability to handle nonlinear multiplication and
division.  This invocation of \texttt{simplify} causes simplification
to occur with this capability turned off.

  \item[\texttt{(simplify -1 :rewrite-flag RL)}] :  The rewrite flag
can take on values LR (``left-to-right'') or RL (``right-to-left'')
to indicate that left-hand side (for LR) or right-hand side (for RL)
of the indicated formula should be
left undisturbed by simplification.  This is needed in case the next step
involves a syntactic replacement.
\end{usage}

\item[notes:] The \indtt{simplify} commands and their variants can be
placed within \indtt{repeat} strategies without the danger of creating an
infinitely looping strategy.

The command \indtt{track-rewrite} can be used to obtain diagnostic
information about the progress of rewriting,  and the command
\indtt{untrack-rewrite} can be used to turn off the printing of this
information.  
\end{description}

\prdolsubsection{simplify-with-rewrites}{Install Rewrites, Simplify, and Stop Rewrites}
\begin{description}
\item[syntax:] \texttt{(simplify-with-rewrites \optl\ \cargdflt{fnums}{*}
\carg{defs} \carg{theories} \carg{rewrites}
\newline\hspace*{1in}
\carg{exclude-theories} \carg{exclude})}

\item[effect:] Installs rewrites (according to \emph{defs}) from
\emph{theories} and \emph{rewrites}, excluding those rewrites from
\emph{exclude} or \emph{excluded-theories}, applies \texttt{(assert
\emph{fnums})}, and then turns off all the installed rewrites.  The
arguments other than \emph{fnums} are all as in \indtt{install-rewrites}.

\end{description}

\prdolsubsection{smash}{Propositional/Ground Simplification with IF-lifting}
\begin{description}
\item[syntax:] \texttt{(smash \optl\ \cargdflt{updates?}{t}
\cargdflt{let-reduce?}{t} \carg{quant-simp?})}

\item[effect:] This command is a more powerful version of \indtt{ground}.
It is essentially an iterated application of \indtt{bddsimp} (whereas the
propositional simplification in \indtt{ground} is similar to that of
\indtt{prop}), \indtt{assert}, and \indtt{lift-if}.

The \emph{updates?}\ flag can be set to \texttt{nil} in order to avoid
if-lifting update applications (see page~\pageref{if-lift-updates}).

The \emph{let-reduce?}\ flag indicates whether \texttt{LET} expressions
should also be reduced.

The \emph{quant-simp?}\ flag indicates that quantifier expressions of the
form, for example, \texttt{EXISTS x: x = a AND P(x)} or \texttt{FORALL y:
y = a IMPLIES P(y)} should be simplified to \texttt{P(a)}.  This is not
always desirable because type information may be lost, and the quantified
formula may be useful for doing induction.

\end{description}

\section{Installing and Removing Rewrite Rules}
\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{auto-rewrite} & \emph{primitive}
  & install a list of formulas as lazy rewrite rules\\\hline
\indttbang{auto-rewrite} & \emph{defined}
  & install a list of formulas as eager rewrite rules\\\hline
\indttdbang{auto-rewrite} & \emph{defined}
  & install a list of formulas as macro rewrite rules\\\hline
\indtt{auto-rewrite-defs} & \emph{defined}
  & install relevant definitions as rewrite rules\\\hline
\indtt{auto-rewrite-explicit} & \emph{defined}
  & install relevant definitions as eager rewrite rules\\\hline
\indtt{auto-rewrite-theories} & \emph{defined}
  & install declarations of theories as rewrite rules\\\hline
\indtt{auto-rewrite-theory} & \emph{defined}
  & install declarations of a theory as rewrite rules\\\hline
\multicolumn{3}{|l|}{\indtt{auto-rewrite-theory-with-importings}}\\
  & \emph{defined}
  & install declarations of a theory and its importings as rewrite rules\\\hline
\indtt{install-rewrites} & \emph{defined}
  & install rewrites from names and theories \\\hline 
\indtt{stop-rewrite} & \emph{primitive}
  & disable automatic rewrite rules \\\hline
\indtt{stop-rewrite-theory} & \emph{defined}
  & disable automatic rewrites from a theory\\\hline
\end{tabularx}

\prsubsection{auto-rewrite}{Install Lazy Rewrite Rules}
\begin{description}

\item[syntax:] \texttt{(auto-rewrite \rest\ \carg{names})}

\item[effect:] The definitions, lemmas, and antecedent formulas named (or
numbered) in \emph{names} are made available for the descendant nodes of
the current proof node as automatic rewrite rules to be used for
simplification by the \texttt{assert} rule.  Only formulas of a certain
special form can be considered as automatic rewrite rules.  An automatic
rewrite rule is either:
\begin{itemize}

\item An \emph{equality rewrite rule} of the form $l = r$ or $l \iff r$
or an atomic Boolean proposition, where $l$ is any expression that
is not an individual variable, and the set of free variables in $r$ is a
subset of the free variables of $l$

\item An unquantified conditional rewrite rule of the form $A\supset B$
where $B$ is either an equality or an unquantified conditional rewrite
rule and the set of free variables in $A$ is a subset of the free
variables in $B$, or

\item A quantified rewrite rule of the form $(\forall x_1,\ldots, x_n :
A)$, where $A$ has the form of a rewrite rule.
\end{itemize}
In addition, a generic rewrite rule that is installed without actual
theory parameters must be such that all the formal parameters occur in the
left-hand side expression  $l$\@. 

All rewrite rules have a left-hand side $l$, a right-hand side $r$, and a
condition $H$ so that any matching instance $l'$ of the left-hand side is
replaced by the corresponding instance $r'$ of the right-hand side
provided the corresponding instance $H'$ of the condition can be
simplified to \texttt{TRUE}\@.  ($H$ is usually the left-hand side of an
implication, e.g. $H \implies l = r$, or the condition of an $IF$ or
$CASES$ expression.)

There are three kinds of automatic rewrite rules: \emph{lazy},
\emph{eager}, and \emph{macros}.  At a given sequent, each installed
rewrite rule can belong to at most one of these classes.

There are two forms of the \emph{names} argument.  In the preferred form,
each name is a \emph{rewrite-name-or-fnum}:

\begin{bnf}
\production{rewrite-name-or-fnum}{fnum \choice rewrite-name}
\production{fnum}
  {\opt{\lit{-}} Number \opt{\lit{!} \opt{\lit{!}}}}
\production{rewrite-name}
  {Name \opt{\lit{!} \opt{\lit{!}}} \opt{\lit{:} \brc{TypeExpr \choice FormulaName}}}
\end{bnf}

Here a lazy rule has no exclamation marks, an eager rule has one, and a
macro has two.  For a rewrite name, a type expr or formula name allows a
specific rewrite to be specified in the presence of overloading.

In the second form of \emph{names} argument some of the names may be
parenthesized, and the depth of parenthesization indicates whether it is
lazy, eager, or a macro.  If the name appears as unparenthesized as
\texttt{"assoc"}, then it is lazy.  If it is singly parenthesized, as in
\texttt{("assoc")}, then it is eager.  If it is doubly parenthesized, as
in \texttt{(("assoc"))}, then it is a macro.  The single and doubly
parenthesized forms can include multiple unparenthesized names.  If a
given name is overloaded in a theory, there is no way in this form to
indicate a specific declaration.

For example, for the command
\begin{alltt}
  (auto-rewrite "A" "B!" "1!" "C" "-3!!" "D!!")
\end{alltt}
\texttt{A} and \texttt{C} are lazy rewrites, \texttt{B} and formula number
\texttt{1} are eager rewrites, and formula number \texttt{-3} and
\texttt{D} are macro rewrites.  In the deprecated form, this may be given
as
\begin{alltt}
  (auto-rewrite "A" ("B" "1") "C" (("-3" "D")))
\end{alltt}
The two forms may not be mixed, and the parenthesized form may be
disallowed in the future.

Lazy rules are the default where if the right hand side is a conditional
or \texttt{CASES} expression, the rewrite rule is not triggered unless the 
top-level condition simplifies to \texttt{TRUE} or \texttt{FALSE} or the
top-level \texttt{CASES} expression is resolved.  All recursive definitions
can only be lazy rewrite rules since there is a possibility that the
rewriting might loop following the recursion.  In an eager rewrite rule,
the rewrite rule is applied regardless of the consequence of
simplifications on the right-hand side instance.  When rewriting with
function definitions, both lazy and eager rewrite rules work with
left-hand sides that, when curried, are in their fully applied form.  That
is, if a function definition allows the left-hand side forms $f$, $f(x,
y)$, $f(x, y)(z)$, then $f(x, y)(z)$ is the only valid left-hand side to a
lazy or eager rewrite rule form of this definition.  Macros on the other
hand always rewrite any occurrence of $f$ so that $f$ is rewritten to
$(\lambda (x, y): (\lambda z: \ldots))$ and $f(a, b)$ is rewritten to
$(\lambda z: \ldots)[a/x, b/y]$\@.


It is preferable that the names of 
lemmas  from imported theories be completely specified, \ie\ with
all the actual theory
parameters explicitly given.  Otherwise, the rewrite rule is known
as \emph{generic} and the actual parameters are instantiated
when the left-hand side is matched.  Not all rewrite rules contain
instances of all the actuals, and such rewrite rules are not installed
in their generic form.

For rewrite rules installed from antecedent formulas, an internal name is
generated that can be used for turning off the rewrite rule using
\indtt{stop-rewrite} or one of its variants.

It is important to note that \indtt{auto-rewrite} has no visible effect
on the sequent, but  
it affects the subsequent behavior of \indtt{assert} in any lower branch
of the proof.  The scope of an \indtt{auto-rewrite} declaration is
restricted to the branch of the proof below it.

\item[usage:] \texttt{(auto-rewrite "append[nat]" "append[int]"
"length[nat]")}

\item[errors:] Due to the presence of actual parameters, \texttt{auto-rewrite} can generate parsing and typechecking errors, in addition
to those listed below.
\begin{description}

\item[{\bf No resolutions for \ldots}:] The system was unable to find
declarations corresponding to the given names.

\item[{\bf Can't rewrite using \ldots: LHS key \ldots is bad.}]
Rewrite rules are arranged by a key which in the case of an application
is the left-most operator name or expression type such as a
record constructor, tuple constructor, update expression,
tuple projection, record field access, cases expression, and lambda,
forall, and exists expressions.   Note that having too many rewrite rules
attached to a single key can slow down rewrite lookup.  

\item[{\bf RHS free variables must be contained in the LHS free
variables}:] Since the matching for rewriting is done using the left-hand
side of the rewrite rule, there should be no free variables left in the
formula that are not instantiated during such a match.

\item[{\bf Hypothesis free variables must be contained in the LHS free
variables}:] See explanation above.

\item[]{\bf Theory \ldots is generic; No actuals given; Free parameters in
the LHS of rewrite must contain all theory formals.}:   Rewrite rules
from generic theories are allowed as long as it is possible to
extract the actual parameters by matching against the left-hand side.

\end{description}

\item[notes:] \indtt{stop-rewrite} turns off automatic rewrite rules,
\indtt{auto-rewrite-theory} turns an entire theory into rewrite rules, and
\indtt{stop-rewrite-theory} turns off theory rewriting.  The Emacs command
\emacstt{show-auto-rewrites} displays the currently active rewrite rules
in a separate buffer and \indtt{track-rewrite} can be used to
explain why rewrite rules did not perform the expected rewriting.  Rewrite
rules that are already installed are not affected by
\emacstt{modify-declaration} and might therefore need to be reinstalled.
\end{description}

\prdolsubsection{auto-rewrite!}{Install Eager Rewrite Rules}
\index{auto-rewrite"!@{\texttt{auto-rewrite"!}}|ii}

\begin{description}
\item[syntax:] \texttt{(auto-rewrite!\ \rest\ \carg{names})}

\item[effect:] This is just a macro for the eager case of
\indtt{auto-rewrite}\@.  The convenience it offers over
\indtt{auto-rewrite} is that the arguments can be given in {\rest} form. 
\end{description}

\prdolsubsection{auto-rewrite!!}{Install Macro Rewrite Rules}
\index{auto-rewrite"!"!@{\texttt{auto-rewrite"!"!}}|ii}

\begin{description}
\item[syntax:] \texttt{(auto-rewrite!!\ \rest\ \carg{names})}

\item[effect:] This is just an abbreviation for the macro case of
\indtt{auto-rewrite} where the arguments can be given in {\rest} form. 
\end{description}

\prdolsubsection{auto-rewrite-defs}{Install Relevant Definitions as Rewrites}

\begin{description}
\item[syntax:] \texttt{(auto-rewrite-defs \optl\ \carg{explicit?}\ \carg{always?}\ \carg{exclude-theories}) }

\item[effect:]  Installs all the definitions used directly or indirectly in the
current sequent as auto-rewrite rules.  If the \emph{explicit?}\ flag is T, the
recursive definitions are not installed and only the explicit definitions are.
If \emph{always?}\ is \texttt{!!}, the explicit definitions are installed as
macros.   
If this flag is \texttt{t}, then the explicit definitions are installed as
eager rewrite rules.  Otherwise, all definitions are installed as lazy
rewrite rules.  (See \indtt{auto-rewrites}.)

The \emph{exclude-theories} takes a list of theories and the definitions
in these theories will not be expanded.  

The \indtt{install-rewrites} command should always be preferred over any of
the specialized rewrite installation commands. 
\end{description}

\prdolsubsection{auto-rewrite-explicit}{Install Relevant Definitions as
Eager Rewrites}

\begin{description}
\item[syntax:] \texttt{(auto-rewrite-explicit \optl\ \carg{always?})}

\item[effect:] Installs all and only the explicit definitions used
directly or indirectly in the current sequent as auto-rewrite rules.  If
\emph{always?}\ is \texttt{!!}, the explicit definitions are installed as
macros.  If this flag is \texttt{t}, then the explicit definitions are
installed as eager rewrite rules.  Otherwise, all definitions are
installed as lazy rewrite rules.  (See \texttt{auto-rewrite}.)

The \indtt{install-rewrites} command should always be preferred over any of
the specialized rewrite installation commands.
\end{description}

\prdolsubsection{auto-rewrite-theories}{Install Rewrites of Theories}

\begin{description}

\item[syntax:] \texttt{(auto-rewrite-theories \rest\ \carg{theories})}

\item[effect:] Applies the \indtt{auto-rewrite-theory} command to each of
the theories in the list \emph{theories}\@.   Each entry in the list of
theories can be a theory name with or without actuals or a list of
arguments in the form accepted by \indtt{auto-rewrite-theory}.

This command is subsumed by \indtt{install-rewrites}.
\end{description}

\prdolsubsection{auto-rewrite-theory}{Install Rewrites of a Theory}

\begin{description}

\item[syntax:] \texttt{(auto-rewrite-theory \carg{name} \optl\
\carg{exclude} \carg{defs} \carg{always?}\ \carg{tccs?})}

\item[effect:] Installs an entire theory or only (explicit) definitions
if \emph{defs} is \texttt{t} (\texttt{explicit}) as auto-rewrites.  In the
case of a parametric theory, unless the \emph{defs} flag is \texttt{t} or
\texttt{explicit}, the actual parameters must be given.  If \emph{always?}
is \texttt{t} the rewrites are installed so that any rewrite other
than a recursive definition always takes effect (see
\texttt{auto-rewrite!}).  If \emph{always?}\ is set to \texttt{!!}, then
the non-recursive definitions are always rewritten even when only a few of
the curried arguments have been provided.)  Declarations named in
\emph{exclude} are not introduced and any current rewrite rules in the
\emph{exclude} list are disabled.  By default, TCCs in the theory are
excluded but they can be included when the \emph{tcc?}\ flag is \texttt{t}.

\begin{usage}{}

\item[]\texttt{(auto-rewrite-theory "sets[nat]" "sets[rational]"
"list\_adt[nat]")} : Declares all those definitions and formula from the
listed modules that can be viewed as rewrite rules to be automatic
rewrite rules.

\item[\texttt{(auto-rewrite-theory "agreement")}] : If we are proving a
lemma names \texttt{main} in the theory \texttt{agreement}, then all the
rewrite rules preceding \texttt{main} are declared as automatic rewrite
rules to be used by \indtt{assert}.
\end{usage}

\item[errors:] Apart from parsing and typechecking errors, the following
error messages are possible:
\begin{description}

\item[{\bf Could not find theory \ldots}:] The named theory does not
appear in the current context.  Add the theory to the \texttt{IMPORTING}
list if needed.

\item[{\bf \ldots is not a fully instantiated theory}:] Provide the
relevant actual parameters.
\end{description}
   
\end{description}

\prdolsubsection{auto-rewrite-theory-with-importings}{Install Rewrites
of a Theory and Its Importings}

\begin{description}

\item[syntax:] \texttt{(auto-rewrite-theory-with-importings \carg{name}
\newline\hspace*{1in}
\optl\ \carg{exclude-theories} \carg{importchain?}\ \carg{exclude}
\carg{defs}
\newline\hspace*{1in}
\carg{always?}\ \carg{tccs?})}

\item[effect:] Installs rewrites in theory \emph{name} along with any
theories imported by \emph{name}.  The full import chain of theories can
be installed by supplying the \emph{importchain?}\ flag as \texttt{t}.
Theories named in \emph{exclude-theories} are ignored.  The other
arguments are similar to those of \texttt{auto-rewrite-theory} and apply
uniformly to each of the theories to be installed.

\item[errors:] Same as for \texttt{auto-rewrite-theories}
\end{description}

\prdolsubsection{install-rewrites}{Install Rewrites from Names
and Theories}

\begin{description}
\item [syntax:] \texttt{(install-rewrites \optl\ \carg{defs}
\carg{theories} \carg{rewrites} \carg{exclude-theories}
\newline\hspace*{1in}
\carg{exclude})} 

\item[effect:]  This is the most powerful way to install rewrite rules
and essentially subsumes all the other ways of installing rewrite rules.

The \emph{defs} argument can be
\begin{itemize}
\item \texttt{nil}:  To avoid installing the
definitions relevant to the current sequent.
\item \texttt{t}, \texttt{!}, or \texttt{!!}: To install all definitions as lazy, eager,
or macro rewrites, respectively.
\item  \texttt{explicit}, \texttt{explicit!}, or \texttt{explicit!!}: Only the
explicit definitions are installed as lazy, eager, or macro rewrites,
respectively.
\end{itemize}

The \emph{theories} argument is a list of theories whose declarations
are meant to be used as rewrite rules.  Each entry in the list is either a
theory name, with or without 
actual parameters, or an argument list in the format expected by
\indtt{auto-rewrite-theory}\@.

The \emph{rewrites} argument is a list of names of rewrite rules to be
installed.

The \emph{exclude-theories} argument is a list of theories that have to
be excluded when installing rewrite rules from theories.

The \emph{exclude} argument is a list of names of rewrite rules that are
removed from the list of installed rewrite rules.  
\end{description}


\prsubsection{stop-rewrite}{Disable Automatic Rewrites}
\begin{description}

\item[syntax:] \texttt{(stop-rewrite \rest\ \carg{names})}

\item[effect:] Turns off those automatic rewrite rules named in \emph{names} that were turned on by either \indtt{auto-rewrite} or \texttt{auto-rewrite-theory}.

\item[usage:] \texttt{(stop-rewrite "append[nat]" "append[int]"
"length[nat]")} : Turns off automatic rewriting of these specific
rewrite rules regardless of whether they were added using \texttt{auto-rewrite} or \indtt{auto-rewrite-theory}.

\item[errors:] {\bf \ldots is not an auto-rewrite}: This is a helpful
message rather than an error.

\end{description}


\prdolsubsection{stop-rewrite-theory}{Disable Automatic Rewrites from a Theory}

\begin{description}

\item[syntax:] \texttt{(stop-rewrite-theory \rest\ \carg{names})}

\item[effect:] Turns off any rewrite rules from the theories named in
\emph{names} that were turned on by either \indtt{auto-rewrite} or \texttt{auto-rewrite-theory}.  Any theory listed in \emph{names} must either be
fully instantiated, or name a defined constant, or be the theory for
the current proof.  Note that for a rewrite rule to be turned off,
the name should be given in the same form to \indtt{stop-rewrite} as in
the corresponding \indtt{auto-rewrite}.   command

\item[usage:] \texttt{(stop-rewrite-theory "sets[nat]" "sets[rational]"
"list\_adt[nat]")} : Turns off any rewrite rules in the listed
theories.  As with \indtt{auto-rewrite-theory}, the theory names should
be fully instantiated.

\item[errors:] Same as \texttt{auto-rewrite-theory}.
   
\end{description}
\index{Proof Rules!Extensionality|)}

\section{Making Type Constraints Explicit}
\index{Proof Rules!Type Constraints|(}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{all-typepreds} & \emph{defined}
  & make type constraints of subexpressions explicit\\\hline
\indtt{typepred} & \emph{primitive}
  & make type constraints of expressions explicit\\\hline
\indttbang{typepred} & \emph{primitive}
  & make all type constraints of expressions explicit\\\hline
\end{tabularx}

\prsubsection{all-typepreds}{Make Type Constraints of Subexpressions Explicit}
\begin{description}

\item[syntax:] \texttt{(all-typepreds \optl\ \cargdflt{fnums}{*})}

\item[effect:] This provides the type constraints for all subexpressions
of the given formulas.  The type constraints are only collected for
subexpressions without free variables, and which contain an expandable
definition or a propositional operator; otherwise the type constraint will
not be useful, since the decision procedures already handle the other
possibilities.
\end{description}

\prsubsection{typepred}{Make Type Constraints of Expressions Explicit}
\begin{description}

\item[syntax:] \texttt{(typepred \rest\ \carg{exprs})}

\item[effect:] If \emph{exprs} is a list of expressions $e_1, \ldots
e_n$, then for each $e_i$, and for each type-constraint predicate $p$ in
the type of $e_i$, an antecedent formula of the form $p(e_i)$ is
introduced.  A predicate $p$ is a type-constraint predicate in a type
$\{ x : \tau | q(x) \}$ if either $p \equiv q$ or $p$ is a
type-constraint predicate in $\tau$.

\begin{usage}{}

\item[\texttt{(typepred "i+j")}] : If \texttt{i} and \texttt{j} are natural
numbers, then the antecedent formula \texttt{i + j >= 0} is added to the
current sequent along with the assertions \texttt{integer\_pred(i + j)},
\texttt{rational\_pred(i + j)}, and \texttt{real\_pred(i + j)}.

\item[\texttt{(typepred "cons(i, null)")}] : Adds the antecedent formula\linebreak
\texttt{cons?[nat](cons(i, null))} to the current sequent.

\end{usage}

\item[errors:] Apart from parsing and typechecking errors,
\indtt{typepred} can generate two errors:
\begin{description}

\item[{\bf Given expression does not typecheck uniquely}:] This means
that there was some type ambiguity in the given expression that can be
resolved by providing theory names, actuals, and/or explicit coercions.

\item[{\bf Irrelevant free variables in \ldots}:] As with many other
rules, no free variables can be introduced into a sequent in a PVS
proof.
\end{description}

\item[notes:] Type predicates are automatically made available to the
decision procedures in most cases.  This command is needed when the
predicates involve definitions or propositional operators.

It is important to provide the right (sub)term to \texttt{typepred}.  For
example, given the curried function
\begin{alltt}
  f: {g: [y: T -> {z: T | R(y, z)}] | P(g)}
\end{alltt}
\texttt{(typepred \"f\")} yields \texttt{P(f)}, while \texttt{(typepred
\"f(a)\")} yields \texttt{R(a, f(a))}.  If you want both, try
\indtt{all-typepreds}.
   
\end{description}

\prsubsection{typepred!}{Make All Type Constraints of Expressions Explicit}
\index{typepred"!@{\texttt{typepred"!}}|ii}
\begin{description}

\item[syntax:] \texttt{(typepred!\ \carg{exprs} \optl\ \carg{all?})}

\item[effect:]  The only difference between \indtt{typepred} and
\indttbang{typepred} is that the \emph{exprs} argument is not given in
{\rest} form and the \texttt{all?}\ flag can be set to \texttt{t} to get
all the type predicates for subtypes of the type \texttt{number}.  The
\indtt{typepred} command only returns the type predicates up to the
natural number constraint.  
\end{description}
\index{Proof Rules!Type Constraints|)}

\section{Abstraction and Model Checking}
\index{Proof Rules!Model Checking|(}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{abstract} & \emph{defined}
  & Boolean abstraction of expressions\\\hline
\indtt{abstract-and-mc} & \emph{defined}
  & Boolean/data abstraction followed by model-checking\\\hline
\indtt{abs-simp} & \emph{primitive}
  & Boolean abstraction \\\hline
\indtt{model-check} & \emph{defined}
  & CTL model checker\\\hline
\indtt{musimp} & \emph{primitive}
  & mu-calculus model checker \\\hline
\end{tabularx}


%
% abstract
%


\prdolsubsection{abstract}{Create Abstraction}
\begin{description}
\item[syntax:]  \texttt{(abstract 
\carg{cstate}
\carg{astate}
\carg{amap}
\optl\ 
\carg{theories}
\carg{rewrites}
\newline\hspace*{1in}
\carg{exclude}
\cargdflt{strategy}{(assert)}
\carg{feasible}
\carg{verbose?})}
\item[effect:]  This command invokes the 
command \indtt{abstract} to construct an abstraction 
of the mu-calculus formulas in the given goal.

The mu-calculus formulas in the goal that contain quantification
over the concrete state type \emph{cstate} are abstracted with
respect to both predicate and data abstraction maps given in \emph{amap}.
The result is a corresponding mu-calculus formula over the abstract
state type \emph{astate}.  Both \emph{cstate} and \emph{astate} are
expected to be type expressions, and \emph{amap} is a list of
pairs of field-name (from the record type \emph{astate})
and a function from the concrete state type \emph{cstate} to
the type (which currently must be a boolean or a scalar type)
corresponding to the 
field-name in the type \emph{astate}\@. 
The optional arguments \emph{theories}, \emph{rewrites}, and
\emph{exclude}
are as in \indtt{install-rewrites}\@.  The \emph{strategy} argument
takes a proof command that is used to discharge the proof obligations that
arise in the construction of the abstraction.  The default strategy
is \texttt{(assert)}.  Various forms of \indtt{grind} are also suitable
though significantly more expensive in terms of time.   
The \texttt{feasible}
argument takes a predicate in the abstract state \emph{astate}
that characterizes the feasible abstract states.  This is needed
when the abstracted formulas contain quantifiers of existential strength. 
Each abstract state corresponds to a set of concrete states, but the
latter set might be empty leading to an existential formula that is
satisfiable at the abstract level but not at the concrete level.
Finally, the \emph{verbose?}\ flag prints out an extensive listing
of the proof obligations generated during abstraction and the
success or failure of the proof effort.
\end{description}

\prdolsubsection{abstract-and-mc}{Abstract and Model Check}
\begin{description}
\item[syntax:]  \texttt{(abstract-and-mc
\carg{cstate}
\carg{astate}
\carg{amap}
\optl\ 
\carg{theories}
\carg{rewrites}
\newline\hspace*{1in}
\carg{exclude}
\cargdflt{strategy}{(assert)}
\carg{feasible}
\carg{verbose?})}
\item[effect:]  This command constructs an abstraction 
of the mu-calculus formulas in the given goal using
\indtt{install-rewrites} to install various rewrites,
\indtt{assert} to apply these rewrites and other simplifications,
and \indtt{abs-simp} to actually construct the abstraction. 

The mu-calculus formulas in the goal that contain quantification
over the concrete state type \emph{cstate} are abstracted with
respect to both predicate and data abstraction maps given in \emph{amap}.
The result is a corresponding mu-calculus formula over the abstract
state type \emph{astate}.  Both \emph{cstate} and \emph{astate} are
expected to be type expressions, and \emph{amap} is a list of
pairs of field-name (from the record type \emph{astate})
and a function from the concrete state type \emph{cstate} to
the type (which currently must be a boolean or a scalar type)
corresponding to the 
field-name in the type \emph{astate}\@. 
The optional arguments \emph{theories}, \emph{rewrites}, and
\emph{exclude}
are as in \indtt{install-rewrites}\@.  The \emph{strategy} argument
takes a proof command that is used to discharge the proof obligations that
arise in the construction of the abstraction.  The default strategy
is \texttt{(assert)}.  Various forms of \indtt{grind} are also suitable
though significantly more expensive in terms of time.   
The \texttt{feasible}
argument takes a predicate in the abstract state \emph{astate}
that characterizes the feasible abstract states.  This is needed
when the abstracted formulas contain quantifiers of existential strength. 
Each abstract state corresponds to a set of concrete states, but the
latter set might be empty leading to an existential formula that is
satisfiable at the abstract level but not at the concrete level.
Finally, the \emph{verbose?}\ flag prints out an extensive listing
of the proof obligations generated during abstraction and the
success or failure of the proof effort.
\end{description}


\prdolsubsection{abs-simp}{Create Boolean abstraction}
\begin{description}
\item[syntax:] \texttt{(abs-simp 
\carg{cstate}
\carg{astate}
\carg{amap}
\optl\ 
\cargdflt{strategy}{(assert)}
\carg{feasible}
\newline\hspace*{1in}
\carg{verbose?})}
\item[effect:]  This is the primitive proof command
used to construct an abstraction 
of the mu-calculus formulas in the given goal.

The mu-calculus formulas in the goal that contain quantification
over the concrete state type \emph{cstate} are abstracted with
respect to both predicate and data abstraction maps given in \emph{amap}.
The result is a corresponding mu-calculus formula over the abstract
state type \emph{astate}.  Both \emph{cstate} and \emph{astate} are
expected to be type expressions, and \emph{amap} is a list of
pairs of field-name (from the record type \emph{astate})
and a function from the concrete state type \emph{cstate} to
the type (which currently must be a boolean or a scalar type)
corresponding to the 
field-name in the type \emph{astate}\@. 
  The \emph{strategy} argument
takes a proof command that is used to discharge the proof obligations that
arise in the construction of the abstraction.  The default strategy
is \texttt{(assert)}.  Various forms of \indtt{grind} are also suitable
though significantly more expensive in terms of time.   
The \texttt{feasible}
argument takes a predicate in the abstract state \emph{astate}
that characterizes the feasible abstract states.  This is needed
when the abstracted formulas contain quantifiers of existential strength. 
Each abstract state corresponds to a set of concrete states, but the
latter set might be empty leading to an existential formula that is
satisfiable at the abstract level but not at the concrete level.
Finally, the \emph{verbose?}\ flag prints out an extensive listing
of the proof obligations generated during abstraction and the
success or failure of the proof effort.
\end{description}

\prdolsubsection{model-check}{CTL Model Checker}

\begin{description}
\item[syntax:] \texttt{(model-check \optl\ \cargdflt{dynamic-ordering?}{t}
\cargdflt{cases-rewrite?}{t} \carg{defs}
\newline\hspace*{1in}
\carg{theories} \carg{rewrites}
\carg{exclude} \carg{irredundant?})}

\item[effect:]  This command is still quite experimental.
It has the effect of rewriting with respect to the theories that
define the CTL operators in terms of the mu-calculus, and then applying
\indtt{musimp}, the mu-calculus model checker to the result.

The \emph{dynamic-ordering?}\ flag can be set to \texttt{nil} to turn off the
dynamic reordering of variables in order to reduce BDD size.

The \emph{cases-rewrite?}\ flag can be set to \texttt{nil} to avoid rewriting
and simplification within unresolved selections within a \texttt{CASES}
expression for the sake of efficiency.

The commands \emph{defs}, \emph{theories}, \emph{rewrites}, and \emph{exclude}, are used exactly as in \indtt{install-rewrites} to set
up rewrite rules for use in simplification prior to model checking.

The model checker invoked by \indtt{ musimp} uses the same BDD package
as the \indtt{bddsimp} command.  The results of Boolean simplification
and model checking are returned in sum-of-products form as a
disjunction of conjunction of literals.  Some of the disjuncts
might be redundant but generating a minimal set of disjunctions is
expensive.  The flag \emph{irredundant?}\ when set to \texttt{t}
allows a less expensive redundant sum-of-products to be returned as the
result.

The model checker either verifies the goal, returns a collection of
subgoals that serve as counterexamples to the given mu-calculus assertion,
or gives an indication that the result cannot be translated.  The
counterexamples correspond to the set of states for which the mu-calculus
assertion fails.

\begin{usage}{}
\item[\texttt{(model-check :theories ("transitions" "props")
:irredundant?\ T)}]: Translates the given sequent containing CTL or
mu-calculus assertions into a Boolean mu-calculus, invokes a BDD-based
symbolic model checker on this, and either proves the result or returns a
collection of subgoals.

\item[\texttt{(model-check :dynamic-ordering? nil)}]: Invokes CTL/mu-calculus
model checking procedure on the subgoal but with dynamic reordering of
BDDs disabled.  The dynamic reordering tries to reduce the size of the
BDDs but can be expensive in terms of time. 
\end{usage}
\end{description}

\prsubsection{musimp}{Mu-Calculus Model Checker}

\begin{description}
\item[syntax:] \texttt{(musimp \optl\ \cargdflt{fnums}{*}
\carg{dynamic-ordering?}\ \carg{irredundant?}\ \carg{verbose?})}

\item[effect:] This command is primarily used in the \indtt{model-check}
strategy to invoke the BDD-based, symbolic mu-calculus model checker.  A
glaring weakness of this model checker is that it does not generate a
counterexample trace.  The outcome of the command is usually a collection
of subgoals corresponding to the states that violate the mu-calculus
formula given by the sequent formulas selected using \emph{fnums}.

When set to \texttt{t} the \emph{irredundant?}\ flag computes
the disjunctive normal form of the result (which can take quite a bit of
time).  The \emph{verbose?}\ flag controls the amount of information
printed, and is mostly useful for debugging.

\end{description}

\index{Proof Rules!Model Checking|)}

\section{Converting Strategies to Rules}
\index{Proof Strategies!Converting to Rules}
\index{Proof Rules}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{apply} & \emph{primitive}
  & apply a proof strategy in a single atomic step\\\hline
\end{tabularx}


\prsubsection{apply}{Make Proof Strategies Atomic}
\begin{description}
\item[syntax:] \texttt{(apply \carg{strategy}\ \optl\ \carg{comment}
\carg{save?}\ \carg{time?}\ \carg{timeout})}

\item[effect:] The \indtt{apply} rule takes an application of a proof
\emph{strategy} and applies it as a single atomic step that generates
those subgoals left unproved by the proof strategy.  The \indtt{apply}
rule is frequently used when one wishes to employ a proof strategy but is
not interested in the details of the intermediate steps.  A number of
defined rules employ \indtt{apply} to suppress trivial details.

The optional \emph{comment} field can be used to provide a format string
to be used as commentary while printing out the proof.  If the
\texttt{save?}\ flag is set to \texttt{t}, the \texttt{apply} step is
saved even if the applied strategy results in no change to the proof.
This is useful if, for example, the command within the apply uses the
\texttt{lisp} command to change a Lisp variable for use elsewhere in the
proof.  The \texttt{time?}\ flag when \texttt{t} is used to return timing
information regarding the applied step.

The \emph{timeout} may be set to an integer to indicate that the apply
step should give up after the specified number of seconds.  If it succeeds
before then, it is treated exactly as an \texttt{apply}, and removes the
\emph{timeout} argument from the saved proof, so that it will succeed in
the same way even if the proof is subsequently rerun on a slower machine.
If it fails, the proof state is restored, and the \emph{timeout} argument
is retained.

\begin{usage}{}

\item[\texttt{(apply (then (skolem 2 ("a4" "b5")) (beta) (flatten)}]
\texttt{"Skolemizing and beta-reducing")} : 
The \indtt{then} strategy performs each of the steps given by its
arguments in sequence.  Wrapping this strategy in an \indtt{apply} ensures
that the intermediate steps in the sequence are hidden.
 The given commentary string is printed out as part of
the proof.

\item[\texttt{(apply (try (skolem!) (flatten) (ground)))}] : This applies
a strategy that applies \texttt{(skolem!)} to the current goal, and if that
``succeeds,'' applies \texttt{(flatten)} to the resulting subgoals, and
otherwise it applies \texttt{(ground)} to the current goal.  The above
rule carries out this strategy in an atomic step and returns the
resulting subgoals.

\item[\texttt{(apply (grind) :save? T :time? T)}] Applies the
\texttt{grind} strategy but saves the step even when \texttt{grind} has
no effect, and returns timing information. 
\end{usage}

\item[errors:] No error messages are generated by apply.
\end{description}

\section{Using Default Strategies}

\begin{tabularx}{\textwidth}{|l|l|X|}\hline
\indtt{default-strategy} & \emph{defined}
  & invoke default strategies\\\hline
\end{tabularx}


\prdolsubsection{default-strategy}{Invoke Default Strategies}
\begin{description}
\item[syntax:] \texttt{(default-strategy)}

\item[effect:] The \texttt{default-strategy} is a strategy that makes it
easy to invoke user-defined strategies as defaults.  It looks for a
strategy of the name \texttt{\emph{th}-strategy}, where \texttt{\emph{th}}
is the current theory (i.e., the theory containing the formula being
proved).  If that is not defined, it looks for a strategy named
\texttt{context-strategy}, and if that is not found, it invokes
\texttt{(grind)}.  This strategy is the default for many of the commands
that apply proofs across many formulas; see the System Guide for details.

\end{description}

\pagebreak

\chapter{Proof Strategies}\label{strategy}
\index{Proof Strategies|(}
\index{Strategies|see{Proof Strategies}}
\index{Rules|see{Proof Rules}}


We have so far described the primitive proof rules employed by PVS to
construct proofs.  Since it would be moderately tedious to construct
proofs using only the primitive proof rules, there is a simple language
for defining more powerful proof rules and proof strategies for
combining proof rules.  A \emph{proof strategy} is intended to capture
patterns of inference steps.  A \emph{defined proof rule} is a strategy
that is applied in a single atomic step so that only the final effect of
the strategy is visible and the intermediate steps are hidden from the
user.  There are four basic forms for constructing strategies or proof
rules: recursion, let, backtracking, and the conditional form.  Lisp
expressions can be employed in constructing strategies as shown below.
There is a special purpose interpreter for strategy expressions.  An
advanced user would  need to study the interpreter.  The crucial
aspect of PVS commands is that the arguments are not evaluated.  We
use a substitution model of evaluation.  Lisp code can only appear in
the conditional of an \indtt{if} strategy and in the bindings of a \texttt{let} strategy.

\section{Global Variables used in Strategies}

The following global variables are kept current with each proof state
and can be used within strategies.  

\noindent
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\indtt{*ps*} & Current proof state \\\hline
\indtt{*goal*} & Goal sequent of current proof state \\\hline
\indtt{*label*} & Label of current proof state  \\\hline
\indtt{*par-ps*} & Current parent proof state \\\hline
\indtt{*par-label*} & Label of current parent \\\hline
\indtt{*par-goal*} & Goal sequent of current parent \\\hline
\indtt{*+*} & Consequent sequent formulas \\\hline
\indtt{*-*} & Antecedent sequent formulas \\\hline
\indtt{*new-fmla-nums*} &  Numbers of new formulas in current sequent
\\\hline
\indtt{*current-context*} & Current typecheck context \\\hline
\indtt{*module-context*} & Context of current module \\\hline
\indtt{*current-theory*} & Current theory \\\hline 
\end{tabularx}

\section{Data Structures}

We now document the various operations on PVS data structures for terms,
formulas, 
and proof goals that are needed for writing nontrivial PVS proof
strategies.  PVS data structures are defined as classes in the Common Lisp
Object Sysem (CLOS).  Each class is defined by indicating its slots.
Classes can be defined as subclasses of one or more \emph{superclasses}
by introducing the additional slots.  For example, the proof state
that is the root node of a proof is defined as a subclass of an ordinary
proof state that contains an extra slot for referring to the formula
declaration corresponding to the 
proof.  Data objects corresponding to a class are called \emph{instances}\@.  If a Lisp term $t$ has instance $v$ as its value, then
\texttt{(show \(t\))} displays the slot values of $v$\@.  With PVS
data structures, if value $v$ is an instance of class \texttt{c}, then
\texttt{c?}\ is the recognizer corresponding to the class so that
\texttt{(c?~\(v\))} is \texttt{t}.  Furthermore, if \texttt{c} is a subclass of
class \texttt{b}, then \texttt{(b?~\(v\))} is also \texttt{t}\@.  If \texttt{s} is a
slot name in class \texttt{c}, then \texttt{(s \(v\))} returns the corresponding
slot value in $v$\@.    A slot value is destructively updated by
\texttt{(setf (s \(v\)) \(u\))}, which sets the slot value of slot \texttt{s}
in $v$ to $u$\@.  An instance can be nondestructively copied and updated
by \texttt{(copy \(v\) 's1 \(u_1\) 's2 \(u_2\))}, which returns a copy of
$v$ with slot \texttt{s1} set to $u_1$ and \texttt{s2} set to $u_2$\@.
There is a lazy form of copy where \texttt{(lcopy \(v\) 's1 \(u_1\) 's2
\(u_2\))}  creates a new copy only when the updates actually change
the slot values.

The class \texttt{proofstate} of proof states consists of a number of slots.
These slots include:

\noindent
\begin{tabularx}{\textwidth}{|l|X|}\hline
\indtt{label} & Displayed label of proof state\\\hline
\indtt{current-goal} & Sequent part of proof state \\\hline
\indtt{current-rule} & Rule being applied to current proof state \\\hline
\indtt{alist} & Decision procedure data structures \\\hline
\indtt{done-subgoals} & List of proof states of completed subgoals
\\\hline
\indtt{pending-subgoals} & List of processed but incomplete subgoals
\\\hline
\indtt{remaining-subgoals} & List of unprocesses subgoals\\\hline
\indtt{current-subgoal} & Proof state currently being processed \\\hline
\indtt{subgoalnum} & Number of current proof state as subgoal of parent
\\\hline
\indtt{context} & Current typecheck context  \\\hline
\indtt{parent-proofstate} & Parent proof state \\\hline
\indtt{justification} & Proof of subtree \\\hline
\indtt{current-auto-rewrites} & Current rewrite rules \\\hline
\end{tabularx}

Only a few of these are really relevant for writing strategies,
and these are typically the ones that are already captured in
global variables.

The global variable \texttt{*ps*} is always bound to the currently active
proof goal.  Each proof goal is an instance of class \texttt{proofstate}\@.
The sequent corresponding to the proof goal is kept in the global variable
\indtt{*goal*} and appears in the \indtt{current-goal} slot of the
proofstate.   The current sequent is an instance of the
class \texttt{sequent} which has the slots:

\noindent
\begin{tabularx}{\textwidth}{|l|X|}\hline
\indtt{s-forms} & List of active sequent  formulas \\\hline
\indtt{hidden-s-forms} & List of hidden sequent formulas \\\hline
\end{tabularx}

A sequent formula is of class \texttt{s-formula} and the
main slot here is \texttt{formula} so that if \texttt{sf} is a sequent formula,
\texttt{(formula sf)} is the expression corresponding to the formula.
This expression is a negation in the case of an antecedent formula.

Typical formulas are either negations, disjunctions, conjunctions,
implications, equalities, equivalences, conditional expressions,
arithmetic inequalities, or  universally or existentially
quantified expressions.  Quantified expressions are in the class 
\texttt{binding-expr} with slots \texttt{bindings} which returns the
bound variables, and \texttt{expression}, which returns the body of
the binding expression.  The other forms are all instances of
the \texttt{application} class consisting of a slot for the
\texttt{operator} and one for the \texttt{argument}.  The first or
only argument of an application \texttt{expr} can be obtained by
\texttt{(args1 expr)}\@.  The second argument, if any, can be obtained
by \texttt{(args2 expr)}\@.   The predicates for recognizing
the different connectives are summarized in the following table.
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Connective} & {\bf Recognizer Form}\\\hline
Negation & \texttt{(negation?\ expr)} \\\hline
Disjunction & \texttt{(disjunction?\ expr)} \\\hline
Conjunction & \texttt{(conjunction?\ expr)} \\\hline
Implication & \texttt{(implication?\ expr)} \\\hline
Equality & \texttt{(equation?\ expr)} \\\hline
Equivalence/Equality & \texttt{(iff?\ expr)} \\\hline
Conditional & \texttt{(branch?\ expr)} \\\hline
Universal Formula & \texttt{(forall-expr?\ expr)} \\\hline
Existential Formula & \texttt{(exists-expr?\ expr)} \\\hline
\end{tabular}
\end{center}


\section{Selecting Sequent Formulas}\label{selection}

 Several Lisp functions  select sequent formulas
given their labels or numbers, or collect the numbers 
of selected sequent formulas.  Given a sequent \texttt{seq}, typically obtained
by \texttt{(s-forms *goal*)} and a list of labels or formula
numbers \texttt{fnums},  the Lisp expression \texttt{(select-seq seq fnums)}
returns the list of sequent formulas in \texttt{seq} corresponding to the
given \texttt{fnums}\@.  The Lisp expression \texttt{(delete-seq seq fnums)}
returns the list of sequent formulas in \texttt{seq} that are not
selected by the given \texttt{fnum}\@.  If we are interested in
selecting the sequent formulas according to some predicate, then
the Lisp expression \texttt{(gather-seq seq yes-fnums no-fnums pred)}
returns the list of sequent formulas in \texttt{seq} that are selected
by \texttt{yes-fnums} but not by \texttt{no-fnums} such that the formula part
of the sequent formula satisfies the unary predicate given by \texttt{pred}\@.  Given a sequent formula \texttt{sf} in \texttt{(s-forms *goal*)} or in the list returned by \texttt{gather-seq}, the Lisp expression
\texttt{(formula sf)} returns the actual PVS term corresponding to the
sequent formula.  Note that the formula numbers input to \texttt{gather-seq}
can also \texttt{be '*} (for all the formulas), \texttt{'+} (for the
consequent formulas), and \texttt{'-} (for the antecedent formulas),
and also formula labels. 

Since many commands take  formula numbers or lists of formula numbers as
arguments, it is useful to select these numbers rather than the formulas
themselves.  The Lisp expression \texttt{(gather-fnums seq yes-fnums no-fnums
pred)} returns the list of all the formula numbers of sequent formulas in
\texttt{seq} corresponding to \texttt{fnums} that satisfy the predicate \texttt{pred}\@.  Note that any reference to the actual PVS term representing
the sequent formula \texttt{sf} in the predicate \texttt{pred} will have to be
of the form \texttt{(formula sf)}\@.  


Thus, the Lisp expression
\begin{alltt}
  (gather-seq (s-forms *goal*)
              '-
              nil
              \#'(lambda (sf) (and (negation? (formula sf))
                               (forall-expr? (args1 (formula sf))))))
\end{alltt}
collects the list of universally quantified
antecedent formulas, and the Lisp expression
\begin{alltt}
  (gather-fnums (s-forms *goal*)
                '-
                nil
              \#'(lambda (sf) (and (negation? (formula sf))
                               (forall-expr? (args1 (formula sf))))))
\end{alltt}
returns the corresponding list of formula numbers.





\section{Strategy Expressions}

We describe the more easily understood aspects of strategies below.  Any
strategy expression can be typed in at the \texttt{Rule?}\ prompt in a
proof.  The syntax for strategy expressions is as follows:

\begin{eqnarray*}
\pair{step} &:= & \pair{\textit{primitive-rule}}\\
           & | & \pair{\textit{defined-rule}}\\
           & | & \pair{\textit{defined-strategy}}\\
           & | & (\indtt{quote}\ \pair{\textit{step}})\\
           & | & (\indtt{try}\ \pair{\textit{step}}\ \pair{\textit{step}}\ \pair{\textit{step}})\\
           & | & \texttt{(if}\ \pair{\textit{lisp-expression}}\ \pair{\textit{step}}\ \pair{\textit{step}}\texttt{)}\\
           & | & \texttt{(let\ (}\{\texttt{(}\pair{\textit{symbol}}\ \pair{\mbox{\emph{lisp-expression}}}\texttt{)}\}^+\texttt{)}\ \pair{\textit{step}}\texttt{)}
\end{eqnarray*}

\section{Defining Strategies}

User-defined strategies should be saved in a file called
\indtt{pvs-strategies}.  PVS loads strategies from files of this name from
both the user's home directory and the current context
directory.\footnote{Note: changing contexts does not remove the strategies
or supporting Lisp forms, so if there is a local \texttt{pvs-strategies}
file it is probably best to quit PVS and restart it in the new context.}
A strategy definition has the form:

\begin{alltt}
     (defstep \emph{name}
              (\emph{required-parameters}
                \&optional \emph{optional-parameters}
                \&rest \emph{parameter})
         \emph{strategy-expression}
         \emph{documentation-string}
         \emph{format-string})
\end{alltt}

This generates both a (blackbox) defined rule \emph{name} and a (glassbox)
strategy \emph{ name\texttt{\char36}}.  There are two other definition
forms that are essentially similar to \indtt{defstep}.  These are
\indtt{defstrat} and \indtt{defhelper}.  The \indtt{defhelper} version is
identical to \indtt{defstep} but is used for defining strategies that are
only meant to be used in the definition of other strategies and are not
likely to be invoked directly by the user, hence they are not shown with
the \texttt{M-x help-pvs-prover} commands, unless invoked with an argument
(e.g., C-u).  The currently defined helper commands are:
\begin{description}
\item[\indtt{tcc}] The different classes of TCCs have their own
strategies, which are assigned by default.  Most of them default to
\indtt{tcc}, which takes an optional \emph{defs} argument (default
\texttt{!}) and simply invokes \texttt{(grind :defs defs)}.  Any of these,
including \texttt{tcc}, may be redefined, usually in a
\indtt{pvs-strategies} file.
\begin{description}
\item[\indtt{subtype-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{termination-tcc}:] calls \texttt{(tcc !)}
\item[\indtt{well-founded-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{monotonicity-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{existence-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{assuming-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{mapped-axiom-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{cases-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{cond-coverage-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{cond-disjoint-tcc}:] calls \texttt{(tcc explicit)}
\item[\indtt{same-name-tcc}:] calls \texttt{(tcc explicit)}
\end{description}

\item[\indtt{expand1*}:] invoked by \indtt{expand*}
\item[\indtt{label-fnums}:] invoked by \indtt{with-labels}
\item[\indtt{rewrite-directly-with-fnum}:] invoked by \indtt{rewrite-with-fnum}
\item[\indtt{chain-antecedent}:] invoked by \indtt{forward-chain}
\item[\indtt{chain-antecedent*}:] invoked by \indtt{chain-antecedent}
\item[\indtt{detuple-boundvars-in-formulas}:] invoked by \indtt{detuple-boundvars}
\end{description}

The \indtt{defstrat} version defines only a glassbox strategy called
\emph{name} and the rule or blackbox version is not defined.  The
\indtt{defstrat} form does not take the final format-string argument given
to \indtt{defstep}.  The differences between a defined rule and a strategy
are:
\begin{enumerate}

\item A defined rule like a primitive rule is atomic, whereas a strategy
could expand to the application of several atomic rules.

\item Only the expanded form of a strategy is saved to be rerun, whereas
a rule is saved and rerun in its unexpanded form.

\item A defined rule merely returns the unproved subgoals, whereas a
strategy returns the expanded proof tree.  For example, \texttt{prop\char36} and \texttt{ground} are strategies and \indtt{prop} and \texttt{ground} are their corresponding rule versions.  The former are glass
boxes in that their internal behavior is visible to the user, whereas
the latter are black boxes.
\end{enumerate}

Otherwise, defined rules and strategies are very similar.  Both can be
recursive and can involve the application of a number of primitive proof
steps to achieve their effect.  

In the following, we describe some important strategies used for defining
new proof rules.

\section{The Basic Strategies}

\begin{tabular}{|l|l|}\hline
\indtt{if} & Conditional strategy \\\hline
\indtt{let} & Evaluate/bind Lisp expressions/values\\\hline
\indtt{quote} & Identity strategy \\\hline
\indtt{try} & Subgoaling and Backtracking \\\hline
\end{tabular}

\prsubsection{if}{Conditional Selection of Strategies}

\begin{description}

\item[syntax:] \texttt{(if \carg{condition} \carg{step1} \carg{step2})}

\item[effect:] Here \emph{condition} is some Lisp code that is
evaluated against the current goal.  If \emph{condition} evaluates to
\texttt{nil}, then \emph{step2} is applied, else \emph{step1} is applied.

\item[usage:] \texttt{(if (equal (get-goalnum *ps*) 1) (ground) (prop))} :
If the current goal (\texttt{*ps*} is the current proofstate) is the first
subgoal of its parent, the apply \texttt{(ground)}, else apply
\texttt{(prop)}.

\end{description}


\prsubsection{let}{Use Lisp in Strategies}
\begin{description}

\item[syntax:] \texttt{(let ((\carg{var$_1$} \carg{lexpr$_1$}) $\ldots$
(\carg{var$_n$} \carg{lexpr$_n$})) \carg{step})}

\item[effect:] Here \emph{var$_1$} through \emph{var$_n$} are symbols,
and \emph{lexpr$_1$} through \emph{lexpr$_n$} are Lisp expressions.
The \texttt{let}-form allows some values to be computed to be plugged into
strategies.  The scope of each let-binding extends over the later
bindings and the body of the \indtt{let} strategy, so that it is similar
to the \texttt{let*} construct of Lisp.

\item[usage:] A simplified definition of the basic querying strategy is shown
below.  Here, a defined Lisp function \texttt{qread} is used to generate the
\texttt{"Rule?"} query and read the resulting user input.
{\smaller
\begin{alltt}
  (query*) = (let ((input (qread "Rule? ")))
               (try input (query*) (query*)))
\end{alltt}}

The \indtt{then} strategy has the definition shown below:
{\smaller
\begin{alltt}
  (let ((x (when steps (car steps)))
	(y (when steps (cons 'then (cdr steps)))))
    (if steps (if (cdr steps) (try x y y) x) (skip)))
\end{alltt}}
\end{description}

\prsubsection{quote}{The Identity Strategy}

\begin{description}

\item[syntax:] \texttt{(quote \carg{step})}

\item[effect:] The strategy expression \texttt{(quote \emph{step})} simply
evaluates to \emph{step} itself.  This is only useful in support of the
\indtt{let} strategy, in order to ensure that forms are only evaluated
once.

The reason it is needed is that it is quite typical to construct a Lisp
expression corresponding to a strategy but this then needs to be unquoted
to be used as a strategy.  For example the strategy \texttt{(then \rest\
steps)} is given the recursive definition
\begin{alltt}
  (let ((x (when steps (car steps)))
        (y (when steps (cons 'then (cdr steps)))))
    (if steps (if (cdr steps) (try x y y) x) (skip)))
\end{alltt}
In evaluating the body of this definition, the quoted forms of the values
of the bindings for \texttt{x} and \texttt{y} are substituted for these
variables into the body of the let-expression.  When any of these values
are to be evaluated as strategies, the \texttt{quote} simply causes the
underlying steps to be evaluated.

\item[notes:] It is probably a mistake to use this strategy directly.
\end{description}

\prsubsection{try}{Strategy for Subgoaling and Backtracking}

\begin{description}

\item[syntax:] \texttt{(try \carg{step1} \carg{step2} \carg{step3})}

\item[effect:] This is the basic control strategy.  It applies
\emph{step1} to the current goal.  If \emph{step1} succeeds and generates
subgoals, then \emph{step2} is applied to those subgoals.  If \emph{step1}
does nothing, \ie\ behaves as a \texttt{(skip)} step, then \emph{step3} is
applied to the current goal.  The \indtt{try} step thus provides a
backtracking mechanism for proof search that can be controlled by
appropriately signalling failure.  The following identities describe the
behavior of the \indtt{try} strategy (assuming that the \texttt{lemma}
step succeeds):
\begin{enumerate}\label{trypage}
\item \texttt{(try (skip) (assert) (split)) = (split)}
\item \texttt{(try (try (skip) (assert) (fail)) (split) (flatten)) = (flatten)} 
\item \texttt{(try (try (lemma "assoc") (fail) (assert)) (split) (flatten))
= (flatten)}
\item \texttt{(try (try (lemma "assoc") (assert) (fail)) (split) (flatten))
= (then (lemma "assoc") (assert) (split))}
\end{enumerate}

The important thing to note is that if step $A$ succeeds on the current
goal, then applying \texttt{(try $A$ $B$ $C$)} causes the alternative $C$
to be closed.  Then \texttt{(fail)} backtracks to the last open (\ie\ not
closed) alternative.

\begin{usage}{}

\item[\texttt{(try (flatten) (propax) (split))}] : Applies the disjunctive
simplification step to the current goal.  If the goal does disjunctively
simplify, then the \texttt{(propax)} step is applied to the resulting
subgoal.  Otherwise the conjunctive splitting step is applied to the
current goal.

\item[]\texttt{(try (try (flatten) (fail) (skolem 1 ("a" "b"))) (postpone)
(prop))} : If the current goal disjunctively simplifies, then backtrack
and apply \texttt{(prop)}, otherwise introduce skolem constants and if that
fails, try propositional simplification, otherwise postpone.  Notice how
\texttt{(fail)} is used to trigger backtracking from a subgoal.
\end{usage}

\end{description}



\section{Strategies}\label{defined strategies}

We have already briefly discussed the differences between strategies and
defined rules.  In many of the cases, defined rules are analogous to the
\emph{tactics} of LCF, and strategies are like the \emph{tacticals}
which are used to combine rules in various ways.

\prsubsection{branch}{Assign Strategies to Subgoals}
\begin{description}

\item[syntax:] \texttt{(branch \carg{step} \carg{steplist})}

\item[effect:] Just like \indtt{spread} except that when \emph{steplist}
has only $n$ elements and \emph{step} generates more than $n$ subgoals,
the $n$'th element of \texttt{steplist} is also applied to the subgoals
following the $n$'th one (in \indtt{spread}, \texttt{skip} is used).  This
is generally useful when only the first few subgoals generated by
\emph{step} require special attention and the rest of the subgoals yield
to some uniform strategy.
\end{description}

\prsubsection{checkpoint}{Checkpoint Handling}
\begin{description}

\item[syntax:] \texttt{(checkpoint)}

\item[effect:] A synonym for \texttt{query*}: inserting
\texttt{(checkpoint)} into an edited proof and rerunning it causes the
non-checkpointed subproofs to simply be installed (using
\indtt{just-install-proof}) so that the proof quickly run up to the
checkpoint.

\item[notes:] This command is not meant to be used directly; see the User
Guide for details on adding checkpoints to proofs. 
\end{description}


\prsubsection{else}{A Simple Backtracking Strategy}
\begin{description}

\item[syntax:] \texttt{(else \carg{step1} \carg{step2})}

\item[effect:] First applies \emph{step1} and if that does nothing,
then \emph{step2} is applied to the present goal.  The definition of
\texttt{else} is just \texttt{(try \emph{step1} (skip) \emph{step2})}.
\end{description}

\prsubsection{just-install-proof}{Install Proof without Rerunning}
\begin{description}

\item[syntax:] \texttt{(just-install-proof \carg{proof})}

\item[effect:] Installs, the \emph{proof} without actually checking it,
and treats the current subgoal as proved, but marks the proof as
unfinished.  Used in conjunction with \texttt{checkpoint}.

\item[notes:] This command is not meant to be used directly; see the User
Guide for how it is used in editing proofs. 
\end{description}


\prsubsection{query*}{The Basic Interaction Strategy}

\begin{description}

\item[syntax:] \texttt{(query*)}

\item[effect:] This is the strategy that repeatedly queries the user for
the current rule or strategy.  PVS also invokes \indtt{query*} when all
other options have been exhausted and the prover is being used in an
interactive mode.
\end{description}



\prsubsection{repeat}{Iterate Along Main Proof Branch}

\begin{description}

\item[syntax:] \texttt{(repeat \carg{step})}

\item[effect:] First applies \emph{step} to the current goal.  If this
does nothing, then no further steps are indicated.  If the application
of \emph{step} generates subgoals, then \texttt{(repeat \emph{step})} is
recursively applied to the first of those subgoals (the main subgoal).
See \emph{repeat*} below.  The \emph{repeat} strategy must be used
cautiously.  It can easily cause loops since it is only terminated when
\emph{step} does nothing.  Some commands such as \indtt{assert} almost
always take effect even when they seemingly do nothing, and wrapping
these within a \indtt{repeat} can cause a loop.
\end{description}


\prsubsection{repeat*}{Iterate Along all Branches}
\begin{description}

\item[syntax:] \texttt{(repeat* \carg{step})}

\item[effect:] While \emph{repeat} only repeats the step for the main
branch of the proof, \indtt{repeat*} carries out the repetition along all
the subgoals resulting from the first application of \emph{step}.  The
repetition is continued along each branch until an application of \emph{step} has no effect.
\end{description}

\prsubsection{rerun}{Rerun a Proof or Partial Proof}

\begin{description}

\item[syntax:] \texttt{(rerun \optl\ \carg{proof} \carg{recheck?}\
\carg{break?})}

\item[effect:] This step can be used to rerun a partial or completed proof
from a previous attempt or from another branch of the proof.  This step is
largely used automatically by the system when it queries as to whether the
proof should be rerun.  The \emph{proof} argument can also be explicitly
given by the user using either the \emacstt{edit-proof} or
\emacstt{show-proof} commands to generate and edit such inputs.

The \emph{recheck?}\ flag when \texttt{t} is used to rerun an entire proof
expanding all steps so that only primitive proof steps are used.

By default the \texttt{rerun} step simply gives a warning when there is a
mismatch between the number of subgoals and the number of subproofs.  When
\emph{break?}\ is \texttt{t}, an error is produced instead.

This step can be used to:
\begin{enumerate}

\item Restore a partial proof to the state when the proof was
interrupted.

\item Recheck a completed proof.

\item Redo a proof following some changes to the specification.  It is
possible that the old proof only partially works for the changed
specification.  In this case, it is usually possible to clean up and
complete the resulting partial proof.

\item Apply a partial or completed proof from one subgoal to some other
subgoal in the proof attempt.
\end{enumerate}
 
\end{description}

\prsubsection{spread}{Assign Strategies to Subgoals}
\begin{description}

\item[syntax:] \texttt{(spread \carg{step} \carg{steplist})}

\item[effect:] First applies \emph{step1} and then applies the $i$'th
element of \emph{steplist} to the $i$'th subgoal.  If there are more steps
in \emph{steplist} than subgoals the remaining ones are ignored.  If there
are fewer, then \texttt{skip} is applied to the rest.  This is typically
used when \emph{step} splits the proof into multiple branches where a
different strategy is required for each of the branches.  See
\indtt{branch}.
\end{description}

\prsubsection{spread!}{Assigning Strategies to Subgoals with Error Checks}
\index{spread"!@{\texttt{spread"!}}|ii}
\begin{description}

\item[syntax:] \texttt{(spread!\ \carg{step} \carg{steplist})}

\item[effect:] Like \indtt{spread}, applies \emph{step} and then pairs the
steps in \emph{steplist} with the subgoals, but generates an error and
queries the user if the number of subgoals does not match the number of
subproofs.
\end{description}

\prsubsection{spread@}{Assigning Strategies to Subgoals with Warning Checks}
\index{spread"@@{\texttt{spread"@}}|ii}
\begin{description}

\item[syntax:] \texttt{(spread@ \carg{step} \carg{steplist})}

\item[effect:] Like \indtt{spread}, applies \emph{step} and then pairs the
steps in \emph{steplist} with the subgoals, but generates a warning if the
number of subgoals does not match the number of subproofs.
\end{description}


\prsubsection{then}{A Sequencing Strategy}

\begin{description}

\item[syntax:] \texttt{(then \rest\ \carg{steps})}

\item[effect:] Let the list \emph{steps} consist of the first element
\emph{step1} and the remaining steps \emph{rest-steps}.  This strategy
first applies the \emph{step1} to the current goal.  If any subgoals are
generated, then \texttt{(then :steps \emph{rest-steps})} is applied to
each of these subgoals.  If \emph{step1} has no effect, then \texttt{(then
:steps \emph{rest-steps})} is applied to the original goal.  The main body
of \indtt{then} is essentially \texttt{(try \emph{step1} (then
\emph{rest-steps}) (then \emph{rest-steps}))}.
\end{description}


\prsubsection{then@}{Apply Steps in Sequence Along Main Branch}
\index{then"@@{\texttt{then"@}}|ii}
\begin{description}

\item[syntax:] \texttt{(then@ \rest\ \carg{steps})}

\item[effect:] This is a version of \indtt{then} where the given steps are
applied in sequence only along the main branch of the proof, \ie\ if the
the given rule is \texttt{(then@ \emph{step$_1$} \ldots \emph{step$_n$})},
then \emph{step$_{i+1}$} is only applied to the first subgoal of
\emph{step$_i$}.
\end{description}


\prsubsection{time}{Time a Given Strategy}
\begin{description}
\item[syntax:] \texttt{(time \carg{strategy})}

\item[effect:] Executes the given rule or strategy as an atomic step (like
the \indtt{apply} command) while printing out the run times at each of the
leaf nodes.  This command has no other effect on the proof.  It only
prints out timing information when there are leaf nodes generated and
yields no information when the given strategy succeeds in proving the
subgoal.

\item[usage:] \texttt{(time (then (lift-if) (prop) (skolem!)))}

\item[errors:] No error messages other than those generated by the given
strategy.

\end{description}



\prsubsection{try-branch}{Branch or Backtrack}

\begin{description}

\item[syntax:] \texttt{(try-branch \carg{step1} \carg{steplist} \carg{step2})}

\item[effect:] This is a combination of the \indtt{try} and \indtt{branch}
strategies.  It is like branch for \emph{step1} and \emph{steplist}
except that when \emph{step1} has no effect, then \emph{step2} is
attempted on the original subgoal.
\end{description}
\index{Proof Strategies|)}

%\addcontentsline{toc}{chapter}{References}
\bibliographystyle{plain}
\bibliography{../pvs}

%\addcontentsline{toc}{chapter}{Index}   %% Put entry in T-O-C
{\smaller\smaller\printindex}

%\input{prover-r.ind}

\end{document}
