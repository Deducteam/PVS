			  PVS Language Summary

============================Example Theories==================================

orderings[t: TYPE] : THEORY
  BEGIN
    x, y, z: VAR t
    pp, qq: VAR predicate[t]
    <= : VAR predicate[[t,t]]

    reflexive?(<=) : bool = (FORALL x: x <= x)

    antisymmetric?(<=) : bool =
      (FORALL x, y: (x <= y & y <= x) => x = y)

    transitive?(<=) : bool =
      (FORALL x, y, z: (x <= y & y <= z) => x <= z)

    partial_order?(<=) : bool =
      reflexive?(<=) & antisymmetric?(<=)
                     & transitive?(<=)

    linear?(<=) : bool =
      (FORALL x, y : x <= y OR y <= x)

    total_order?(<=) : bool =
      partial_order?(<=) & linear?(<=)
  END orderings

sort [domain, range: TYPE,
      (IMPORTING orderings[range], orderings[domain])
      d_order: (total_order?[domain]),
      r_order: (partial_order?[range])] : THEORY
  BEGIN
    A, B, C: VAR ARRAY[domain->range]
    sorted?(A): bool =
      (FORALL (x, y: domain): (d_order(x, y) & x /= y)
                    => NOT r_order(A(y), A(x)))
  END sort


list[t:TYPE] : DATATYPE
  BEGIN
    null: null?
    cons (car: t, cdr :list) :cons?
  END list


=============================Lexical Rules====================================

Comments start with '%' and go to the end of the line

Identifiers are composed of letters, digits, question mark, and underscores;
they must begin with a letter.

Numbers are composed of digits; floating point numbers are not supported.


============================Reserved Words====================================

ALL         COROLLARY    FALSE       LEMMA         SUBLEMMA   
AND  	    DATATYPE     FORALL      LET           THEN       
ARRAY  	    ELSE         FORMULA     MEASURE       THEOREM    
ASSUMING    ELSIF        FROM        NOT           THEORY     
ASSUMPTION  END          FUNCTION    O             TRUE       
AXIOM  	    ENDASSUMING  IF          OBLIGATION    TYPE       
BEGIN  	    ENDCASES     IFF         OF            IMPORTING  
BUT  	    ENDIF        IMPLIES     OR            VAR        
CASES  	    EPSILON      IN          PLET          WHEN       
CLAIM  	    EXISTS       LAM         PROPOSITION   WHERE      
CONJECTURE  EXPORTING    LAMBDA      RECURSIVE     WITH       
CONTAINING  FACT         LAW         SOME

===============================Special Symbols================================

&   (   )    *    +    ,   -   ->  .   /   /=   :   :=

;   <   <=   <=>  =    =>  >   >=  |   [    ]   [#  #]

{   }   (#   #)   \/   /\  ~   ==  []  <>


==============================Type Declarations===============================

----------------------Uninterpreted types and subtypes------------------------
foo: TYPE
some_nums: TYPE FROM number
nat_to_10: TYPE = {x:nat | x <= 10}
posint: TYPE = {x:integer | x > 0} CONTAINING 1
ptype: TYPE = (pred?)                    % same as {x | pred?(x)}

-------------------------------Function types---------------------------------

intf: TYPE = FUNCTION[int, int -> int]
altf: TYPE = [int, int -> int]           % same as above
inta: TYPE = ARRAY[int,int -> int]       % same as above

---------------------------------Tuple Types----------------------------------

tuptype: TYPE = [int, bool, [int -> int]]

--------------------------------Record types----------------------------------

stack: TYPE = [# pointer: nat, astack: ARRAY[nat -> t] #]

-------------------------------Dependent Types--------------------------------

pfun: TYPE = [# dom: predicate[t1], pfn:[(dom)->t2] #]
date: TYPE = [y,m:nat, {d:nat | d <= days(m,y))}]
tmod: TYPE = [n,m:int -> {x:nat | x < m}]

------------------------------Enumeration Types-------------------------------

color: TYPE = {red, green, blue}

----------------------------------Datatypes-----------------------------------

list[t:TYPE] : DATATYPE 
 BEGIN
  null: null?
  cons (car: t, cdr :list) :cons?
 END list

-----------------Imports, Exports, and Theory Abbreviations-------------------

IMPORTING orderings[int], set[foo[nat]]
EXPORTING foo, bar WITH set[foo]
pset: THEORY = sets[list[nat]]

---------------------Constants and Recursive Definitions----------------------

some_int: int
max: int = 10
abs: [int -> nat] = (LAMBDA x: IF x < 0 THEN -x ELSE x ENDIF)
abs(x:int): nat = IF x < 0 THEN -x ELSE x ENDIF
sum(f,x,y): int                      % f,x,y prev declared VAR
sum(f,(x,y:int)): int                % f prev declared VAR
fac(n): RECURSIVE nat =
   (IF n = 0 THEN 1 ELSE n * fac(n-1) ENDIF)
   MEASURE (LAMBDA n: n)

----------------------------Variable Declarations-----------------------------

x, y, z: VAR int
f: VAR [int -> [int -> int]]

----------------------------Formula Declarations------------------------------

transitive: AXIOM x < y AND y < z IMPLIES x < z
nonzero_fac: THEOREM fac(n) /= 0
poset: ASSUMPTION poset?(T,<=)   % Only in ASSUMINGs

=================================Expressions==================================

------------------------------Equality (=, /=)--------------------------------
Defined for any type; both sides must be the same type.  With boolean,
= is treated as IFF.

x * y = 4
true /= 1            % Illegal

-------------Arithmetic (+, -, *, /, <, <=, >, >=, 0, 1, 2, ...)--------------

((x + 1) * x) / 2 < x * x

--------Logical (true, false, AND, &, OR, IMPLIES, =>, NOT, IFF, <=>,
			 FORALL, ALL, EXISTS, SOME)                  ---------

(FORALL e: (EXISTS d: abs(f(x) - f(y)) < d) IMPLIES abs(x - y) < e)

--------------------------------IF-THEN-ELSE----------------------------------

The {\tt THEN} and {\tt ELSE} parts must have compatible types.

IF x=0 THEN 1 ELSIF y=0 THEN 2 ELSE y/x ENDIF

------------------------------------CASES-------------------------------------

Pattern matching on datatypes.

  CASES x OF
    cons(x,y): append(reverse(y), cons(x, null))
    ELSE null
  ENDCASES

---------Function application, lambda-abstraction & function update-----------

f(1,2)(0)
(lambda x: x + 1)
f WITH [(0) := 1, (1) := 0]

------------Record construction, field selection & record update--------------

(# pointer := 1, astack := (LAMBDA x: 0) #)
astack(r)                                   % r.astack NOT allowed
r WITH [pointer := 2, (astack)(1) := 1]

-----------------------Tuple construction & projection------------------------

(1, true, (LAMBDA (x:int) x + 37))
proj_3(tup)

----------------------------LET, PLET, & WHERE------------------------------

PLET is a parallel let; in the example below y depends on an outside x.
WHERE is like LET, but with the assignments and expression reversed.

LET x = 2, y:nat = x*x IN f(x,y)   % == f(2,4)
PLET x = 2, y:nat = x*x IN f(x,y)
f(x,y) WHERE x = 2, y:nat = x*x    % Like LET

----------------------------------Coercion------------------------------------

Coercion indicates the expected type to the typechecker to resolve ambiguity.

a + b:natural
(LAMBDA n -> nat: n - m)     % LAMBDA coercion

------------------------------------Names-------------------------------------

If foo is declared in theory bar, then the following are allowable references
(the first two may be ambiguous).

foo
foo[int]
bar[int].foo
