(BitvectorOneComplementDivision (IMP_BitvectorMultiplication_TCC1 0 (IMP_BitvectorMultiplication_TCC1-1 nil 3249114881 3290735699 ("" (use "N_size") nil nil) proved ((N_size formula-decl nil BitvectorOneComplementDivision nil)) 1197 670 nil nil)) (divrem_TCC1 0 (divrem_TCC1-1 nil 3249114881 3290735700 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 1446 700 nil nil)) (divrem_TCC2 0 (divrem_TCC2-1 nil 3249114881 3290735702 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 1697 780 nil nil)) (divrem_TCC3 0 (divrem_TCC3-1 nil 3249114881 3290735704 ("" (subtype-tcc) nil nil) proved ((nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 2555 1250 nil nil)) (divrem_TCC4 0 (divrem_TCC4-1 nil 3249114881 3290735707 ("" (termination-tcc) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 2161 1090 nil nil)) (divrem_TCC5 0 (divrem_TCC5-1 nil 3249114881 3290735709 ("" (subtype-tcc) nil nil) proved ((nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 2537 1250 nil nil)) (divrem_TCC6 0 (divrem_TCC6-1 nil 3249114881 3290735713 ("" (termination-tcc) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 1297 1040 nil nil)) (divrem_dvd_TCC1 0 (divrem_dvd_TCC1-1 nil 3249114881 3290735714 ("" (subtype-tcc) nil nil) proved nil 1072 710 nil nil)) (divrem_dvd_TCC2 0 (divrem_dvd_TCC2-1 nil 3249114881 3290735715 ("" (subtype-tcc) nil nil) proved nil 939 680 nil nil)) (divrem_dvd 0 (divrem_dvd-1 nil 3249114881 3290735723 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "divrem" +) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (inst?) (("1" (replace*) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "k!1") (("2" (inst?) (("2" (replace*) (("2" (hide-all-but 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((NOT const-decl "[bool -> bool]" booleans nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (left_shift const-decl "bvec[N]" bv_shift nil) (TRUE const-decl "bool" booleans nil) (- const-decl "bvec[N]" bv_arithmetic nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) 8416 3990 nil nil)) (divrem_dvs0_TCC1 0 (divrem_dvs0_TCC1-1 nil 3249114881 3290735726 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) 2257 1150 nil nil)) (divrem_dvs0_TCC2 0 (divrem_dvs0_TCC2-1 nil 3249114881 3290735729 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) 3168 1530 nil nil)) (divrem_dvs0 0 (divrem_dvs0-1 nil 3249114881 3290735776 ("" (use "N_size") (("" (induct "n") (("1" (grind) (("1" (apply-extensionality :hide? t) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (skosimp*) (("2" (expand "divrem" +) (("2" (rewrite "bv2nat_fill_F[N]") (("2" (assert) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (replace*) (("1" (hide -) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (expand "-") (("2" (rewrite " bv_sub_identity_R") (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) proved ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (= const-decl "[T, T -> boolean]" equalities nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (TRUE const-decl "bool" booleans nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (bv_sub_identity_R formula-decl nil bv_arith_minus_rules nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (left_shift const-decl "bvec[N]" bv_shift nil) (- const-decl "bvec[N]" bv_arithmetic nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 46912 8460 nil nil)) (bv2nat_left_false_inc 0 (bv2nat_left_false_inc-1 nil 3249114881 3290735797 ("" (use "N_size") (("" (skosimp*) (("" (case-replace "n!1=0") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (lemma " bv2nat_lem") (("1" (inst - "N" "(LAMBDA (i: below(N)): IF i < 1 THEN bv!1(i) ELSE FALSE ENDIF)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (expand "^") (("1" (expand "exp2") (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                          exp2(ii) *
                           IF ii < n!1
                             THEN b2n(bv!1(ii))
                           ELSE b2n(FALSE)
                           ENDIF)" "N-1" "0" "n!1-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case-replace "sigma(n!1, N - 1,
                    extend(LAMBDA (ii: below(N)):
                             exp2(ii) *
                              IF ii < n!1
                                THEN b2n(bv!1(ii))
                              ELSE b2n(FALSE)
                              ENDIF)) = 0") (("1" (hide -1) (("1" (case-replace "n!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                               exp2(ii) *
                                IF ii < 1 + n!1
                                  THEN b2n(bv!1(ii))
                                ELSE b2n(FALSE)
                                ENDIF)" "N-1" "0" "n!1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (case-replace "sigma(1 + n!1, N - 1,
                       extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < 1 + n!1
                                   THEN b2n(bv!1(ii))
                                 ELSE b2n(FALSE)
                                 ENDIF)) = 0") (("1" (hide -1) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n:nat):
                          0 *
                           extend(LAMBDA (ii: below(N)):
                                    exp2(ii) *
                                     IF ii < 1 + n!1
                                       THEN b2n(bv!1(ii))
                                     ELSE b2n(FALSE)
                                     ENDIF)
                                 (n)" "extend(LAMBDA (ii: below(N)):
                                 exp2(ii) *
                                  IF ii < 1 + n!1
                                    THEN b2n(bv!1(ii))
                                  ELSE b2n(FALSE)
                                  ENDIF)" "N-1" "1+n!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n:nat) :
                      0 *
                       extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < n!1
                                   THEN b2n(bv!1(ii))
                                 ELSE b2n(FALSE)
                                 ENDIF)
                             (n)" "extend(LAMBDA (ii: below(N)):
                             exp2(ii) *
                              IF ii < n!1
                                THEN b2n(bv!1(ii))
                              ELSE b2n(FALSE)
                              ENDIF)" "N-1" "n!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2nat_as_sum formula-decl nil bv_sum nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_split formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (fill const-decl "bit" bv nil) (above nonempty-type-eq-decl nil integers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (FALSE const-decl "bool" booleans nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 21565 10300 nil nil)) (bv2nat_right_false_inc 0 (bv2nat_right_false_inc-1 nil 3249114881 3290735822 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "bv2nat_as_sum[N]") (("" (rewrite "bv2nat_as_sum[N]") (("" (case-replace "n!1=0") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                         exp2(ii) *
                          IF ii < n!1
                            THEN b2n(FALSE)
                          ELSE b2n(bv!1(ii))
                          ENDIF)" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                          exp2(ii) *
                           IF ii < 1 THEN b2n(FALSE) ELSE b2n(bv!1(ii)) ENDIF)" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "b2n" -1 5) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                         exp2(ii) *
                          IF ii < n!1
                            THEN b2n(FALSE)
                          ELSE b2n(bv!1(ii))
                          ENDIF)" "N-1" "0" "n!1-1") (("1" (assert) (("1" (case-replace "sigma(0, n!1 - 1,
                   extend(LAMBDA (ii: below(N)):
                            exp2(ii) *
                             IF ii < n!1
                               THEN b2n(FALSE)
                             ELSE b2n(bv!1(ii))
                             ENDIF)) = 0") (("1" (replace*) (("1" (hide -1 -2) (("1" (assert) (("1" (case-replace "n!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (lemma "sigma_mult") (("1" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                        0 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))" "N-1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < 1 + n!1
                                   THEN b2n(FALSE)
                                 ELSE b2n(bv!1(ii))
                                 ENDIF)" "N-1" "0" "n!1") (("2" (assert) (("2" (case-replace "sigma(0, n!1,
                       extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < 1 + n!1
                                   THEN b2n(FALSE)
                                 ELSE b2n(bv!1(ii))
                                 ENDIF)) = 0") (("1" (replace*) (("1" (hide -1 -2) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                 exp2(ii) *
                                  IF ii < n!1
                                    THEN b2n(FALSE)
                                  ELSE b2n(bv!1(ii))
                                  ENDIF)" "N-1" "n!1" "n!1") (("1" (assert) (("1" (expand "sigma" -1 3) (("1" (expand "extend" -1 2) (("1" (replace -1) (("1" (assert) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat):
                          0 *
                           extend(LAMBDA (ii: below(N)):
                                    exp2(ii) *
                                     IF ii < 1 + n!1
                                       THEN b2n(FALSE)
                                     ELSE b2n(bv!1(ii))
                                     ENDIF)
                                 (n)" "extend(LAMBDA (ii: below(N)):
                                 exp2(ii) *
                                  IF ii < 1 + n!1
                                    THEN b2n(FALSE)
                                  ELSE b2n(bv!1(ii))
                                  ENDIF)" "n!1" "0") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n:nat):
                      0 *
                       extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < n!1
                                   THEN b2n(FALSE)
                                 ELSE b2n(bv!1(ii))
                                 ENDIF)
                             (n)" "extend(LAMBDA (ii: below(N)):
                             exp2(ii) *
                              IF ii < n!1
                                THEN b2n(FALSE)
                              ELSE b2n(bv!1(ii))
                              ENDIF)" "n!1-1" "0") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_mult formula-decl nil sums nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (extend const-decl "[nat -> nat]" bv_sum nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (exp2 def-decl "posnat" exp2 nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma def-decl "nat" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_split formula-decl nil sums nil) (= const-decl "[T, T -> boolean]" equalities nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FALSE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 25037 11680 nil nil)) (bv2nat_left_false_dec_TCC1 0 (bv2nat_left_false_dec_TCC1-1 nil 3249114881 3290735825 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 2621 1350 nil nil)) (bv2nat_left_false_dec_TCC2 0 (bv2nat_left_false_dec_TCC2-1 nil 3249114881 3290735828 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 3019 1360 nil nil)) (bv2nat_left_false_dec_TCC3 0 (bv2nat_left_false_dec_TCC3-1 nil 3249114881 3290735830 ("" (subtype-tcc) nil nil) proved nil 1507 800 nil nil)) (bv2nat_left_false_dec_TCC4 0 (bv2nat_left_false_dec_TCC4-1 nil 3249114881 3290735831 ("" (subtype-tcc) nil nil) proved nil 1564 680 nil nil)) (bv2nat_left_false_dec 0 (bv2nat_left_false_dec-1 nil 3249114881 3290735877 ("" (use "N_size") (("" (skosimp*) (("" (case-replace "n!1=N-1") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (lemma " bv2nat_lem") (("1" (inst - "N" "(LAMBDA (i: below(N)): IF i < 1 THEN bv!1(i-1+N) ELSE FALSE ENDIF)") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (expand "^") (("1" (expand "exp2") (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (case-replace "n!1=0") (("1" (assert) (("1" (expand "sigma") (("1" (expand "extend" 2 1) (("1" (expand "extend" 2 2) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))" "extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < N - 1
                                   THEN b2n(bv!1(ii))
                                 ELSE b2n(FALSE)
                                 ENDIF)" "N-2" "0") (("1" (split -) (("1" (replace -1) (("1" (expand "b2n") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                               exp2(ii) *
                                IF ii < N - n!1
                                  THEN b2n(bv!1(ii + n!1))
                                ELSE b2n(FALSE)
                                ENDIF)" "N-1" "0" "N-n!1-1") (("1" (assert) (("1" (case-replace "sigma(N - n!1, N - 1,
                          extend(LAMBDA (ii: below(N)):
                                   exp2(ii) *
                                    IF ii < N - n!1
                                      THEN b2n(bv!1(ii + n!1))
                                    ELSE b2n(FALSE)
                                    ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (lemma "sigma_split") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                    exp2(ii) *
                                     IF ii < N - 1 - n!1
                                       THEN b2n(bv!1(ii + n!1))
                                     ELSE b2n(FALSE)
                                     ENDIF)" "N-1" "0" "N-2-n!1") (("1" (assert) (("1" (case-replace "sigma(N - 1 - n!1, N - 1,
                              extend(LAMBDA (ii: below(N)):
                                       exp2(ii) *
                                        IF ii < N - 1 - n!1
                                          THEN b2n(bv!1(ii + n!1))
                                        ELSE b2n(FALSE)
                                        ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                       exp2(ii) *
                                        IF ii < N - n!1
                                          THEN b2n(bv!1(ii + n!1))
                                        ELSE b2n(FALSE)
                                        ENDIF)" "extend(LAMBDA (ii: below(N)):
                                        exp2(ii) *
                                         IF ii < N - 1 - n!1
                                           THEN b2n(bv!1(ii + n!1))
                                         ELSE b2n(FALSE)
                                         ENDIF)" "N-2-n!1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                                  0 *
                                   extend(LAMBDA (ii: below(N)):
                                            exp2(ii) *
                                             IF ii < N - 1 - n!1
                                               THEN b2n(bv!1(ii + n!1))
                                             ELSE b2n(FALSE)
                                             ENDIF)
                                         (n)" "extend(LAMBDA (ii: below(N)):
                                         exp2(ii) *
                                          IF ii < N - 1 - n!1
                                            THEN b2n(bv!1(ii + n!1))
                                          ELSE b2n(FALSE)
                                          ENDIF)" "N-1" "N-1-n!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                              0 *
                               extend(LAMBDA (ii: below(N)):
                                        exp2(ii) *
                                         IF ii < N - n!1
                                           THEN b2n(bv!1(ii + n!1))
                                         ELSE b2n(FALSE)
                                         ENDIF)
                                     (n)" "extend(LAMBDA (ii: below(N)):
                                     exp2(ii) *
                                      IF ii < N - n!1
                                        THEN b2n(bv!1(ii + n!1))
                                      ELSE b2n(FALSE)
                                      ENDIF)" "N-1" "N-n!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((bv2nat_as_sum formula-decl nil bv_sum nil) (sigma def-decl "nat" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nbit type-eq-decl nil bit nil) (b2n const-decl "nbit" bit nil) (extend const-decl "[nat -> nat]" bv_sum nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (sigma_mult formula-decl nil sums nil) (sigma_split formula-decl nil sums nil) (fill const-decl "bit" bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (FALSE const-decl "bool" booleans nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 39260 19090 nil nil)) (bv2nat_split_TCC1 0 (bv2nat_split_TCC1-1 nil 3249114881 3290735880 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) 3212 1510 nil nil)) (bv2nat_split 0 (bv2nat_split-1 nil 3249114881 3290735921 ("" (use "N_size") (("" (skosimp*) (("" (case-replace "m!1=0") (("1" (assert) (("1" (expand "exp2") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "m!1=N") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (assert) (("1" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                        exp2(ii) *
                                         IF ii < m!1
                                           THEN b2n(bv1!1(ii+N-m!1))
                                         ELSE b2n(FALSE)
                                         ENDIF)" "N-1" "0" "m!1-1") (("1" (assert) (("1" (case-replace "sigma(m!1, N - 1,
                                  extend(LAMBDA (ii: below(N)):
                                           exp2(ii) *
                                            IF ii < m!1
                                              THEN b2n(bv1!1(ii+N-m!1))
                                            ELSE b2n(FALSE)
                                            ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_split") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                                exp2(ii) *
                                                 IF ii < N - m!1
                                                   THEN b2n(bv2!1(ii))
                                                 ELSE b2n(FALSE)
                                                 ENDIF)" "N-1" "0" "N-m!1-1") (("1" (assert) (("1" (case-replace "sigma(N - m!1, N - 1,
                                      extend(LAMBDA (ii: below(N)):
                                               exp2(ii) *
                                                IF ii < N - m!1
                                                  THEN b2n(bv2!1(ii))
                                                ELSE b2n(FALSE)
                                                ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_mult") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                     exp2(ii) *
                                                      IF ii < N - m!1
                                                        THEN b2n(bv2!1(ii))
                                                      ELSE b2n(FALSE)
                                                      ENDIF)" "N-1-m!1" "0" "exp2(m!1)") (("1" (replace -1 * rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                 exp2(ii) *
                                                  IF ii < m!1
                                                    THEN b2n(bv1!1(ii + N - m!1))
                                                  ELSE b2n(bv2!1(ii - m!1))
                                                  ENDIF)" "N-1" "0" "m!1-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                       exp2(ii) *
                                        IF ii < m!1
                                          THEN b2n(bv1!1(ii + N - m!1))
                                        ELSE b2n(bv2!1(ii - m!1))
                                        ENDIF)" "extend(LAMBDA (ii: below(N)):
                                         exp2(ii) *
                                          IF ii < m!1
                                            THEN b2n(bv1!1(ii + N - m!1))
                                          ELSE b2n(FALSE)
                                          ENDIF)" "m!1-1" "0") (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                           exp2(ii) *
                                            IF ii < m!1
                                              THEN b2n(bv1!1(ii + N - m!1))
                                            ELSE b2n(bv2!1(ii - m!1))
                                            ENDIF)" "N-1-m!1" "0" "m!1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) (("1" (lemma "exp2_sum") (("1" (inst - "m!1-1" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat) :
                                          0 *
                                           extend(LAMBDA (ii: below(N)):
                                                    exp2(ii) *
                                                     IF ii < N - m!1
                                                       THEN b2n(bv2!1(ii))
                                                     ELSE b2n(FALSE)
                                                     ENDIF)
                                                 (n)" "extend(LAMBDA (ii: below(N)):
                                                 exp2(ii) *
                                                  IF ii < N - m!1
                                                    THEN b2n(bv2!1(ii))
                                                  ELSE b2n(FALSE)
                                                  ENDIF)" "N-1" "N-m!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                        0 *
                                         extend(LAMBDA (ii: below(N)):
                                                  exp2(ii) *
                                                   IF ii < m!1
                                                     THEN b2n(bv1!1(ii+N-m!1))
                                                   ELSE b2n(FALSE)
                                                   ENDIF)
                                               (n)" "extend(LAMBDA (ii: below(N)):
                                               exp2(ii) *
                                                IF ii < m!1
                                                  THEN b2n(bv1!1(ii+N-m!1))
                                                ELSE b2n(FALSE)
                                                ENDIF)" "N-1" "m!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((m!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma def-decl "nat" sums nil) (restrict const-decl "[nat -> nat]" sums nil) (exp2_sum formula-decl nil exp2 nil) (sigma_shift formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (sigma_split formula-decl nil sums nil) (FALSE const-decl "bool" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (fill const-decl "bit" bv nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 40364 20410 nil nil)) (bv2nat_left_false_minus_TCC1 0 (bv2nat_left_false_minus_TCC1-1 nil 3249114881 3290735922 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 1423 1380 nil nil)) (bv2nat_left_false_minus 0 (bv2nat_left_false_minus-1 nil 3249114881 3290735933 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                           exp2(ii) *
                            IF ii < N - n!1
                              THEN b2n(bv!1(ii + n!1))
                            ELSE b2n(FALSE)
                            ENDIF)" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "exp2" -1 3) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_mult") (("1" (inst?) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (expand "sigma" 1 2) (("1" (expand "extend" 1 2) (("1" (expand "b2n" 1 7) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                exp2(ii) *
                                 IF ii < N - n!1
                                   THEN b2n(bv!1(ii + n!1))
                                 ELSE b2n(FALSE)
                                 ENDIF)" "N-2" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                           extend(LAMBDA (ii: below(N)):
                                    exp2(ii) *
                                     IF ii < N - n!1
                                       THEN b2n(bv!1(ii + n!1))
                                     ELSE b2n(FALSE)
                                     ENDIF)
                                 (1 + n)" "LAMBDA (n:nat):
                            2 *
                             extend(LAMBDA (ii: below(N)):
                                      exp2(ii) *
                                       IF ii < N - 1 - n!1
                                         THEN b2n(bv!1(1 + ii + n!1))
                                       ELSE b2n(FALSE)
                                       ENDIF)
                                   (n)" "N-2" "0") (("1" (assert) (("1" (hide 2) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) proved ((sigma_split formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_shift formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (n!1 skolem-const-decl "below(N)" BitvectorOneComplementDivision nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FALSE const-decl "bool" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 10358 9720 nil nil)) (bv2nat_leftshift_exp_TCC1 0 (bv2nat_leftshift_exp_TCC1-1 nil 3249114881 3290735933 ("" (subtype-tcc) nil nil) proved nil 787 740 nil nil)) (bv2nat_leftshift_exp 0 (bv2nat_leftshift_exp-1 nil 3249114881 3290735940 ("" (use "N_size") (("" (skosimp*) (("" (rewrite "bv2nat_as_sum[N]") (("" (assert) (("" (rewrite "bv2nat_as_sum[N]") (("" (expand "sigma" 1 1) (("" (expand "extend" 1 1) (("" (lemma "sigma_split") (("" (inst - "extend(LAMBDA (ii: below(N)):
                        exp2(ii) * b2n(left_shift(1, bv!1)(ii)))" "N-1" "0" "0") (("" (assert) (("" (expand "sigma" -1 2) (("" (expand "extend" -1 2) (("" (expand "left_shift" -1 3) (("" (expand "^") (("" (expand "o ") (("" (expand "fill") (("" (expand "b2n" -1 3) (("" (replace -1) (("" (hide -1) (("" (lemma "sigma_shift") (("" (inst -1 "extend(LAMBDA (ii: below(N)):
                        exp2(ii) * b2n(left_shift(1, bv!1)(ii)))" "N-2" "0" "1") (("" (assert) (("" (replace -1) (("" (hide -1) (("" (case-replace "sigma(0, N - 2,
               LAMBDA (n:nat):
                 extend(LAMBDA (ii: below(N)):
                          exp2(ii) * b2n(left_shift(1, bv!1)(ii)))
                       (1 + n)) = 2 * sigma(0, N - 2,
              extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii))))") (("1" (rewrite "times_div1" :dir rl) nil nil) ("2" (hide 2) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n: nat):
                  extend(LAMBDA (ii: below(N)):
                           exp2(ii) * b2n(left_shift(1, bv!1)(ii)))
                        (1 + n)" "LAMBDA (n:nat):
                   2 *
                    extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(bv!1(ii)))(n)" "N-2" "0") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((sigma def-decl "nat" sums nil) (sigma_split formula-decl nil sums nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (sigma_shift formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (times_div1 formula-decl nil real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (b2n const-decl "nbit" bit nil) (nbit type-eq-decl nil bit nil) (exp2 def-decl "posnat" exp2 nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (extend const-decl "[nat -> nat]" bv_sum nil) (left_shift const-decl "bvec[N]" bv_shift nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 6691 6240 nil nil)) (divrem_mem_TCC1 0 (divrem_mem_TCC1-1 nil 3249114881 3290735941 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 1046 980 nil nil)) (divrem_mem_TCC2 0 (divrem_mem_TCC2-1 nil 3249114881 3290735942 ("" (subtype-tcc) nil nil) proved ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil)) 1060 1010 nil nil)) (divrem_mem_TCC3 0 (divrem_mem_TCC3-1 nil 3249114881 3290735944 ("" (subtype-tcc) nil nil) proved ((below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 1792 1640 nil nil)) (divrem_mem_TCC4 0 (divrem_mem_TCC4-1 nil 3249114881 3290735945 ("" (termination-tcc) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 1391 1350 nil nil)) (divrem_mem_TCC5 0 (divrem_mem_TCC5-1 nil 3249114881 3290735947 ("" (subtype-tcc) nil nil) proved ((below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 1703 1590 nil nil)) (divrem_mem_TCC6 0 (divrem_mem_TCC6-1 nil 3249114881 3290735949 ("" (termination-tcc) nil nil) proved ((left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil)) 1395 1340 nil nil)) (divrem_mem_first_second_third 0 (divrem_mem_first_second_third-2 nil 3249244443 3290737031 ("" (use "N_size") (("" (beta) (("" (induct "n") (("1" (grind) (("1" (apply-extensionality :hide? t) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (expand "divrem" +) (("2" (case-replace "(LAMBDA (i: below(N)):
                              IF i < N - jb!1
                                THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                              ELSE FALSE
                              ENDIF) = (left_shift(1,
                                       LAMBDA (i: below(N)):
                                         IF i < N - 1 - jb!1
                                           THEN rem!1(i)
                                         ELSE FALSE
                                         ENDIF)
                              WITH [(0) := quot!1(N - 1)])") (("1" (hide -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (inst - "left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]" "dvs!1" "left_shift(1, quot!1) WITH [(0) := TRUE]" "(left_shift(1,
                                                              LAMBDA (i: below(N)):
                                                                IF i < N - 1 - jb!1
                                                                  THEN rem!1(i)
                                                                ELSE FALSE
                                                                ENDIF)
                                                     WITH [(0) := quot!1(N - 1)])
                                                   - dvs!1") (("1" (assert) (("1" (flatten) (("1" (case-replace "(LAMBDA (i: below(N)):
                                                IF i < N - jb!1
                                                  THEN ((left_shift(1,
                                                                    LAMBDA
                                                                    (i: below(N)):
                                                                    IF i < N - 1 - jb!1
                                                                    THEN rem!1(i)
                                                                    ELSE FALSE
                                                                    ENDIF)
                                                           WITH [(0) := quot!1(N - 1)])
                                                         - dvs!1)
                                                           (i) ELSE FALSE
                                                ENDIF) = left_shift(1,
                                                           LAMBDA (i: below(N)):
                                                             IF i < N - 1 - jb!1
                                                               THEN rem!1(i)
                                                             ELSE FALSE
                                                             ENDIF)
                                                  WITH [(0) := quot!1(N - 1)]
                                                 - dvs!1") (("1" (assert) (("1" (replace*) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 2) (("2" (name-replace "ls" "(left_shift(1,
                                                                LAMBDA (i: below(N)):
                                                                  IF i < N - 1 - jb!1
                                                                    THEN rem!1(i)
                                                                  ELSE FALSE
                                                                  ENDIF)
                                                       WITH [(0) := quot!1(N - 1)])") (("2" (case "bv2nat[N](LAMBDA (i: below(N)):
                                                                            IF i < N - jb!1
                                                                              THEN (ls
                                                                                     - dvs!1)
                                                                                       (i) ELSE FALSE
                                                                            ENDIF) = bv2nat[N](ls
                                                                             - dvs!1)") (("1" (rewrite "bv2nat_inj[N]") nil nil) ("2" (hide 2) (("2" (rewrite "bv2nat_minus3") (("2" (case-replace "bv2nat[N](ls) = bv2nat[N-jb!1](ls^(N-jb!1-1,0))") (("1" (hide -1) (("1" (case-replace "bv2nat[N](dvs!1) = bv2nat[N-jb!1](dvs!1^(N-jb!1-1,0))") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                                                             IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF) = (fill[jb!1](FALSE) o ((ls - dvs!1) ^ (N - 1 - jb!1, 0)))") (("1" (hide -1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) (("1" (expand "-") (("1" (rewrite "bv_add_subrange") (("1" (rewrite "bv_caret_negate") (("1" (lemma "bv2nat_minus3") (("1" (expand "-") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "dvs!1 = (fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0)))") (("1" (case "bv2nat[N](dvs!1) = bv2nat[N](fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0)))") (("1" (replace -1 1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case-replace "jb!1=0") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "bv2nat_upperbound[N]") (("2" (inst - "dvs!1" "N-jb!1") (("1" (assert) (("1" (hide -2) (("1" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "bv2nat_concat") (("2" (inst - "N-jb!1" "jb!1" "fill[jb!1](FALSE)" "(ls ^ (N - jb!1 - 1, 0))") (("2" (rewrite "bv2nat_fill_F") (("2" (assert) (("2" (case "ls = (fill[jb!1](FALSE) o (ls ^ (N - 1 - jb!1, 0)))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (expand "ls") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst - "left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]" "dvs!1" "left_shift(1, quot!1)" "left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]") (("2" (flatten) (("2" (assert) (("2" (case-replace "(LAMBDA (i: below(N)):
                                               IF i < N - jb!1
                                                 THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                                               ELSE FALSE
                                               ENDIF) = left_shift(1,
                                                         LAMBDA (i: below(N)):
                                                           IF i < N - 1 - jb!1
                                                             THEN rem!1(i)
                                                           ELSE FALSE
                                                           ENDIF)
                                                WITH [(0) := quot!1(N - 1)]") (("1" (assert) (("1" (replace*) (("1" (hide-all-but 2) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) proved ((jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (bv_add_subrange formula-decl nil bv_arith_caret nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (ls skolem-const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_minus3 formula-decl nil DivisionUtil nil) (bv2nat_inj formula-decl nil bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (TRUE const-decl "bool" booleans nil) (- const-decl "bvec[N]" bv_arithmetic nil) (left_shift const-decl "bvec[N]" bv_shift nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (FALSE const-decl "bool" booleans nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 270745 55680 t nil) (divrem_mem_first_second_third-1 nil 3249114881 3249244423 ("" (use "N_size") (("" (induct "n") (("1" (grind) (("1" (apply-extensionality :hide? t) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (expand "divrem" +) (("2" (case-replace "(LAMBDA (i: below(N)):
                      IF i < N - jb!1
                        THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                      ELSE FALSE
                      ENDIF) = (left_shift(1,
                               LAMBDA (i: below(N)):
                                 IF i < N - 1 - jb!1
                                   THEN rem!1(i)
                                 ELSE FALSE
                                 ENDIF)
                      WITH [(0) := quot!1(N - 1)])") (("1" (hide -1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (inst - "left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]" "dvs!1" "left_shift(1, quot!1) WITH [(0) := TRUE]" "(left_shift(1,
                                              LAMBDA (i: below(N)):
                                                IF i < N - 1 - jb!1
                                                  THEN rem!1(i)
                                                ELSE FALSE
                                                ENDIF)
                                     WITH [(0) := quot!1(N - 1)])
                                   - dvs!1") (("1" (assert) (("1" (flatten) (("1" (case-replace "(LAMBDA (i: below(N)):
                                IF i < N - jb!1
                                  THEN ((left_shift(1,
                                                    LAMBDA
                                                    (i: below(N)):
                                                    IF i < N - 1 - jb!1
                                                    THEN rem!1(i)
                                                    ELSE FALSE
                                                    ENDIF)
                                           WITH [(0) := quot!1(N - 1)])
                                         - dvs!1)
                                           (i) ELSE FALSE
                                ENDIF) = left_shift(1,
                                           LAMBDA (i: below(N)):
                                             IF i < N - 1 - jb!1
                                               THEN rem!1(i)
                                             ELSE FALSE
                                             ENDIF)
                                  WITH [(0) := quot!1(N - 1)]
                                 - dvs!1") (("1" (assert) (("1" (replace*) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 2) (("2" (name-replace "ls" "(left_shift(1,
                                            LAMBDA (i: below(N)):
                                              IF i < N - 1 - jb!1
                                                THEN rem!1(i)
                                              ELSE FALSE
                                              ENDIF)
                                   WITH [(0) := quot!1(N - 1)])") (("2" (case "bv2nat[N](LAMBDA (i: below(N)):
                                              IF i < N - jb!1
                                                THEN (ls
                                                       - dvs!1)
                                                         (i) ELSE FALSE
                                              ENDIF) = bv2nat[N](ls
                                               - dvs!1)") (("1" (rewrite "bv2nat_inj[N]") nil nil) ("2" (hide 2) (("2" (rewrite "bv2nat_minus") (("2" (case-replace "bv2nat[N](ls) = bv2nat[N-jb!1](ls^(N-jb!1-1,0))") (("1" (hide -1) (("1" (case-replace "bv2nat[N](dvs!1) = bv2nat[N-jb!1](dvs!1^(N-jb!1-1,0))") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                             IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF) = (fill[jb!1](FALSE) o ((ls - dvs!1) ^ (N - 1 - jb!1, 0)))") (("1" (hide -1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) (("1" (expand "-") (("1" (rewrite "bv_add_subrange") (("1" (rewrite "bv_caret_negate") (("1" (lemma "DivisionUtil.bv2nat_minus") (("1" (expand "-") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "dvs!1 = (fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0)))") (("1" (case "bv2nat[N](dvs!1) = bv2nat[N](fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0)))") (("1" (replace -1 1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case-replace "jb!1=0") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "bv2nat_upperbound[N]") (("2" (inst - "dvs!1" "N-jb!1") (("1" (assert) (("1" (hide -2) (("1" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma "bv2nat_concat") (("2" (inst - "N-jb!1" "jb!1" "fill[jb!1](FALSE)" "(ls ^ (N - jb!1 - 1, 0))") (("2" (rewrite "bv2nat_fill_F") (("2" (assert) (("2" (case "ls = (fill[jb!1](FALSE) o (ls ^ (N - 1 - jb!1, 0)))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (expand "ls") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst - "left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]" "dvs!1" "left_shift(1, quot!1)" "left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]") (("2" (flatten) (("2" (assert) (("2" (case-replace "(LAMBDA (i: below(N)):
                               IF i < N - jb!1
                                 THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                               ELSE FALSE
                               ENDIF) = left_shift(1,
                                         LAMBDA (i: below(N)):
                                           IF i < N - 1 - jb!1
                                             THEN rem!1(i)
                                           ELSE FALSE
                                           ENDIF)
                                WITH [(0) := quot!1(N - 1)]") (("1" (assert) (("1" (replace*) (("1" (hide-all-but 2) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) unfinished ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (divrem def-decl "[bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (FALSE const-decl "bool" booleans nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (left_shift const-decl "bvec[N]" bv_shift nil) (- const-decl "bvec[N]" bv_arithmetic nil) (TRUE const-decl "bool" booleans nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_inj formula-decl nil bv_nat nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv_add_subrange formula-decl nil bv_arith_caret nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 265315 101570 t nil)) (divrem_mem_rem 0 (divrem_mem_rem-2 nil 3249244749 3290735981 ("" (use "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (assert) (("1" (expand "divrem_mem") (("1" (case-replace "(LAMBDA (i: below(N)): rem!1(i)) = rem!1") (("1" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (name-replace "ls" "(LAMBDA (i: below(N)):
                      IF i < N - jb!1
                        THEN left_shift(1, rem!1) WITH [(0) := dvd!1(N - 1)](i)
                      ELSE FALSE
                      ENDIF)") (("1" (expand "<") (("1" (lemma "leftshift_with") (("1" (inst - "N" "(LAMBDA (i: below(N)):
                       IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)" "dvd!1(N - 1)") (("1" (assert) (("1" (split -) (("1" (case-replace "(left_shift(1,
                                (LAMBDA (i: below(N)):
                                   IF i < N - 1 - jb!1
                                     THEN rem!1(i)
                                   ELSE FALSE
                                   ENDIF))
                       WITH [(0) := dvd!1(N - 1)]) = ls") (("1" (hide -1) (("1" (case-replace "jb!1=0") (("1" (assert) (("1" (case-replace "(LAMBDA (i: below(N)): (ls - dvs!1)(i)) = (ls - dvs!1)") (("1" (hide -1) (("1" (rewrite "bv2nat_minus3") (("1" (assert) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil) ("2" (case "bv2nat[N](ls) < exp2(N-jb!1)") (("1" (lemma "bv2nat_upperbound_caret[N]") (("1" (inst-cp - "ls" "N-jb!1") (("1" (assert) (("1" (inst-cp - "dvs!1" "N-jb!1") (("1" (assert) (("1" (inst - "(LAMBDA (i: below(N)):
                                 IF i < N - jb!1
                                   THEN (ls - dvs!1)(i)
                                 ELSE FALSE
                                 ENDIF)" "N-jb!1") (("1" (assert) (("1" (split -) (("1" (replace*) (("1" (case-replace "((LAMBDA (i: below(N)):
                                  IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF)
                                ^ (N - 1 - jb!1, 0)) = (ls - dvs!1)^ (N - 1 - jb!1, 0)") (("1" (expand "-") (("1" (rewrite "bv_add_caret") (("1" (rewrite "bv_caret_negate") (("1" (rewrite "-" :dir rl) (("1" (rewrite "bv2nat_minus3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -1 -2 -4 3) (("2" (use "bv2nat_upperbound[N]") (("1" (assert) (("1" (skosimp*) (("1" (expand "ls") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (expand "ls") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 2) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst?) (("1" (assert) (("1" (expand "<") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" bv_arith_nat nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "bvec[N]" bv_arithmetic nil) (TRUE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (fill const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (bv_add_caret formula-decl nil bv_arith_caret_rules nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (below type-eq-decl nil nat_types nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (bv2nat_upperbound_caret formula-decl nil BitvectorUtil nil) (ls skolem-const-decl "[below(N) -> bit]" BitvectorOneComplementDivision nil) (bv2nat_minus3 formula-decl nil DivisionUtil nil) (leftshift_with formula-decl nil DivisionUtil nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 29316 12040 t nil) (divrem_mem_rem-1 nil 3249114881 3249243546 ("" (use "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (assert) (("1" (expand "divrem_mem") (("1" (case-replace "(LAMBDA (i: below(N)): rem!1(i)) = rem!1") (("1" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (name-replace "ls" "(LAMBDA (i: below(N)):
              IF i < N - jb!1
                THEN left_shift(1, rem!1) WITH [(0) := dvd!1(N - 1)](i)
              ELSE FALSE
              ENDIF)") (("1" (expand "<") (("1" (lemma "leftshift_with") (("1" (inst - "N" "(LAMBDA (i: below(N)):
               IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)" "dvd!1(N - 1)") (("1" (assert) (("1" (split -) (("1" (case-replace "(left_shift(1,
                      (LAMBDA (i: below(N)):
                         IF i < N - 1 - jb!1
                           THEN rem!1(i)
                         ELSE FALSE
                         ENDIF))
             WITH [(0) := dvd!1(N - 1)]) = ls") (("1" (hide -1) (("1" (case-replace "jb!1=0") (("1" (assert) (("1" (case-replace "(LAMBDA (i: below(N)): (ls - dvs!1)(i)) = (ls - dvs!1)") (("1" (hide -1) (("1" (rewrite "bv2nat_minus") (("1" (assert) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil) ("2" (case "bv2nat[N](ls) < exp2(N-jb!1)") (("1" (lemma "bv2nat_upperbound_caret[N]") (("1" (inst-cp - "ls" "N-jb!1") (("1" (assert) (("1" (inst-cp - "dvs!1" "N-jb!1") (("1" (assert) (("1" (inst - "(LAMBDA (i: below(N)):
               IF i < N - jb!1
                 THEN (ls - dvs!1)(i)
               ELSE FALSE
               ENDIF)" "N-jb!1") (("1" (assert) (("1" (split -) (("1" (replace*) (("1" (case-replace "((LAMBDA (i: below(N)):
              IF i < N - jb!1 THEN (ls - dvs!1)(i) ELSE FALSE ENDIF)
            ^ (N - 1 - jb!1, 0)) = (ls - dvs!1)^ (N - 1 - jb!1, 0)") (("1" (expand "-") (("1" (rewrite "bv_add_caret") (("1" (rewrite "bv_caret_negate") (("1" (rewrite "-" :dir rl) (("1" (rewrite "bv2nat_minus") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide -1 -2 -4 3) (("2" (use "bv2nat_upperbound[N]") (("1" (assert) (("1" (skosimp*) (("1" (expand "ls") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (expand "ls") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 2) (("2" (use "bv2nat_upperbound[N]") (("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst?) (("1" (assert) (("1" (expand "<") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) unfinished ((nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" bv_arith_nat nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "bvec[N]" bv_arithmetic nil) (TRUE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (fill const-decl "bit" bv nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (bv_add_caret formula-decl nil bv_arith_caret_rules nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (below type-eq-decl nil nat_types nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (bv2nat_upperbound_caret formula-decl nil BitvectorUtil nil) (leftshift_with formula-decl nil DivisionUtil nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 15364 7360 nil nil)) (div_divrem_mem_TCC1 0 (div_divrem_mem_TCC1-1 nil 3249114881 3290735982 ("" (subtype-tcc) nil nil) proved nil 988 940 nil nil)) (div_divrem_mem 0 (div_divrem_mem-1 nil 3249114881 3290735983 ("" (skosimp*) (("" (expand "div") (("" (use "divrem_mem_first_second_third") (("" (assert) (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil)) 1567 1460 nil nil)) (rem_divrem_mem 0 (rem_divrem_mem-1 nil 3249114881 3290735985 ("" (skosimp*) (("" (expand "rem") (("" (use "divrem_mem_first_second_third") (("" (assert) (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil)) 1504 1400 nil nil)) (divrem_mem_invariant 0 (divrem_mem_invariant-2 nil 3249244821 3290737395 ("" (use "N_size") (("" (beta) (("" (induct "n") (("1" (skosimp*) (("1" (expand "divrem_mem") (("1" (assert) (("1" (case-replace "(LAMBDA (i: below(N)): aux!1(i)) = aux!1") (("1" (case-replace "(LAMBDA (i: below(N)): rem!1(i)) = rem!1") (("1" (case-replace "(LAMBDA (i: below(N)): quot!1(i)) = quot!1") (("1" (expand "exp2") (("1" (propax) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                     IF i < 1 + jb!1
                                       THEN quot!1(i - 1 + N - jb!1)
                                     ELSE aux!1(i - 1 - jb!1)
                                     ENDIF) = (LAMBDA (i: below(N)):
                                     IF i < jb!1
                                       THEN left_shift(1, quot!1)(i + N - jb!1)
                                     ELSE left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]
                                              (i - jb!1)
                                     ENDIF)") (("1" (hide -1) (("1" (replace -3) (("1" (hide -3) (("1" (assert) (("1" (expand "exp2" 1 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                               IF i < N - jb!1
                                                 THEN left_shift(1, quot!1) WITH [(0) := TRUE](i)
                                               ELSE FALSE
                                               ENDIF) = left_shift(1, (LAMBDA (i: below(N)):
                                              IF i < N - 1 - jb!1 THEN quot!1(i) ELSE FALSE ENDIF)) WITH [(0) := TRUE]") (("1" (hide -1) (("1" (rewrite "leftshift_with" 1) (("1" (assert) (("1" (expand "b2n") (("1" (lemma "bv2nat_split") (("1" (inst-cp - "quot!1" "rem!1" "1+jb!1") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (inst - "left_shift(1, quot!1)" "left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)] - dvs!1" "jb!1") (("1" (hide -1) (("1" (expand "exp2" 1 1) (("1" (name-replace "lsrem" "(LAMBDA (i: below(N)):
                                                              IF i < N - jb!1
                                                                THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                                                              ELSE FALSE
                                                              ENDIF)") (("1" (lemma "bv2nat_split") (("1" (inst -1 "left_shift(1, quot!1)" "lsrem - dvs!1" "jb!1") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (case-replace "bv2nat[N]
                                                             (LAMBDA (i: below(N)):
                                                                IF i < N - jb!1 THEN (lsrem - dvs!1)(i) ELSE FALSE ENDIF)
                                                    = bv2nat[N](lsrem) - bv2nat[N](dvs!1)") (("1" (hide -1 -2) (("1" (assert) (("1" (expand "lsrem") (("1" (case-replace "bv2nat[N]
                                                                    ((LAMBDA (i: below(N)):
                                                                        IF i < N - jb!1
                                                                          THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                                                                        ELSE FALSE
                                                                        ENDIF)) = 2 *
                                                                (bv2nat[N]
                                                                     (LAMBDA (i: below(N)):
                                                                        IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)) + b2n(quot!1(N - 1))") (("1" (assert) (("1" (hide -1) (("1" (case-replace "jb!1=0") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (expand "exp2") (("1" (assert) (("1" (rewrite "bv2nat_lem") (("1" (expand "^") (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                                                                              exp2(ii) *
                                                                                                               IF ii < jb!1
                                                                                                                 THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                                               ELSE b2n(FALSE)
                                                                                                               ENDIF)" "N-1" "0" "jb!1-1") (("1" (assert) (("1" (case-replace "sigma(jb!1, N - 1,
                                                                                                              extend(LAMBDA (ii: below(N)):
                                                                                                                       exp2(ii) *
                                                                                                                        IF ii < jb!1
                                                                                                                          THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                                                        ELSE b2n(FALSE)
                                                                                                                        ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (case-replace "jb!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(quot!1(ii)))" "extend(LAMBDA (ii: below(N)):
                                                                                                                                       exp2(ii) *
                                                                                                                                        IF ii < N - 1
                                                                                                                                          THEN b2n(left_shift(1, quot!1)(1 + ii))
                                                                                                                                        ELSE b2n(FALSE)
                                                                                                                                        ENDIF)" "N-2" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                                                                                                     exp2(ii) *
                                                                                                                                      IF ii < 1 + jb!1
                                                                                                                                        THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                                                                      ELSE b2n(FALSE)
                                                                                                                                      ENDIF)" "N-1" "0" "jb!1") (("1" (assert) (("1" (case-replace "sigma(1 + jb!1, N - 1,
                                                                                                                                      extend(LAMBDA (ii: below(N)):
                                                                                                                                               exp2(ii) *
                                                                                                                                                IF ii < 1 + jb!1
                                                                                                                                                  THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                                                                                ELSE b2n(FALSE)
                                                                                                                                                ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                                                                                                                                     exp2(ii) *
                                                                                                                                                      IF ii < 1 + jb!1
                                                                                                                                                        THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                                                                                      ELSE b2n(FALSE)
                                                                                                                                                      ENDIF)" "extend(LAMBDA (ii: below(N)):
                                                                                                                                                      exp2(ii) *
                                                                                                                                                       IF ii < jb!1
                                                                                                                                                         THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                                                                                       ELSE b2n(FALSE)
                                                                                                                                                       ENDIF)" "jb!1-1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                                                                                                                      0 *
                                                                                                                                                       extend(LAMBDA (ii: below(N)):
                                                                                                                                                                exp2(ii) *
                                                                                                                                                                 IF ii < 1 + jb!1
                                                                                                                                                                   THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                                                                                                 ELSE b2n(FALSE)
                                                                                                                                                                 ENDIF)
                                                                                                                                                             (n)" "extend(LAMBDA (ii: below(N)):
                                                                                                                                                             exp2(ii) *
                                                                                                                                                              IF ii < 1 + jb!1
                                                                                                                                                                THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                                                                                              ELSE b2n(FALSE)
                                                                                                                                                              ENDIF)" "N-1" "1+jb!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                                                                                                                              0 *
                                                                                                                               extend(LAMBDA (ii: below(N)):
                                                                                                                                        exp2(ii) *
                                                                                                                                         IF ii < jb!1
                                                                                                                                           THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                                                                         ELSE b2n(FALSE)
                                                                                                                                         ENDIF)
                                                                                                                                     (n)" "extend(LAMBDA (ii: below(N)):
                                                                                                                                     exp2(ii) *
                                                                                                                                      IF ii < jb!1
                                                                                                                                        THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                                                                      ELSE b2n(FALSE)
                                                                                                                                      ENDIF)" "N-1" "jb!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (case-replace "jb!1=0") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                                                             exp2(ii) *
                                                                                              b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                                                                                      (ii)))" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "exp2" -1 3) (("1" (replace -1) (("1" (hide -1) (("1" (expand "sigma" 1 2) (("1" (expand "extend" 1 2) (("1" (expand "b2n" 1 6) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                                                              exp2(ii) *
                                                                                               b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                                                                                       (ii)))" "N-2" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                                                       extend(LAMBDA (ii: below(N)):
                                                                                                exp2(ii) *
                                                                                                 b2n(left_shift(1, rem!1)
                                                                                                       WITH [(0) := quot!1(N - 1)]
                                                                                                         (ii)))
                                                                                             (1 + n)" "LAMBDA (n:nat):
                                                                                        2 *
                                                                                         extend(LAMBDA (ii: below(N)):
                                                                                                  exp2(ii) *
                                                                                                   IF ii < N - 1
                                                                                                     THEN b2n(rem!1(ii))
                                                                                                   ELSE b2n(FALSE)
                                                                                                   ENDIF)
                                                                                               (n)" "N-2" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                                                             exp2(ii) *
                                                                                              IF ii < N - jb!1
                                                                                                THEN b2n(left_shift(1, rem!1)
                                                                                                           WITH [(0) := quot!1(N - 1)]
                                                                                                             (ii))
                                                                                              ELSE b2n(FALSE)
                                                                                              ENDIF)" "N-1" "0" "N-jb!1-1") (("2" (assert) (("2" (case-replace "sigma(N - jb!1, N - 1,
                                                                                      extend(LAMBDA (ii: below(N)):
                                                                                               exp2(ii) *
                                                                                                IF ii < N - jb!1
                                                                                                  THEN b2n(left_shift(1, rem!1)
                                                                                                             WITH [(0) := quot!1(N - 1)]
                                                                                                               (ii))
                                                                                                ELSE b2n(FALSE)
                                                                                                ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (case-replace "jb!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (expand "exp2" 2 1) (("1" (assert) (("1" (lemma "sigma_mult") (("1" (inst - "LAMBDA (n:nat):
                                                                                                        2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "N-1" "0" "0") (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n: nat):
                                                                                                       0 *
                                                                                                        (2 *
                                                                                                          extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))
                                                                                                                (n))" "LAMBDA (n:nat):
                                                                                                        2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "N-1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                                                                             exp2(ii) *
                                                                                                              IF ii < N - jb!1
                                                                                                                THEN b2n(left_shift(1, rem!1)
                                                                                                                           WITH [(0) := quot!1(N - 1)]
                                                                                                                             (ii))
                                                                                                              ELSE b2n(FALSE)
                                                                                                              ENDIF)" "N-1-jb!1" "0" "0") (("2" (assert) (("2" (expand "sigma" -1 2) (("2" (expand "extend" -1 2) (("2" (replace -1) (("2" (hide -1) (("2" (expand "exp2" 3 2) (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst -1 "LAMBDA (n:nat):
                                                                                                        2 *
                                                                                                         extend(LAMBDA (ii: below(N)):
                                                                                                                  exp2(ii) *
                                                                                                                   IF ii < N - 1 - jb!1
                                                                                                                     THEN b2n(rem!1(ii))
                                                                                                                   ELSE b2n(FALSE)
                                                                                                                   ENDIF)
                                                                                                               (n)" "N-1" "0" "N-2-jb!1") (("2" (assert) (("2" (case-replace "sigma(N - 1 - jb!1, N - 1,
                                                                                                      LAMBDA (n: nat):
                                                                                                        2 *
                                                                                                         extend(LAMBDA (ii: below(N)):
                                                                                                                  exp2(ii) *
                                                                                                                   IF ii < N - 1 - jb!1
                                                                                                                     THEN b2n(rem!1(ii))
                                                                                                                   ELSE b2n(FALSE)
                                                                                                                   ENDIF)
                                                                                                               (n)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                                                                                      exp2(ii) *
                                                                                                                       IF ii < N - jb!1
                                                                                                                         THEN b2n(left_shift(1, rem!1)
                                                                                                                                    WITH [(0) := quot!1(N - 1)]
                                                                                                                                      (ii))
                                                                                                                       ELSE b2n(FALSE)
                                                                                                                       ENDIF)" "N-2-jb!1" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                                                                               extend(LAMBDA (ii: below(N)):
                                                                                                                        exp2(ii) *
                                                                                                                         IF ii < N - jb!1
                                                                                                                           THEN b2n(left_shift(1, rem!1)
                                                                                                                                    WITH [(0) := quot!1(N - 1)]
                                                                                                                                    (ii))
                                                                                                                         ELSE b2n(FALSE)
                                                                                                                         ENDIF)
                                                                                                                     (1 + n)" "LAMBDA (n: nat):
                                                                                                                2 *
                                                                                                                 extend(LAMBDA (ii: below(N)):
                                                                                                                          exp2(ii) *
                                                                                                                           IF ii < N - 1 - jb!1
                                                                                                                             THEN b2n(rem!1(ii))
                                                                                                                           ELSE b2n(FALSE)
                                                                                                                           ENDIF)
                                                                                                                       (n)" "N-2-jb!1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst - "LAMBDA (n: nat):
                                                                                                              2 *
                                                                                                               extend(LAMBDA (ii: below(N)):
                                                                                                                        exp2(ii) *
                                                                                                                         IF ii < N - 1 - jb!1
                                                                                                                           THEN b2n(rem!1(ii))
                                                                                                                         ELSE b2n(FALSE)
                                                                                                                         ENDIF)
                                                                                                                     (n)" "N-1" "N-1-jb!1" "0") (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n: nat):
                                                                                                              2 *
                                                                                                               extend(LAMBDA (ii: below(N)):
                                                                                                                        exp2(ii) *
                                                                                                                         IF ii < N - 1 - jb!1
                                                                                                                           THEN b2n(rem!1(ii))
                                                                                                                         ELSE b2n(FALSE)
                                                                                                                         ENDIF)
                                                                                                                     (n)" "LAMBDA(n:nat) : 0" "N-1" "N-1-jb!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat):
                                                                                              0 *
                                                                                               extend(LAMBDA (ii: below(N)):
                                                                                                        exp2(ii) *
                                                                                                         IF ii < N - jb!1
                                                                                                           THEN b2n(left_shift(1, rem!1)
                                                                                                                    WITH [(0) := quot!1(N - 1)]
                                                                                                                    (ii))
                                                                                                         ELSE b2n(FALSE)
                                                                                                         ENDIF)
                                                                                                     (n)" "extend(LAMBDA (ii: below(N)):
                                                                                                     exp2(ii) *
                                                                                                      IF ii < N - jb!1
                                                                                                        THEN b2n(left_shift(1, rem!1)
                                                                                                                   WITH [(0) := quot!1(N - 1)]
                                                                                                                     (ii))
                                                                                                      ELSE b2n(FALSE)
                                                                                                      ENDIF)" "N-1" "N-jb!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "bv2nat[N](lsrem) = bv2nat[N-jb!1](lsrem^(N-1-jb!1,0))") (("1" (hide -1) (("1" (case-replace "bv2nat[N](dvs!1) = bv2nat[N-jb!1](dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                                                                     IF i < N - jb!1 THEN (lsrem - dvs!1)(i) ELSE FALSE ENDIF)
                                                                                 = fill[jb!1](FALSE) o (lsrem - dvs!1) ^ (N - 1 - jb!1, 0)") (("1" (hide -1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) (("1" (expand "-") (("1" (rewrite "bv_add_subrange") (("1" (rewrite "bv_caret_negate") (("1" (lemma "bv2nat_minus3") (("1" (expand "-") (("1" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "bv2nat[N](dvs!1) = bv2nat[N](fill[jb!1](FALSE) o dvs!1^(N-1-jb!1,0))") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "dvs!1 = fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case-replace "jb!1=0") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "bv2nat_upperbound[N]") (("2" (inst - "dvs!1" "N-jb!1") (("1" (assert) (("1" (hide -2) (("1" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (case-replace "bv2nat[N](lsrem) = bv2nat[N](fill[jb!1](FALSE) o lsrem^(N-1-jb!1,0))") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "lsrem = (fill[jb!1](FALSE) o lsrem ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (expand "lsrem") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (hide 1 2) (("2" (case-replace "(LAMBDA (i: below(N)):
                                     IF i < 1 + jb!1
                                       THEN quot!1(i - 1 + N - jb!1)
                                     ELSE aux!1(i - 1 - jb!1)
                                     ENDIF) = (LAMBDA (i: below(N)):
                                     IF i < jb!1
                                       THEN left_shift(1, quot!1)(i + N - jb!1)
                                     ELSE left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]
                                              (i - jb!1)
                                     ENDIF)") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                              IF i < 1 + jb!1
                                                THEN quot!1(i - 1 + N - jb!1)
                                              ELSE rem!1(i - 1 - jb!1)
                                              ENDIF) = (LAMBDA (i: below(N)):
                                              IF i < jb!1
                                                THEN left_shift(1, quot!1)(i + N - jb!1)
                                              ELSE left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                                       (i - jb!1)
                                              ENDIF)") (("1" (hide -1) (("1" (replace -2) (("1" (hide -2) (("1" (assert) (("1" (expand "exp2" 1 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                                      IF i < N - jb!1
                                                        THEN left_shift(1, quot!1)(i)
                                                      ELSE FALSE
                                                      ENDIF) = left_shift(1, (LAMBDA (i: below(N)):
                                                       IF i < N - 1 - jb!1 THEN quot!1(i) ELSE FALSE ENDIF)) WITH [(0) := FALSE]") (("1" (rewrite "leftshift_with") (("1" (expand "b2n") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) proved ((bv2nat_rec def-decl "nat" bv_nat nil) (- const-decl "bvec[N]" bv_arithmetic nil) (TRUE const-decl "bool" booleans nil) (left_shift const-decl "bvec[N]" bv_shift nil) (bv2nat_split formula-decl nil BitvectorOneComplementDivision nil) (nbit type-eq-decl nil bit nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (sigma_split formula-decl nil sums nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (restrict const-decl "[nat -> nat]" sums nil) (sigma_restrict_eq formula-decl nil sums nil) (sigma_mult formula-decl nil sums nil) (sigma def-decl "nat" sums nil) (extend const-decl "[nat -> nat]" bv_sum nil) (jb!1 skolem-const-decl "below(1 + N)" BitvectorOneComplementDivision nil) (fill const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (^ const-decl "bit" bv nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (above nonempty-type-eq-decl nil integers nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (sigma_shift formula-decl nil sums nil) (lsrem skolem-const-decl "[below(N) -> bit]" BitvectorOneComplementDivision nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (- const-decl "[numfield -> numfield]" number_fields nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (maxint const-decl "int" bv_int nil) (minint const-decl "int" bv_int nil) (bv_add_subrange formula-decl nil bv_arith_caret nil) (bv2nat_minus3 formula-decl nil DivisionUtil nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (b2n const-decl "nbit" bit nil) (leftshift_with formula-decl nil DivisionUtil nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below_induction formula-decl nil bounded_nat_inductions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (FALSE const-decl "bool" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (= const-decl "[T, T -> boolean]" equalities nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 334729 202400 t nil) (divrem_mem_invariant-1 nil 3249114881 3249243670 ("" (use "N_size") (("" (induct "n") (("1" (skosimp*) (("1" (expand "divrem_mem") (("1" (assert) (("1" (case-replace "(LAMBDA (i: below(N)): aux!1(i)) = aux!1") (("1" (case-replace "(LAMBDA (i: below(N)): rem!1(i)) = rem!1") (("1" (case-replace "(LAMBDA (i: below(N)): quot!1(i)) = quot!1") (("1" (expand "exp2") (("1" (propax) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "divrem_mem" +) (("2" (lift-if +) (("2" (split +) (("1" (flatten) (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                         IF i < 1 + jb!1
                           THEN quot!1(i - 1 + N - jb!1)
                         ELSE aux!1(i - 1 - jb!1)
                         ENDIF) = (LAMBDA (i: below(N)):
                         IF i < jb!1
                           THEN left_shift(1, quot!1)(i + N - jb!1)
                         ELSE left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]
                                  (i - jb!1)
                         ENDIF)") (("1" (hide -1) (("1" (replace -3) (("1" (hide -3) (("1" (assert) (("1" (expand "exp2" 1 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                               IF i < N - jb!1
                                 THEN left_shift(1, quot!1) WITH [(0) := TRUE](i)
                               ELSE FALSE
                               ENDIF) = left_shift(1, (LAMBDA (i: below(N)):
                              IF i < N - 1 - jb!1 THEN quot!1(i) ELSE FALSE ENDIF)) WITH [(0) := TRUE]") (("1" (hide -1) (("1" (rewrite "leftshift_with" 1) (("1" (assert) (("1" (expand "b2n") (("1" (lemma "bv2nat_split") (("1" (inst-cp - "quot!1" "rem!1" "1+jb!1") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (inst - "left_shift(1, quot!1)" "left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)] - dvs!1" "jb!1") (("1" (hide -1) (("1" (expand "exp2" 1 1) (("1" (name-replace "lsrem" "(LAMBDA (i: below(N)):
                                      IF i < N - jb!1
                                        THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                                      ELSE FALSE
                                      ENDIF)") (("1" (lemma "bv2nat_split") (("1" (inst -1 "left_shift(1, quot!1)" "lsrem - dvs!1" "jb!1") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (case-replace "bv2nat[N]
                                     (LAMBDA (i: below(N)):
                                        IF i < N - jb!1 THEN (lsrem - dvs!1)(i) ELSE FALSE ENDIF)
                            = bv2nat[N](lsrem) - bv2nat[N](dvs!1)") (("1" (hide -1 -2) (("1" (assert) (("1" (expand "lsrem") (("1" (case-replace "bv2nat[N]
                                        ((LAMBDA (i: below(N)):
                                            IF i < N - jb!1
                                              THEN left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)](i)
                                            ELSE FALSE
                                            ENDIF)) = 2 *
                                    (bv2nat[N]
                                         (LAMBDA (i: below(N)):
                                            IF i < N - 1 - jb!1 THEN rem!1(i) ELSE FALSE ENDIF)) + b2n(quot!1(N - 1))") (("1" (assert) (("1" (hide -1) (("1" (case-replace "jb!1=0") (("1" (assert) (("1" (lemma "bv2nat_fill_F[N]") (("1" (expand "fill") (("1" (replace -1) (("1" (hide -1) (("1" (expand "exp2") (("1" (assert) (("1" (rewrite "bv2nat_lem") (("1" (expand "^") (("1" (lemma "bv2nat_fill_F[N-1]") (("1" (expand "fill") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "bv2nat_as_sum[N]") (("1" (rewrite "bv2nat_as_sum[N]") (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                                  exp2(ii) *
                                                                   IF ii < jb!1
                                                                     THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                   ELSE b2n(FALSE)
                                                                   ENDIF)" "N-1" "0" "jb!1-1") (("1" (assert) (("1" (case-replace "sigma(jb!1, N - 1,
                                                              extend(LAMBDA (ii: below(N)):
                                                                       exp2(ii) *
                                                                        IF ii < jb!1
                                                                          THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                        ELSE b2n(FALSE)
                                                                        ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (case-replace "jb!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(quot!1(ii)))" "extend(LAMBDA (ii: below(N)):
                                                                               exp2(ii) *
                                                                                IF ii < N - 1
                                                                                  THEN b2n(left_shift(1, quot!1)(1 + ii))
                                                                                ELSE b2n(FALSE)
                                                                                ENDIF)" "N-2" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                                             exp2(ii) *
                                                                              IF ii < 1 + jb!1
                                                                                THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                              ELSE b2n(FALSE)
                                                                              ENDIF)" "N-1" "0" "jb!1") (("1" (assert) (("1" (case-replace "sigma(1 + jb!1, N - 1,
                                                                          extend(LAMBDA (ii: below(N)):
                                                                                   exp2(ii) *
                                                                                    IF ii < 1 + jb!1
                                                                                      THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                    ELSE b2n(FALSE)
                                                                                    ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (expand "sigma" 3 1) (("1" (expand "extend" 3 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "extend(LAMBDA (ii: below(N)):
                                                                                     exp2(ii) *
                                                                                      IF ii < 1 + jb!1
                                                                                        THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                      ELSE b2n(FALSE)
                                                                                      ENDIF)" "extend(LAMBDA (ii: below(N)):
                                                                                      exp2(ii) *
                                                                                       IF ii < jb!1
                                                                                         THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                       ELSE b2n(FALSE)
                                                                                       ENDIF)" "jb!1-1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                                                  0 *
                                                                                   extend(LAMBDA (ii: below(N)):
                                                                                            exp2(ii) *
                                                                                             IF ii < 1 + jb!1
                                                                                               THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                             ELSE b2n(FALSE)
                                                                                             ENDIF)
                                                                                         (n)" "extend(LAMBDA (ii: below(N)):
                                                                                         exp2(ii) *
                                                                                          IF ii < 1 + jb!1
                                                                                            THEN b2n(quot!1(ii - 1 + N - jb!1))
                                                                                          ELSE b2n(FALSE)
                                                                                          ENDIF)" "N-1" "1+jb!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("1" (inst - 0) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (n:nat):
                                                                      0 *
                                                                       extend(LAMBDA (ii: below(N)):
                                                                                exp2(ii) *
                                                                                 IF ii < jb!1
                                                                                   THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                                 ELSE b2n(FALSE)
                                                                                 ENDIF)
                                                                             (n)" "extend(LAMBDA (ii: below(N)):
                                                                             exp2(ii) *
                                                                              IF ii < jb!1
                                                                                THEN b2n(left_shift(1, quot!1)(ii + N - jb!1))
                                                                              ELSE b2n(FALSE)
                                                                              ENDIF)" "N-1" "jb!1") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "bv2nat_as_sum[N]") (("2" (rewrite "bv2nat_as_sum[N]") (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (replace -1 * rl) (("2" (hide -1) (("2" (case-replace "jb!1=0") (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                         exp2(ii) *
                                                          b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                                                  (ii)))" "N-1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "extend" -1 2) (("1" (expand "exp2" -1 3) (("1" (replace -1) (("1" (hide -1) (("1" (expand "sigma" 1 2) (("1" (expand "extend" 1 2) (("1" (expand "b2n" 1 6) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                          exp2(ii) *
                                                           b2n(left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                                                   (ii)))" "N-2" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                   extend(LAMBDA (ii: below(N)):
                                                            exp2(ii) *
                                                             b2n(left_shift(1, rem!1)
                                                                   WITH [(0) := quot!1(N - 1)]
                                                                     (ii)))
                                                         (1 + n)" "LAMBDA (n:nat):
                                                    2 *
                                                     extend(LAMBDA (ii: below(N)):
                                                              exp2(ii) *
                                                               IF ii < N - 1
                                                                 THEN b2n(rem!1(ii))
                                                               ELSE b2n(FALSE)
                                                               ENDIF)
                                                           (n)" "N-2" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                         exp2(ii) *
                                                          IF ii < N - jb!1
                                                            THEN b2n(left_shift(1, rem!1)
                                                                       WITH [(0) := quot!1(N - 1)]
                                                                         (ii))
                                                          ELSE b2n(FALSE)
                                                          ENDIF)" "N-1" "0" "N-jb!1-1") (("2" (assert) (("2" (case-replace "sigma(N - jb!1, N - 1,
                                                  extend(LAMBDA (ii: below(N)):
                                                           exp2(ii) *
                                                            IF ii < N - jb!1
                                                              THEN b2n(left_shift(1, rem!1)
                                                                         WITH [(0) := quot!1(N - 1)]
                                                                           (ii))
                                                            ELSE b2n(FALSE)
                                                            ENDIF)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (case-replace "jb!1=N-1") (("1" (assert) (("1" (expand "sigma" 2 1) (("1" (expand "extend" 2 1) (("1" (expand "exp2" 2 1) (("1" (assert) (("1" (lemma "sigma_mult") (("1" (inst - "LAMBDA (n:nat):
                                                            2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "N-1" "0" "0") (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n: nat):
                                                           0 *
                                                            (2 *
                                                              extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))
                                                                    (n))" "LAMBDA (n:nat):
                                                            2 * extend(LAMBDA (ii: below(N)): exp2(ii) * b2n(FALSE))(n)" "N-1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "extend(LAMBDA (ii: below(N)):
                                                                 exp2(ii) *
                                                                  IF ii < N - jb!1
                                                                    THEN b2n(left_shift(1, rem!1)
                                                                               WITH [(0) := quot!1(N - 1)]
                                                                                 (ii))
                                                                  ELSE b2n(FALSE)
                                                                  ENDIF)" "N-1-jb!1" "0" "0") (("2" (assert) (("2" (expand "sigma" -1 2) (("2" (expand "extend" -1 2) (("2" (replace -1) (("2" (hide -1) (("2" (expand "exp2" 3 2) (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst -1 "LAMBDA (n:nat):
                                                            2 *
                                                             extend(LAMBDA (ii: below(N)):
                                                                      exp2(ii) *
                                                                       IF ii < N - 1 - jb!1
                                                                         THEN b2n(rem!1(ii))
                                                                       ELSE b2n(FALSE)
                                                                       ENDIF)
                                                                   (n)" "N-1" "0" "N-2-jb!1") (("2" (assert) (("2" (case-replace "sigma(N - 1 - jb!1, N - 1,
                                                          LAMBDA (n: nat):
                                                            2 *
                                                             extend(LAMBDA (ii: below(N)):
                                                                      exp2(ii) *
                                                                       IF ii < N - 1 - jb!1
                                                                         THEN b2n(rem!1(ii))
                                                                       ELSE b2n(FALSE)
                                                                       ENDIF)
                                                                   (n)) = 0") (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "sigma_shift") (("1" (inst - "extend(LAMBDA (ii: below(N)):
                                                                      exp2(ii) *
                                                                       IF ii < N - jb!1
                                                                         THEN b2n(left_shift(1, rem!1)
                                                                                    WITH [(0) := quot!1(N - 1)]
                                                                                      (ii))
                                                                       ELSE b2n(FALSE)
                                                                       ENDIF)" "N-2-jb!1" "0" "1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst -1 "LAMBDA (n:nat):
                                                               extend(LAMBDA (ii: below(N)):
                                                                        exp2(ii) *
                                                                         IF ii < N - jb!1
                                                                           THEN b2n(left_shift(1, rem!1)
                                                                                    WITH [(0) := quot!1(N - 1)]
                                                                                    (ii))
                                                                         ELSE b2n(FALSE)
                                                                         ENDIF)
                                                                     (1 + n)" "LAMBDA (n: nat):
                                                                2 *
                                                                 extend(LAMBDA (ii: below(N)):
                                                                          exp2(ii) *
                                                                           IF ii < N - 1 - jb!1
                                                                             THEN b2n(rem!1(ii))
                                                                           ELSE b2n(FALSE)
                                                                           ENDIF)
                                                                       (n)" "N-2-jb!1" "0") (("1" (assert) (("1" (hide-all-but 1) (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 4) (("2" (lemma "sigma_mult") (("2" (inst - "LAMBDA (n: nat):
                                                              2 *
                                                               extend(LAMBDA (ii: below(N)):
                                                                        exp2(ii) *
                                                                         IF ii < N - 1 - jb!1
                                                                           THEN b2n(rem!1(ii))
                                                                         ELSE b2n(FALSE)
                                                                         ENDIF)
                                                                     (n)" "N-1" "N-1-jb!1" "0") (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst -1 "LAMBDA (n: nat):
                                                              2 *
                                                               extend(LAMBDA (ii: below(N)):
                                                                        exp2(ii) *
                                                                         IF ii < N - 1 - jb!1
                                                                           THEN b2n(rem!1(ii))
                                                                         ELSE b2n(FALSE)
                                                                         ENDIF)
                                                                     (n)" "LAMBDA(n:nat) : 0" "N-1" "N-1-jb!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "sigma_mult") (("2" (inst?) (("2" (inst - 0) (("2" (assert) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (n:nat):
                                                      0 *
                                                       extend(LAMBDA (ii: below(N)):
                                                                exp2(ii) *
                                                                 IF ii < N - jb!1
                                                                   THEN b2n(left_shift(1, rem!1)
                                                                            WITH [(0) := quot!1(N - 1)]
                                                                            (ii))
                                                                 ELSE b2n(FALSE)
                                                                 ENDIF)
                                                             (n)" "extend(LAMBDA (ii: below(N)):
                                                             exp2(ii) *
                                                              IF ii < N - jb!1
                                                                THEN b2n(left_shift(1, rem!1)
                                                                           WITH [(0) := quot!1(N - 1)]
                                                                             (ii))
                                                              ELSE b2n(FALSE)
                                                              ENDIF)" "N-1" "N-jb!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "bv2nat[N](lsrem) = bv2nat[N-jb!1](lsrem^(N-1-jb!1,0))") (("1" (hide -1) (("1" (case-replace "bv2nat[N](dvs!1) = bv2nat[N-jb!1](dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                                 IF i < N - jb!1 THEN (lsrem - dvs!1)(i) ELSE FALSE ENDIF)
                                             = fill[jb!1](FALSE) o (lsrem - dvs!1) ^ (N - 1 - jb!1, 0)") (("1" (hide -1) (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) (("1" (expand "-") (("1" (rewrite "bv_add_subrange") (("1" (rewrite "bv_caret_negate") (("1" (lemma "DivisionUtil.bv2nat_minus") (("1" (expand "-") (("1" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "bv2nat[N](dvs!1) = bv2nat[N](fill[jb!1](FALSE) o dvs!1^(N-1-jb!1,0))") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "dvs!1 = fill[jb!1](FALSE) o (dvs!1 ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case-replace "jb!1=0") (("1" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "bv2nat_upperbound[N]") (("2" (inst - "dvs!1" "N-jb!1") (("1" (assert) (("1" (hide -2) (("1" (apply-extensionality 2 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (case-replace "bv2nat[N](lsrem) = bv2nat[N](fill[jb!1](FALSE) o lsrem^(N-1-jb!1,0))") (("1" (rewrite "bv2nat_concat") (("1" (rewrite "bv2nat_fill_F") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case "lsrem = (fill[jb!1](FALSE) o lsrem ^ (N - 1 - jb!1, 0))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("2" (expand "lsrem") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (hide 1 2) (("2" (case-replace "(LAMBDA (i: below(N)):
                         IF i < 1 + jb!1
                           THEN quot!1(i - 1 + N - jb!1)
                         ELSE aux!1(i - 1 - jb!1)
                         ENDIF) = (LAMBDA (i: below(N)):
                         IF i < jb!1
                           THEN left_shift(1, quot!1)(i + N - jb!1)
                         ELSE left_shift(1, aux!1) WITH [(0) := quot!1(N - 1)]
                                  (i - jb!1)
                         ENDIF)") (("1" (hide -1) (("1" (case-replace "(LAMBDA (i: below(N)):
                              IF i < 1 + jb!1
                                THEN quot!1(i - 1 + N - jb!1)
                              ELSE rem!1(i - 1 - jb!1)
                              ENDIF) = (LAMBDA (i: below(N)):
                              IF i < jb!1
                                THEN left_shift(1, quot!1)(i + N - jb!1)
                              ELSE left_shift(1, rem!1) WITH [(0) := quot!1(N - 1)]
                                       (i - jb!1)
                              ENDIF)") (("1" (hide -1) (("1" (replace -2) (("1" (hide -2) (("1" (assert) (("1" (expand "exp2" 1 1) (("1" (case-replace "(LAMBDA (i: below(N)):
                                  IF i < N - jb!1
                                    THEN left_shift(1, quot!1)(i)
                                  ELSE FALSE
                                  ENDIF) = left_shift(1, (LAMBDA (i: below(N)):
                                   IF i < N - 1 - jb!1 THEN quot!1(i) ELSE FALSE ENDIF)) WITH [(0) := FALSE]") (("1" (rewrite "leftshift_with") (("1" (expand "b2n") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "bv2nat_upperbound[N]") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (apply-extensionality :hide? t) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil) unfinished ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_mem def-decl "[bvec[N], bvec[N], bvec[N]]" BitvectorOneComplementDivision nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (FALSE const-decl "bool" booleans nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_induction formula-decl nil bounded_nat_inductions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (leftshift_with formula-decl nil DivisionUtil nil) (b2n const-decl "nbit" bit nil) (bv2nat_upperbound formula-decl nil BitvectorUtil nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bv2nat_fill_F formula-decl nil bv_nat_rules nil) (bv_caret_negate formula-decl nil bv_arith_int_caret nil) (bv_add_subrange formula-decl nil bv_arith_caret nil) (minint const-decl "int" bv_int nil) (maxint const-decl "int" bv_int nil) (rng_2s_comp type-eq-decl nil bv_int nil) (bv2int const-decl "rng_2s_comp" bv_int nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "{bvn: bvec[N] |
         bv2int(bvn) =
          IF bv2int(bv) = minint THEN bv2int(bv) ELSE -(bv2int(bv)) ENDIF}" bv_arithmetic nil) (bv2nat_concat formula-decl nil bv_arith_concat nil) (below type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (sigma_shift formula-decl nil sums nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (above nonempty-type-eq-decl nil integers nil) (bv2nat_lem formula-decl nil bv_arith_caret nil) (^ const-decl "bit" bv nil) (^ const-decl "bvec[PROJ_1(sp) - PROJ_2(sp) + 1]" bv_caret nil) (fill const-decl "bit" bv nil) (extend const-decl "[nat -> nat]" bv_sum nil) (sigma def-decl "nat" sums nil) (sigma_mult formula-decl nil sums nil) (sigma_restrict_eq formula-decl nil sums nil) (restrict const-decl "[nat -> nat]" sums nil) (O const-decl "bvec[n + m]" bv_concat_def nil) (sigma_split formula-decl nil sums nil) (bv2nat_as_sum formula-decl nil bv_sum nil) (nbit type-eq-decl nil bit nil) (bv2nat_split formula-decl nil BitvectorOneComplementDivision nil) (left_shift const-decl "bvec[N]" bv_shift nil) (TRUE const-decl "bool" booleans nil) (- const-decl "bvec[N]" bv_arithmetic nil) (bv2nat_rec def-decl "nat" bv_nat nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 121662 53430 t nil)) (divrem1_eq 0 (divrem1_eq-1 nil 3249114881 3290735996 ("" (skosimp*) (("" (rewrite "div_divrem_mem") (("" (rewrite "rem_divrem_mem") (("" (use "divrem_mem_invariant") (("" (beta) (("" (split -) (("1" (replace -1 * rl) (("1" (hide -1) (("1" (use "divrem_mem_first_second_third") (("1" (beta) (("1" (flatten) (("1" (assert) (("1" (replace -1) (("1" (hide -1 -2 -3) (("1" (case-replace "(LAMBDA (i: below(N)): dvd!1(i)) = dvd!1") (("1" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (lemma "bv2nat_fill_F[N]") (("2" (expand "fill") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((div_divrem_mem formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (divrem_mem_invariant formula-decl nil BitvectorOneComplementDivision nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (FALSE const-decl "bool" booleans nil) (fill const-decl "bit" bv nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (divrem_mem_first_second_third formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (rem_divrem_mem formula-decl nil BitvectorOneComplementDivision nil)) 3001 2780 t nil)) (rem1_below_dvs 0 (rem1_below_dvs-1 nil 3249114881 3290735997 ("" (skosimp*) (("" (rewrite "rem_divrem_mem") (("" (lemma "divrem_mem_rem") (("" (inst?) (("" (expand "<") (("" (assert) (("" (lemma "bv2nat_fill_F[N]") (("" (expand "fill") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((rem_divrem_mem formula-decl nil BitvectorOneComplementDivision nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bv2nat_fill_F formula-decl nil bv_nat nil) (< const-decl "bool" bv_arith_nat nil) (divrem_mem_rem formula-decl nil BitvectorOneComplementDivision nil)) 1229 1180 nil nil)) (rem1_dvs0 0 (rem1_dvs0-1 nil 3249114881 3290735999 ("" (skosimp*) (("" (expand "rem") (("" (use "divrem_dvs0") (("" (assert) (("" (replace -1) (("" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil) proved ((rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_dvs0 formula-decl nil BitvectorOneComplementDivision nil)) 1391 1320 nil nil)) (div1_dvs0 0 (div1_dvs0-1 nil 3249114881 3290736000 ("" (skosimp*) (("" (expand "div") (("" (use "divrem_dvs0") (("" (assert) (("" (replace -1) (("" (assert) (("" (apply-extensionality :hide? t) (("" (expand "fill") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (TRUE const-decl "bool" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (below type-eq-decl nil naturalnumbers nil) (bit type-eq-decl nil bit nil) (bvec type-eq-decl nil bv nil) (below type-eq-decl nil nat_types nil) (fill const-decl "bit" bv nil) (FALSE const-decl "bool" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (divrem_dvs0 formula-decl nil BitvectorOneComplementDivision nil)) 1281 1190 nil nil)) (div1_below_dvd 0 (div1_below_dvd-1 nil 3249114881 3290736002 ("" (skosimp*) (("" (use "divrem1_eq") (("" (replace -1 2 rl) (("" (hide -1) (("" (assert) (("" (lemma "le_times_le_pos") (("" (inst - "bv2nat(div(dvd!1, dvs!1))" "1" "bv2nat(dvs!1)" "bv2nat(div(dvd!1, dvs!1))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (le_times_le_pos formula-decl nil real_props nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (nonneg_real nonempty-type-eq-decl nil real_types nil)) 1702 1620 nil nil)) (divrem1_uniqueness 0 (divrem1_uniqueness-1 nil 3249114881 3290736005 ("" (skosimp*) (("" (use "divrem1_eq") (("" (use "rem1_below_dvs") (("" (assert) (("" (lemma "unique_division") (("" (inst - "bv2nat(dvs!1)" "bv2nat(div(dvd!1, dvs!1))" "q!1" "bv2nat(rem(dvd!1, dvs!1))" "r!1") (("" (reduce) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (unique_division formula-decl nil euclidean_division nil) (rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil)) 2973 2820 nil nil)) (divrem1_dvs1 0 (divrem1_dvs1-1 nil 3249114881 3290736007 ("" (skosimp*) (("" (use "rem1_below_dvs") (("" (lemma "bv2nat_one") (("" (assert) (("" (lemma "bv2nat_eq0[N]") (("" (inst?) (("" (assert) (("" (lemma "divrem1_uniqueness") (("" (inst - "dvd!1" "one" "bv2nat(dvd!1)" "bv2nat(rem(dvd!1, one))") (("" (assert) (("" (rewrite "bv2nat_one") (("" (assert) (("" (lemma "bv2nat_inj[N]") (("" (inst - "dvd!1" "div(dvd!1, one)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (one const-decl "bvec[N]" BitvectorMultiplication nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rem const-decl "bvec[N]" BitvectorOneComplementDivision nil) (divrem1_uniqueness formula-decl nil BitvectorOneComplementDivision nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (bv2nat_inj formula-decl nil bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (bv2nat_one formula-decl nil BitvectorMultiplication nil)) 1714 1620 nil nil)) (div1_eq0 0 (div1_eq0-1 nil 3249114881 3290736009 ("" (use "N_size") (("" (skosimp*) (("" (case-replace "bv2nat(dvs!1) = 0") (("1" (lemma "bv2nat_eq0[N]") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (rewrite "div1_dvs0") (("1" (rewrite "bv2nat_fill_T[N]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (iff) (("2" (use "divrem1_eq") (("2" (use "rem1_below_dvs") (("2" (assert) (("2" (split +) (("1" (reduce) nil nil) ("2" (flatten) (("2" (assert) (("2" (case "bv2nat(div(dvd!1, dvs!1)) * bv2nat(dvs!1) >= bv2nat(dvs!1)") (("1" (assert) nil nil) ("2" (hide -1 -2 -3) (("2" (lemma "ge_times_ge_pos") (("2" (inst - "bv2nat(dvs!1)" "1" "bv2nat(div(dvd!1, dvs!1))" "bv2nat(dvs!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((rem1_below_dvs formula-decl nil BitvectorOneComplementDivision nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (ge_times_ge_pos formula-decl nil real_props nil) (div const-decl "bvec[N]" BitvectorOneComplementDivision nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (divrem1_eq formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_eq0 formula-decl nil bv_nat nil) (div1_dvs0 formula-decl nil BitvectorOneComplementDivision nil) (bv2nat_fill_T formula-decl nil bv_nat nil) (bv2nat const-decl "below(exp2(N))" bv_nat nil) (exp2 def-decl "posnat" exp2 nil) (bvec type-eq-decl nil bv nil) (bit type-eq-decl nil bit nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" BitvectorOneComplementDivision nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (N_size formula-decl nil BitvectorOneComplementDivision nil)) 2448 2280 nil nil)))
