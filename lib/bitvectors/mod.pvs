mod: THEORY
%------------------------------------------------------------------------
%
%  mod function as defined in `Concrete Mathematics'
%  The Ada definition of mod is consistent with this definition
%
% Author:
%   Paul S. Miner                | email: p.s.miner@larc.nasa.gov
%   1 South Wright St. / MS 130  |   fax: (804) 864-4234
%   NASA Langley Research Center | phone: (804) 864-6201
%   Hampton, Virginia 23681      |
%------------------------------------------------------------------------

  BEGIN
 
  IMPORTING floor_div_props

  i,k,cc: VAR int
  m: VAR posnat
  n,a,b,c: VAR nat   

  j: VAR nonzero_integer

  ml3: LEMMA abs(i -  m * floor(i/m)) < m
  ml4: LEMMA abs(i +  m * floor(-i/m)) < m

  mod(i,j): {k| abs(k) < abs(j)} = i-j*floor(i/j)

  mod_pos:  LEMMA mod(i,m) >= 0 AND mod(i,m) < m

  JUDGEMENT mod(i:int, m: posnat) HAS_TYPE below(m)


  mod_even   : LEMMA integer_pred(i/j) IMPLIES mod(i,j) = 0

  mod_neg    : LEMMA mod(-i,j) = IF integer_pred(i/j) THEN 0
                                 ELSE j - mod(i,j)
                                 ENDIF

  mod_neg_d  : LEMMA mod(i,-j) = IF integer_pred(i/j) THEN 0
                                 ELSE mod(i,j) - j 
                                 ENDIF

  mod_eq_arg : LEMMA mod(j,j) = 0
  
  mod_lt     : LEMMA abs(i) < abs(j) IMPLIES mod(i,j) = 
                                  IF sgn(i) = sgn(j) OR i = 0 THEN i
                                  ELSE i + j
                                  ENDIF

  mod_lt_nat : LEMMA n < m IMPLIES mod(n,m) = n

  mod_lt_int : LEMMA -m < i AND i < m IMPLIES mod(i,m) = 
                                  IF i >= 0 THEN i ELSE i + m
                                  ENDIF


  mod_sum_pos: LEMMA mod(i+k*m,m) = mod(i,m)

  mod_gt : LEMMA m <= i AND i < 2*m IMPLIES mod(i,m) = i-m 

  mod_sum    : LEMMA mod(i+k*j,j) = mod(i,j)

  mod_sum_nat: LEMMA (FORALL (n1,n2: below(m)):
                          mod(n1+n2,m) = IF n1 + n2 < m THEN n1+n2
                                         ELSE n1 + n2 - m
                                         ENDIF)

  mod_it_is  : LEMMA a = b + m*c AND b < m IMPLIES
                        b = mod(a,m)

  mod_zero   : LEMMA mod(0,j) = 0

  mod_one    : LEMMA mod(1,j) = IF abs(j) = 1 THEN 0
                                   ELSIF j > 0 THEN 1
                                   ELSE j + 1
                                   ENDIF

  mod_of_mod     : LEMMA mod(i + mod(k,m), m) = mod(i+k, m)

  mod_of_mod_neg : LEMMA mod(i - mod(k,m), m) = mod(i-k, m)

  mod_inj_plus       : LEMMA a < m AND n < m AND c < m AND
                       mod(a + n, m) = mod(a + c, m) IMPLIES n = c

  mod_inj_minus       : LEMMA a < m AND n < m AND c < m AND
                        mod(a - n, m) = mod(a - c, m) IMPLIES n = c


  mod_wrap_around: LEMMA n < m AND (c <= m AND c >= m-n) IMPLIES
                              mod(n+c, m) = n - (m-c)

  mod_wrap_inj   : LEMMA n < m AND a < m AND b < m AND a > 0 AND
                            mod(n + a, m) = mod(n - b, m) IMPLIES a + b = m


  mj: VAR posnat
  mod_mult      : LEMMA mod(mod(i,mj*m),m) = mod(i,m)

END mod
