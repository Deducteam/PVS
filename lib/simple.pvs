simple: THEORY
BEGIN
  % Basic
  naturals: TYPE
  nat: TYPE = naturals
  zero: nat
  succ: [nat -> nat]
  plus: [nat, nat -> nat]

  subt: TYPE FROM nat

  curryfication: [nat, [nat, nat -> nat] -> nat]

  % Constant declaration
  one: nat = succ(zero)

  % Proposition
  z_not_succ: AXIOM FORALL (n: nat): succ(n) /= zero

  % Predicate sub-type
  nznat: TYPE = { n: nat | n /= zero }
  rat: TYPE
  zrat: rat
  frac: [nat, nznat -> rat]

  % Quantification
  n, m: VAR nat
  z_not_succ2: AXIOM succ(n) /= zero % In propositions
  plus2(n): nat = succ(succ(n))      % In defined values
  nat_builder(n): nat                % In undefined values

  % Logical context
  lc_impl: LEMMA n /= zero IMPLIES n /= zero
  lc_or: LEMMA n = zero OR n /= zero
  lc_if(n): rat = IF n = zero THEN zrat ELSE frac(one, n) ENDIF

  % Recursive def
  lt: [nat, nat -> bool]
  pred: [nznat -> nat]
  succ_pred: AXIOM succ(pred(n)) = n
  pred_lt: AXIOM lt(pred(n), n)
  pred_ze: AXIOM lt(zero, n)
  triangle(n: nat): RECURSIVE nat =
              IF n = zero then zero else triangle(pred(n)) endif
              measure n BY lt;

  % Judgements
  succ_nz: JUDGEMENT succ(n: nznat) HAS_TYPE nznat
END simple

prenex[d: TYPE, r: TYPE]:THEORY
BEGIN
  % Type definition using theory parameters
  funtype:TYPE = [d -> r]
  binary : TYPE = [d, d -> r]
  %% Constant declarations
  % Using theory param
  f: funtype
  g: [d, d -> r]
  pr : [d -> bool]
  subt : TYPE = {x: d | pr(x)}
  % Not using theory param
  t: TYPE
  x: t
  %% Formula declaration
  x: VAR d
  form: LEMMA pr(x) IMPLIES pr(x)
  %% Constant decl
  func(x,y:d):r = g(x,y)
END prenex

thyparams[d: TYPE, e: d]: THEORY BEGIN
  x: VAR d
  op: [d, d -> d]
  id : AXIOM op(x,e) = x
END thyparams

import: THEORY
BEGIN
  IMPORTING simple
  IMPORTING prenex

  four: simple.nat
  binnat : prenex[simple.nat, simple.nat].binary
END import
