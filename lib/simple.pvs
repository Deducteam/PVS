% Some naturals for further use
naturals: THEORY BEGIN
  nat: TYPE
  zero: nat
  succ: [nat -> nat]
  plus: [nat, nat -> nat]
END naturals

% Unit tests for translator, contains back nat to be self contained
simple: THEORY
BEGIN
  % Basic
  naturals: TYPE
  nat: TYPE = naturals
  zero: nat
  succ: [nat -> nat]
  plus: [nat, nat -> nat]

  subt: TYPE FROM nat

  curryfication: [nat, [nat, nat -> nat] -> nat]
  triple_proj(n: nat, m: nat, k: nat): nat
  proj_trip_ax : AXIOM FORALL (n: nat): triple_proj(n, n, n) = n

  % Constant declaration
  one: nat = succ(zero)
  double : [nat -> nat] = LAMBDA (n: nat): plus(n, n)

  % Proposition
  z_not_succ: AXIOM FORALL (n: nat): succ(n) /= zero

  % Predicate sub-type
  nznat: TYPE = { n: nat | n /= zero }
  rat: TYPE
  zrat: rat
  frac: [nat, nznat -> rat]

  % Quantification
  n, m: VAR nat
  z_not_succ2: AXIOM succ(n) /= zero % In propositions
  plus2(n): nat = succ(succ(n))      % In defined values
  nat_builder(n): nat                % In undefined values

  % Logical context
  lc_impl: LEMMA n /= zero IMPLIES n /= zero
  lc_or: LEMMA n = zero OR n /= zero
  lc_if(n): rat = IF n = zero THEN zrat ELSE frac(one, n) ENDIF

  % Recursive def
  lt: [nat, nat -> bool]
  pred: [nznat -> nat]
  succ_pred: AXIOM succ(pred(n)) = n
  pred_lt: AXIOM lt(pred(n), n)
  pred_ze: AXIOM lt(zero, n)
  triangle(n: nat): RECURSIVE nat =
              IF n = zero then zero else triangle(pred(n)) endif
              measure n BY lt;

  % Judgements
  succ_nz: JUDGEMENT succ(n: nznat) HAS_TYPE nznat
END simple

eqtype: THEORY
BEGIN
  % Check how the equality is typed
  iota: TYPE % a type
  p: [iota -> bool] % a predicate on this type
  subiota : TYPE = (p) % a subtype of iota
  xi, yi : iota
  xsi, ysi : subiota
  iniota : AXIOM xi = yi
  insubiota : AXIOM xsi = ysi
  mixed : AXIOM xi = ysi
  % The conclusion is that in all cases, the equality is of type
  % [iota, iota -> iota],
  % so both arguments are typed as the supertype of the two arguments. Even in
  % the case [xsi = ysi].
END eqtype

decvar: THEORY
BEGIN
  iota: TYPE
  omicron: TYPE
  x: VAR omicron
  y: omicron
  eqio : AXIOM FORALL(x: iota)(x): x = y
  % What we can see here is that the type of x in the equality is omicron,
  % and not iota, even though the previous binding defines x to be of type
  % iota. So the type of not annotated bound variables is *exclusively*
  % sought from the declared variables.
END decvar

tupfun: THEORY
BEGIN
  x, y: VAR boolean
  f(x, y): bool = NOT (x AND y)
END tupfun

%% Tests on theory formals

prenex[d: TYPE, r: TYPE]:THEORY
BEGIN
  % Type definition using theory parameters
  funtype:TYPE = [d -> r]
  binary : TYPE = [d, d -> r]
  %% Constant declarations
  % Using theory param
  f: funtype
  g: [d, d -> r]
  pr : [d -> bool]
  subt : TYPE = {x: d | pr(x)}
  % Not using theory param
  t: TYPE
  x: t
  %% Formula declaration
  x: VAR d
  form: LEMMA pr(x) IMPLIES pr(x)
  %% Constant decl
  func(x,y:d):r = g(x,y)
  %% Constant with lambda abstraction
  flam:funtype = LAMBDA(x: d): g(x,x)
END prenex

thyparams[d: TYPE, e: d]: THEORY BEGIN
  x: VAR d
  op: [d, d -> d]
  id : AXIOM op(x,e) = x

  neurtral(x): d = e
END thyparams

thyparams_tup[d: TYPE, e: [d, d]]: THEORY BEGIN
  x: VAR d
  op: [[d, d], d -> d]
  id: AXIOM op(e, x) = x
END thyparams_tup

% Mixing types and values in import. This may induce non-prenex polymorphism
% that must be made prenex.
mixedup[d: TYPE, n: d, r: TYPE]: THEORY BEGIN
  avalue: [d -> r]
END mixedup

usemixedup: THEORY BEGIN
  IMPORTING mixedup
  t: TYPE
  v: t
  theotherval: [t -> t] = mixedup[t,v,t].avalue
END usemixedup

% Formal with TYPE FROM
subtypethy[d: TYPE, sd: TYPE FROM d]: THEORY BEGIN
  sub: sd
END subtypethy

import: THEORY
BEGIN
  IMPORTING simple
  IMPORTING prenex

  four: simple.nat
  binnat : prenex[simple.nat, simple.nat].binary
END import

vector[t: TYPE, (IMPORTING naturals) n: nat]: THEORY
BEGIN
  vect: TYPE
END vector

vect_ops[t: TYPE]: THEORY
BEGIN
  IMPORTING vector
  IMPORTING naturals
  nil: vector[t, zero].vect
  cons(n: nat, e: t, v: vector[t, n].vect): vector[t, succ(n)].vect
  consc(n:nat)(e:t)(v:vector[t, n].vect): vector[t, succ(n)].vect
END vect_ops

tuples[t: TYPE]: THEORY
BEGIN
  IMPORTING naturals
  f(n: nat, g: [nat -> nat]): nat
  ffunc(n:nat)(g:[nat->nat]): nat
  ftup(ng: [nat, [nat -> nat]]): nat
  n: nat
  g: [nat -> nat]
  ng: [nat, [nat -> nat]]
  x: nat = f(ng)
  y: nat = f(n, g)
  % z: nat = f(n)(g)
  % x2: nat = ffunc(ng)
  % y2: nat = ffunc(n, g)
  z2: nat = ffunc(n)(g)
  x3: nat = ftup(ng)
  y3: nat =ftup(n, g)
  % z3: nat = ftup(n)(g)
  IMPORTING vector
  tup: TYPE = [n: nat, v: vector[t,n].vect, vv: vector[t, n].vect]
END tuples

linear_form[t: TYPE, (IMPORTING naturals) n: nat, (IMPORTING vector[t,n]) ker: vector[t,n].vect]: THEORY
BEGIN
  form: [vector[t, n].vect -> nat]
END linear_form

tfrom[t: TYPE, u: TYPE FROM t]: THEORY
BEGIN
  value: u
END tfrom

exprastype: THEORY
BEGIN
  t: TYPE
  rec?: [t -> bool]
  thevalue : (rec?)
  etaexpanded: (LAMBDA (u: t): (rec?(u)))
  func : [(rec?) -> bool]
END exprastype

depsubtype: THEORY
BEGIN
  T: TYPE
  i: VAR T
  pre: [T, T -> bool]
  subt(i) : TYPE = {s: T | pre(i, s)}
  another_pred: [T -> bool]
  ax: AXIOM FORALL(n: T)(x: subt(n)): another_pred(x)
END depsubtype

expandeddefs: THEORY
BEGIN
  iota: TYPE
  rec?: [iota -> bool]
  alpha: TYPE = {x: iota | rec?(x)}
  f: [alpha -> alpha]
END expandeddefs
