simple: THEORY
BEGIN
  % Basic
  naturals: TYPE
  nat: TYPE = naturals
  zero: nat
  succ: [nat -> nat]
  plus: [nat, nat -> nat]

  subt: TYPE FROM nat

  curryfication: [nat, [nat, nat -> nat] -> nat]

  % Constant declaration
  one: nat = succ(zero)

  % Proposition
  z_not_succ: AXIOM FORALL (n: nat): succ(n) /= zero

  % Predicate sub-type
  nznat: TYPE = { n: nat | n /= zero }
  rat: TYPE
  zrat: rat
  frac: [nat, nznat -> rat]

  % Quantification
  n, m: VAR nat
  z_not_succ2: AXIOM succ(n) /= zero % In propositions
  plus2(n): nat = succ(succ(n))      % In defined values
  nat_builder(n): nat                % In undefined values

  % Logical context
  lc_impl: LEMMA n /= zero IMPLIES n /= zero
  lc_or: LEMMA n = zero OR n /= zero
  lc_if(n): rat = IF n = zero THEN zrat ELSE frac(one, n) ENDIF

  % Recursive def
  lt: [nat, nat -> bool]
  pred: [nznat -> nat]
  succ_pred: AXIOM succ(pred(n)) = n
  pred_lt: AXIOM lt(pred(n), n)
  pred_ze: AXIOM lt(zero, n)
  triangle(n: nat): RECURSIVE nat =
              IF n = zero then zero else triangle(pred(n)) endif
              measure n BY lt;

  % Judgements
  succ_nz: JUDGEMENT succ(n: nznat) HAS_TYPE nznat
END simple
