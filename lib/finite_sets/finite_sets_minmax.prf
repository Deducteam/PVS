(finite_sets_minmax (minrec_TCC1 0 (minrec_TCC1-1 nil 3249288231 3249288798 ("" (skosimp*) (("" (rewrite "card_rest") (("" (assert) nil)))) nil) proved ((card_rest formula-decl nil finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil finite_sets_minmax nil)) 619 80 nil nil)) (lt_reflexive 0 (lt_reflexive-1 nil 3249288231 3249288798 ("" (skosimp*) (("" (typepred "finite_sets_minmax.<=") (("" (expand "total_order?") (("" (expand "partial_order?") (("" (flatten) (("" (hide -2 3) (("" (expand "preorder?") (("" (flatten) (("" (expand "reflexive?") (("" (inst?) nil)))))))))))))))))) nil) proved ((<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil finite_sets_minmax nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (partial_order? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil)) 106 40 nil nil)) (lt_transitive 0 (lt_transitive-1 nil 3249288231 3249288799 ("" (skosimp*) (("" (typepred "finite_sets_minmax.<=") (("" (expand "total_order?") (("" (expand "partial_order?") (("" (flatten) (("" (hide -2 3) (("" (expand "preorder?") (("" (flatten) (("" (hide -1 -3) (("" (expand "transitive?") (("" (inst -1 "x!1" "y!1" "z!1") (("" (assert) nil)))))))))))))))))))))) nil) proved ((<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil finite_sets_minmax nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (partial_order? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil)) 659 50 nil nil)) (lt_total 0 (lt_total-1 nil 3249288231 3249288799 ("" (skosimp*) (("" (typepred "finite_sets_minmax.<=") (("" (expand "total_order?") (("" (expand "partial_order?") (("" (flatten) (("" (hide -1 -2) (("" (expand "dichotomous?") (("" (inst?) (("" (assert) nil)))))))))))))))) nil) proved ((<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil finite_sets_minmax nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (partial_order? const-decl "bool" orders nil) (dichotomous? const-decl "bool" orders nil)) 43 40 nil nil)) (lt_antisymmetric 0 (lt_antisymmetric-1 nil 3249288231 3249288800 ("" (skosimp*) (("" (typepred "finite_sets_minmax.<=") (("" (expand "total_order?") (("" (expand "partial_order?") (("" (flatten) (("" (hide -1 -3) (("" (expand "antisymmetric?") (("" (inst?) (("" (assert) nil)))))))))))))))) nil) proved ((<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (T formal-type-decl nil finite_sets_minmax nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (partial_order? const-decl "bool" orders nil) (antisymmetric? const-decl "bool" relations nil)) 686 40 nil nil)) (min_TCC1 0 (min_TCC1-1 nil 3249288231 3249289259 ("" (inst 1 "(LAMBDA SS: minrec(SS))") (("" (induct "SS" 1 "finite_set_induction_rest") (("1" (typepred "SS!1") (("1" (propax) nil nil)) nil) ("2" (typepred "SS!1") (("2" (propax) nil nil)) nil) ("3" (assert) (("3" (auto-rewrite-theory "sets[T]") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (expand "minrec" +) (("4" (split 2) (("1" (assert) nil nil) ("2" (flatten) (("2" (auto-rewrite-theory "sets[T]") (("2" (assert) (("2" (skosimp*) (("2" (expand "min") (("2" (assert) (("2" (split) (("1" (flatten) (("1" (lemma "epsilon_ax[T]") (("1" (inst?) (("1" (assert) (("1" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lift-if) (("3" (split 1) (("1" (hide -2) (("1" (flatten) (("1" (lemma "choose_rest_or[T]") (("1" (inst?) (("1" (expand "member") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (expand "empty?") (("1" (inst?) (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (rewrite "lt_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (expand "min") (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (lemma "choose_rest_or[T]") (("1" (expand "member") (("1" (inst -1 "SS!1" "x!1") (("1" (assert) (("1" (split -1) (("1" (inst -5 "x!1") (("1" (assert) (("1" (hide -1 -3 -4 2 3) (("1" (lemma "lt_transitive") (("1" (inst -1 "choose(SS!1)" " minrec(rest(SS!1))" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (hide -1 -2 -3 -4) (("2" (rewrite "lt_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "x!1") (("2" (split -3) (("1" (propax) nil nil) ("2" (case-replace "x!1 = choose(SS!1)") (("1" (hide -1 -2 -3 1 4 5) (("1" (lemma "lt_total") (("1" (inst?) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 3 4 5 6) (("2" (lemma "choose_rest_or[T]") (("2" (inst?) (("2" (expand "member") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (lt_reflexive formula-decl nil finite_sets_minmax nil) (nonempty? const-decl "bool" sets nil) (choose_rest_or formula-decl nil sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (lt_total formula-decl nil finite_sets_minmax nil) (lt_transitive formula-decl nil finite_sets_minmax nil) (choose const-decl "(p)" sets nil) (rest const-decl "set" sets nil) (remove const-decl "set" sets nil) (min const-decl "T" finite_sets_minmax nil) (epsilon_ax formula-decl nil epsilons nil) (minrec def-decl "T" finite_sets_minmax nil) (<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_minmax nil)) 298630 10120 t nil)) (max_TCC1 0 (max_TCC1-1 nil 3249288231 3249289328 ("" (inst 1 "(LAMBDA SS: maxrec(SS))") (("" (induct "SS" 1 "finite_set_induction_rest") (("1" (typepred "SS!1") (("1" (propax) nil nil)) nil) ("2" (typepred "SS!1") (("2" (propax) nil nil)) nil) ("3" (assert) (("3" (auto-rewrite-theory "sets[T]") (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (expand "maxrec" +) (("4" (split 2) (("1" (assert) nil nil) ("2" (flatten) (("2" (auto-rewrite-theory "sets[T]") (("2" (assert) (("2" (skosimp*) (("2" (expand "max") (("2" (assert) (("2" (split 2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (lemma "epsilon_ax[T]") (("2" (inst?) (("2" (assert) (("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lift-if) (("3" (split 1) (("1" (hide -2) (("1" (flatten) (("1" (case-replace "x!1=choose(SS!1)") (("1" (rewrite "lt_reflexive") nil nil) ("2" (hide 2) (("2" (lemma "choose_rest_or[T]") (("2" (expand "member") (("2" (inst?) (("2" (assert) (("2" (expand "empty?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (expand "max") (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (hide -4) (("1" (lemma "choose_rest_or[T]") (("1" (expand "member") (("1" (inst -1 "SS!1" "x!1") (("1" (assert) (("1" (reveal -2) (("1" (inst -1 "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -3 "x!1") (("2" (split -3) (("1" (hide -2 -3 3 4) (("1" (lemma "lt_total") (("1" (inst -1 "maxrec(rest(SS!1))" "choose(SS!1) ") (("1" (prop) (("1" (lemma "lt_transitive") (("1" (inst -1 "x!1" "maxrec(rest(SS!1))" "choose(SS!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "choose_rest_or[T]") (("2" (expand "member") (("2" (inst?) (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "lt_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) proved ((finite_set_induction_rest formula-decl nil finite_sets_inductions nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (choose_rest_or formula-decl nil sets_lemmas nil) (lt_reflexive formula-decl nil finite_sets_minmax nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonempty? const-decl "bool" sets nil) (lt_total formula-decl nil finite_sets_minmax nil) (lt_transitive formula-decl nil finite_sets_minmax nil) (choose const-decl "(p)" sets nil) (rest const-decl "set" sets nil) (remove const-decl "set" sets nil) (max const-decl "T" finite_sets_minmax nil) (epsilon_ax formula-decl nil epsilons nil) (maxrec def-decl "T" finite_sets_minmax nil) (<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil finite_sets_minmax nil)) 59739 9400 t nil)) (min_lem 0 (min_lem-1 nil 3249288231 3249288806 ("" (skosimp*) (("" (typepred "min(SS!1)") (("" (prop) (("1" (assert) nil) ("2" (skosimp*) (("2" (replace -1) (("2" (hide -1) (("2" (typepred "x!1") (("2" (inst?) (("2" (assert) nil))))))))))) ("3" (inst -4 "a!1") (("3" (assert) (("3" (inst -2 "min(SS!1)") (("3" (assert) (("3" (hide -1 -3) (("3" (rewrite "lt_antisymmetric") nil)))))))))))))))) nil) proved ((min const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES a <= x)}" finite_sets_minmax nil) (<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_minmax nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (lt_antisymmetric formula-decl nil finite_sets_minmax nil)) 619 90 nil nil)) (max_lem 0 (max_lem-1 nil 3249288231 3249288806 ("" (skosimp*) (("" (typepred "max(SS!1)") (("" (prop) (("1" (assert) nil) ("2" (skosimp*) (("2" (replace -1) (("2" (hide -1) (("2" (typepred "x!1") (("2" (inst?) (("2" (assert) nil))))))))))) ("3" (inst -4 "a!1") (("3" (assert) (("3" (inst -2 "max(SS!1)") (("3" (assert) (("3" (hide -1 -3) (("3" (rewrite "lt_antisymmetric") nil)))))))))))))))) nil) proved ((max const-decl "{a: T | SS(a) AND (FORALL (x: T): SS(x) IMPLIES x <= a)}" finite_sets_minmax nil) (<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (total_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil finite_sets_minmax nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (lt_antisymmetric formula-decl nil finite_sets_minmax nil)) 74 80 nil nil)) (min_union 0 (min_union-1 nil 3249288231 3249288807 ("" (skosimp*) (("" (auto-rewrite "member" "union") (("" (lemma "min_lem") (("" (inst-cp -1 "A!1" "x!1") (("" (inst -1 "B!1" "y!1") (("" (assert) (("" (lemma "min_lem") (("" (inst -1 "union(A!1,B!1)" "min(x!1, y!1)") (("" (flatten) (("" (hide -1) (("" (assert) (("" (hide 2) (("" (split 1) (("1" (flatten) (("1" (expand "min") (("1" (case "x!1 <= y!1") (("1" (assert) nil) ("2" (assert) nil))))))) ("2" (skosimp*) (("2" (typepred "x!2") (("2" (expand "union") (("2" (expand "min") (("2" (expand "member") (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (split -2) (("1" (inst -4 "x!2") nil) ("2" (inst -3 "x!2") (("2" (hide -1 -4 -5 -6) (("2" (lemma "lt_transitive") (("2" (inst -1 "x!1" "y!1" "x!2") (("2" (assert) nil))))))))))))) ("2" (flatten) (("2" (split -1) (("1" (inst -3 "x!2") (("1" (assert) (("1" (hide -1 -2 -4 -5) (("1" (lemma "lt_transitive") (("1" (inst -1 "x!1" "x!2" "y!1") (("1" (assert) (("1" (hide -1 2) (("1" (lemma "lt_total") (("1" (inst?) (("1" (assert) nil))))))))))))))))))) ("2" (inst -2 "x!2") nil)))))))))))))))))))))))))))))))))))))))))))) nil) proved ((T formal-type-decl nil finite_sets_minmax nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (min const-decl "T" finite_sets_minmax nil) (A!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_minmax nil) (B!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_minmax nil) (x!2 skolem-const-decl "(union(A!1, B!1))" finite_sets_minmax nil) (lt_transitive formula-decl nil finite_sets_minmax nil) (lt_total formula-decl nil finite_sets_minmax nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (member const-decl "bool" sets nil) (min_lem formula-decl nil finite_sets_minmax nil)) 935 220 nil nil)) (max_union 0 (max_union-1 nil 3249288231 3249288808 ("" (skosimp*) (("" (auto-rewrite "member" "union") (("" (lemma "max_lem") (("" (inst-cp -1 "A!1" "x!1") (("" (inst -1 "B!1" "y!1") (("" (assert) (("" (lemma "max_lem") (("" (inst -1 "union(A!1,B!1)" "max(x!1, y!1)") (("" (flatten) (("" (hide -1) (("" (assert) (("" (hide 2) (("" (split 1) (("1" (flatten) (("1" (expand "max") (("1" (case "x!1 <= y!1") (("1" (assert) nil) ("2" (assert) nil))))))) ("2" (skosimp*) (("2" (typepred "x!2") (("2" (expand "union") (("2" (expand "max") (("2" (expand "member") (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (split -2) (("1" (inst -4 "x!2") (("1" (hide -1 -3 -5 -6) (("1" (lemma "lt_transitive") (("1" (inst -1 "x!2" "x!1" "y!1") (("1" (assert) nil))))))))) ("2" (inst -3 "x!2") nil))))) ("2" (flatten) (("2" (split -1) (("1" (inst -3 "x!2") nil) ("2" (inst -2 "x!2") (("2" (hide -1 -3 -4 -5) (("2" (lemma "lt_transitive") (("2" (inst -1 "x!2" "y!1" "x!1") (("2" (assert) (("2" (hide -1 3) (("2" (lemma "lt_total") (("2" (inst?) (("2" (assert) nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) nil) proved ((T formal-type-decl nil finite_sets_minmax nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (max const-decl "T" finite_sets_minmax nil) (lt_transitive formula-decl nil finite_sets_minmax nil) (A!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_minmax nil) (B!1 skolem-const-decl "non_empty_finite_set[T]" finite_sets_minmax nil) (x!2 skolem-const-decl "(union(A!1, B!1))" finite_sets_minmax nil) (lt_total formula-decl nil finite_sets_minmax nil) (pred type-eq-decl nil defined_types nil) (total_order? const-decl "bool" orders nil) (<= formal-const-decl "(total_order?[T])" finite_sets_minmax nil) (member const-decl "bool" sets nil) (max_lem formula-decl nil finite_sets_minmax nil)) 793 190 nil nil)))
