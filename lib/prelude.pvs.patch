diff --git a/lib/prelude.pvs b/lib/prelude.pvs
index 767f4804..55ccf47d 100644
--- a/lib/prelude.pvs
+++ b/lib/prelude.pvs
@@ -277,27 +277,27 @@ functions [D, R: TYPE]: THEORY
 
   graph(f)(x, y): bool = (f(x) = y)
 
-  preserves(f, Drel, Rrel): bool =
+  preserves(Drel, Rrel)(f): bool =
       FORALL x1, x2: Drel(x1, x2) IMPLIES Rrel(f(x1), f(x2))
 
   % Curried form
-  preserves(Drel, Rrel)(f): bool = preserves(f, Drel, Rrel)
+  %preserves(Drel, Rrel)(f): bool = preserves(f, Drel, Rrel)
 
-  inverts(f, Drel, Rrel): bool =
+  inverts(Drel, Rrel)(f): bool =
       FORALL x1, x2: Drel(x1, x2) IMPLIES Rrel(f(x2), f(x1))
 
   % Curried form
-  inverts(Drel, Rrel)(f): bool = inverts(f, Drel, Rrel)
+  %inverts(Drel, Rrel)(f): bool = inverts(f, Drel, Rrel)
 
  END functions
 
 
-functions_alt [D, R: TYPE, Drel: PRED[[D, D]], Rrel: PRED[[R, R]]]: THEORY
- BEGIN
-  f: VAR [D -> R]
-  preserves: [[D -> R] -> bool] = preserves(Drel, Rrel)
-  inverts: [[D -> R] -> bool] = inverts(Drel, Rrel)
- END functions_alt
+%functions_alt [D, R: TYPE, Drel: PRED[[D, D]], Rrel: PRED[[R, R]]]: THEORY
+% BEGIN
+%  f: VAR [D -> R]
+%  preserves: [[D -> R] -> bool] = preserves(Drel, Rrel)
+%  inverts: [[D -> R] -> bool] = inverts(Drel, Rrel)
+% END functions_alt
 
 
 transpose[T1, T2, T3: TYPE]: THEORY
@@ -1506,35 +1506,35 @@ function_props [T1, T2, T3: TYPE]: THEORY
     image(f2, image(f1, X)) = image(f2 o f1, X)
 
   preserves_composition: LEMMA
-    preserves(f1, R1, R2) AND preserves(f2, R2, R3)
-      IMPLIES preserves(f2 o f1, R1, R3)
+    preserves(R1, R2)(f1) AND preserves(R2, R3)(f2)
+      IMPLIES preserves(R1, R3)(f2 o f1)
 
   inverts_composition1: LEMMA
-    preserves(f1, R1, R2) AND inverts(f2, R2, R3)
-      IMPLIES inverts(f2 o f1, R1, R3)
+    preserves(R1, R2)(f1) AND inverts(R2, R3)(f2)
+      IMPLIES inverts(R1, R3)(f2 o f1)
 
   inverts_composition2: LEMMA
-    inverts(f1, R1, R2) AND preserves(f2, R2, R3)
-      IMPLIES inverts(f2 o f1, R1, R3)
+    inverts(R1, R2)(f1) AND preserves(R2, R3)(f2)
+      IMPLIES inverts(R1, R3)(f2 o f1)
       
  END function_props
 
 
-function_props_alt [T1, T2, T3: TYPE, R1: PRED[[T1, T1]],
-                    R2: PRED[[T2, T2]], R3: PRED[[T3, T3]]]: THEORY
- BEGIN 
-   composition_preserves: JUDGEMENT
-     o(f2: (preserves[T2, T3, R2, R3]), f1: (preserves[T1, T2, R1, R2]))
-       HAS_TYPE (preserves[T1, T3, R1, R3])
-
-   composition_inverts1: JUDGEMENT
-     o(f2: (preserves[T2, T3, R2, R3]), f1: (inverts[T1, T2, R1, R2]))
-       HAS_TYPE (inverts[T1, T3, R1, R3])
-
-   composition_inverts2: JUDGEMENT
-     o(f2: (inverts[T2, T3, R2, R3]), f1: (preserves[T1, T2, R1, R2]))
-       HAS_TYPE (inverts[T1, T3, R1, R3])
- END function_props_alt  
+%function_props_alt [T1, T2, T3: TYPE, R1: PRED[[T1, T1]],
+%                    R2: PRED[[T2, T2]], R3: PRED[[T3, T3]]]: THEORY
+% BEGIN 
+%   composition_preserves: JUDGEMENT
+%     o(f2: (preserves[T2, T3, R2, R3]), f1: (preserves[T1, T2, R1, R2]))
+%       HAS_TYPE (preserves[T1, T3, R1, R3])
+%
+%   composition_inverts1: JUDGEMENT
+%     o(f2: (preserves[T2, T3, R2, R3]), f1: (inverts[T1, T2, R1, R2]))
+%       HAS_TYPE (inverts[T1, T3, R1, R3])
+%
+%   composition_inverts2: JUDGEMENT
+%     o(f2: (inverts[T2, T3, R2, R3]), f1: (preserves[T1, T2, R1, R2]))
+%       HAS_TYPE (inverts[T1, T3, R1, R3])
+% END function_props_alt  
 
 
 % function_props2 defines the associativity of function composition.  It
@@ -4539,9 +4539,9 @@ sequences[T: TYPE]: THEORY
     p(nth(seq, 0)) AND (FORALL n: p(nth(seq, n)) IMPLIES p(nth(seq, n + 1)))
       IMPLIES every(p)(seq)
 
-  ascends?(seq, Trel): bool = preserves(seq, (LAMBDA i, n: i <= n), Trel)
+  ascends?(seq, Trel): bool = preserves((LAMBDA i, n: i <= n), Trel)(seq)
 
-  descends?(seq, Trel): bool = inverts(seq, (LAMBDA i, n: i <= n), Trel)
+  descends?(seq, Trel): bool = inverts((LAMBDA i, n: i <= n), Trel)(seq)
 
  END sequences
 
@@ -6414,7 +6414,7 @@ BEGIN
     PreservesEq(R) = PreservesEq(EquivClos[X1](R))
 
   PreservesEq_is_preserving: LEMMA
-    PreservesEq(R) = preserves(restrict[[X, X], [X1, X1], bool](R), =[Y])
+    PreservesEq(R) = preserves([X1, X1], bool](R), =[Y])(restrict[[X, X])
 
 END KernelDefinition
 
