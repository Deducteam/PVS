%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Tex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% pvs-gr.txt -- The PVS grammar for ERGO
%% Author          : Sam Owre
%% Created On      : Thu Dec  2 13:45:18 1993
%% Last Modified By: Sam Owre
%% Last Modified On: Wed Nov  4 16:14:48 1998
%% Update Count    : 93
%% Status          : Stable
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Copyright (c) 2002 SRI International, Menlo Park, CA 94025, USA.

Grammar PVS

Case Sensitive

Comment Character
	Newline  '%'

Operators
% Adding new operators may require modification to the following variables,
% and functions:
%  Var or Fun		File
%  ----------		----
%  *pvs-operators*	utils.lisp
%  
	'('  ')'  '-'  '+'  '*' '/' ':=' '::=' '|->'  ';'  ','  '='  '/='
	'<'  '<='  '>'  '>=' '{' '}' '[' ']' '.' '&' '<=>'
	'->' ':' '=>' '[#' '#]' '(#' '#)' '(:' ':)' '{:' ':}' '{{' '}}' '|'
        '^' '/\\' '\\/' '[]' '<>' '~' '==' '++' '**' '//' '^^'
	'<<' '>>' '::' '#' '@' '@@' '##' '[|' '|]' '(|' '|)' '{|' '|}'
        '|[' ']|' '!'
        '<<=' '>>=' '`' '\''
	'[||]' '(||)' '{||}' '||' '|-' '|=' '<|' '|>' ':->' %'<:'

Lexical Terminals
	id, number, string %, literal

Precedence Information
  type-expr  'WITH' medial left
             '[' initial
             jux medial left

  expr  'HAS_TYPE' aggregate,
	'IN' aggregate % LET
	'|' medial left
	'|-' medial right, '|=' medial right
	'IFF' medial right, '<=>' medial right
	'IMPLIES' medial right, '=>' medial right, 'WHEN' medial right
	'OR' medial right, '\\/' medial right, 'XOR' medial right,
		'ORELSE' medial right
	'AND' medial right, '&' medial right, '/\\' medial right,
		'&&' medial right, 'ANDTHEN' medial right
	'NOT' initial, '~' initial
	'=' medial left, '/='  medial left, '==' medial left
		'<' medial left, '<=' medial left,
		'>' medial left, '>=' medial left,
		'<<' medial left, '>>' medial left,
                '<<=' medial left, '>>=' medial left,
		'<|' medial left, '|>' medial left
	'WITH' medial left
	'WHERE' medial left, 'IN' medial left
	'@' medial left, '#' medial left 
	'@@' medial left, '##' medial left, 
		'||' medial left 
	'+' medial left, '-' medial left, '++' medial left, '~' medial left
	'*' medial left, '/' medial left, '**' medial left, '//' medial left
	'-' initial, '+' initial
	'O' medial left
	':' medial left, '::' medial left, 'HAS_TYPE' medial left
	'[]' initial, '<>' initial
	'^' medial left, '^^' medial left
	'`' medial left
	jux medial left  % application

adt-or-theories	::= {adt-or-theory+} <adt-or-modules(adt-or-theory+)>;

% SO - require endid so that multiple theories parse

adt-or-theory ::= {id [theory-formals] ':' {theory | datatype}}
		    <adt-or-module(id,[no-theory-formals()|theory-formals],
                                   alt)>;

theory ::= {'THEORY' [exporting]^e 'BEGIN' [assuming-part]^a
            [theory-part]^t 'END' id}
	      <module([noexp()|exporting]^e,
		      [noass()|assuming-part]^a,
                      [notheory()|theory-part]^t,id)>;

datatype ::= {{'DATATYPE'|'CODATATYPE'}^k ['WITH' 'SUBTYPES' {id^s ++ ','}]
	      'BEGIN' [{importing [';']^u}
                        <importing-elt(importing,[nosemic()|semic()]^u)>]^2
              [assuming-part]^1
	      adtcase+ 'END' id}
	        <{[datatype(opt^1,opt^2,adtcases(plus),id)
		  |datatypes(subtypes(doubleplus),opt^1,opt^2,
                             adtcases(plus),id)]
                 |[codatatype(opt^1,opt^2,adtcases(plus),id)
		  |codatatypes(subtypes(doubleplus),opt^1,opt^2,
                            adtcases(plus),id)]}^k>;

adtcase ::= {constructor ':' idop [':' id]}
              <[adtcase(constructor,idop)
               |adtcase-subtype(constructor,idop,id)]>;

constructor ::= {idop [{'(' {{{idops ':' type-expr}
				<adtdecl(idops,type-expr)>} ++ ','} ')'}
			   <adtdecls(doubleplus)>]}
			<constructor(idop,opt)>;

theory-formals	::= {'[' {theory-formal ++ ','} ']'}
			<theory-formals(theory-formal+)>;

theory-formal ::= {[{'(' [idop ':' lib-decl] importing ')'}
                     <formal-importing-elt([nolib()|lib-fdecl(idop,lib-decl)],
                                           importing)>]
                   idopappls ':' theory-formal-decl}
		     <theory-formal(opt,idopappls,theory-formal-decl)>;

%% theory-formal ::= {[{'(' importing ')'}
%%                      <formal-importing-elt(importing)>]
%%                    depidops ':' theory-formal-decl}
%% 		     <theory-formal(opt,depidops,theory-formal-decl)>;

idopappls ::= {idopappl++','} <idopappls(idopappl+)>;

idopappl ::= {idop ['(' type-expr++',' ')']}
                <[idop|idopappl(idop,deptypes(type-expr+))]>;

theory-formal-decl ::= {type-keyword [{'FROM' type-expr}|{'<' ':' type-expr}]}
		        <ftype-decl(type-keyword,[notype()|{type-expr|struct-subtype(type-expr)}])>
		     | {type-expr} <fconst-decl(type-expr)>
		     | {'THEORY' theory-decl-modname}
                           <ftheory-decl(theory-decl-modname)>
		     ;

exporting ::= {'EXPORTING' exportings [{ 'WITH' exportingmods}]}
	        <exporting(exportings,[noexportingmods()|exportingmods])>;

exportings ::= {'ALL' ['BUT' {expname ++ ','}]}
			<exporting-all([noexpbuts()|expbuts(doubleplus)])>
		 |  {expname ++ ','}
			<expnames(doubleplus)>
		 ;

expname ::= {idop [':' {type-expr <type-expr> |
			'TYPE' <exptype()> |
			'FORMULA' <expformula()>}]}
			<expname(idop,[noexpkind()|alt])>
%		 |  {'|' idop '|'} <absexpname(idop)>
		 ;

exportingmods ::= 'ALL' <expmodall()>
		|  'CLOSURE' <expmodclosure()>
		|  modnames
		;

assuming-part ::= {'ASSUMING' assumings 'ENDASSUMING'} <assumings>;

assumings ::= {assuming+} <assuming-part(plus)>;

assuming ::= {importing [';']}
               <importing-elt(importing,[nosemic()|semic()])>
           | {judgement [';']}
                 <judgement-elt(judgement,[nosemic()|semic()])>
	   | {conversion [';']}
		 <conversion-elt(conversion,[nosemic()|semic()])>
	   | {auto-rewrite [';']}
		 <auto-rewrite-elt(auto-rewrite,[nosemic()|semic()])>
	   | {idops pdformals* ':' assuming-decl [';']}
		<assuming(idops,pdf(star),assuming-decl,[nosemic()|semic()])>
	   ;

theory-part ::= {theory-elt+} <theory-part(plus)>;

theory-elt ::= {importing [';']}
                 <importing-elt(importing,[nosemic()|semic()])>
	     | {judgement [';']}
                 <judgement-elt(judgement,[nosemic()|semic()])>
	     | {conversion [';']}
		 <conversion-elt(conversion,[nosemic()|semic()])>
	     | {auto-rewrite [';']}
		 <auto-rewrite-elt(auto-rewrite,[nosemic()|semic()])>
	     | {idops [pdformals+] ':' theory-declaration [';']^s}
		 <theory(idops,[noformals()|pdf(plus)],
                         theory-declaration,[nosemic()|semic()]^s)>
	     ;

importing ::= {'IMPORTING' {importing-item++ ','}}
              <importing(importing-item+)>;

importing-item ::= {modname ['AS' id]}
                  <[modname|theory-abbreviation-decl(modname,id)]>;

judgement ::= {['RECURSIVE'] 'JUDGEMENT' {jdecl++','}
               {'HAS_TYPE'|'SUBTYPE_OF'} type-expr}
	      <{judgement(jdecls(doubleplus),
                 [{has-type()|subtype-of()}|{rec-has-type()|rec-subtype-of()}],
                 type-expr)>;

jdecl ::= type-expr-sans-name <jsubtypedecl(type-expr-sans-name)>
        | {name [pdformals+]} <[jnamedecl(name)|jappldecl(name,pdf(plus))]>
        ;

ename ::= {name [':' type-expr]} <ename(name,[notype()|type-expr])>;


conversion ::= {{'CONVERSION'|'CONVERSION+'|'CONVERSION-'} {expr++','}}
          <{conversion(expr+)|conversionplus(expr+)|conversionminus(expr+)}>;

auto-rewrite ::= {{'AUTO_REWRITE'|'AUTO_REWRITE+'|'AUTO_REWRITE-'}
                  {rewrite-name++','}}
	         <{auto-rewrite(rewrite-name+)
                  |auto-rewriteplus(rewrite-name+)
                  |auto-rewriteminus(rewrite-name+)}> ;

rewrite-name-or-fnum ::= {'-' number ['!' ['!']^m]^e}
                         <rewrite-fnum(fnum(number,`-()),
                                       [lazy()|[eager()|macro()]^m]^e)>
                       | rewrite-name
                       ;

% fnum ::= {['-'] number} <fnum(number,[`+()|`-()])> ;

rewrite-name ::= {name ['!' ['!']^m]^e [':' {type-expr|formula-name}]}
                 <{rewrite-name(name,
                                [lazy()|[eager()|macro()]^m]^e,
                                [noqual()|
                                 {type(type-expr)|formula(formula-name)}])}> ;

% called 'Bindings' in language doc.
pdformals ::= {'(' adformals ')'} <adformals>;

adformals ::= {adformal++','} <adformals(adformal+)>;

adformal ::= typed-id
	   | {'(' typed-ids ')'} <typed-ids>
	   ;

assuming-decl ::= theory-declaration | assumption;

theory-declaration ::= lib-decl | theory-decl | type-decl | var-decl
              | const-decl | macro-decl | def-decl | ind-decl | corec-decl
              | coind-decl | formula-decl | datatype | judgement;

lib-decl ::= {'LIBRARY' ['='] string} <lib-decl([noeq()|eq()],string)>;

theory-decl ::= {'THEORY' '=' theory-decl-modname}
                   <theory-decl(theory-decl-modname)>;

type-decl ::= {type-keyword [type-def ['CONTAINING' expr]^c]}
                <[uninterp-type-decl(type-keyword)
                 |type-decl(type-keyword,type-def,
                            [nocontains()|expr]^c)]>;

type-keyword ::= 'TYPE' <type()>
               | 'NONEMPTY_TYPE' <nonempty-type()>
               | 'TYPE+' <typeplus()>
               ;

% '=' must appear in name type-def, to avoid overlap with '=' as an opsym.
type-def ::= {{'=' <equal()> | 'FROM' <from()> | {'<' ':'} <`\<\:()>}
              type-expr}
		<type-def(alt,type-expr)>;

var-decl ::= {'VAR' type-expr} <var-decl(type-expr)>;

const-decl ::= {type-expr [const-value]}
		<[uninterp-const-decl(type-expr)
		 |const-decl(type-expr,const-value)]>;

const-value ::= {'=' expr} <expr>;

def-decl ::= {'RECURSIVE' type-expr '=' expr 'MEASURE' expr^b ['BY' expr^r]}
		<def-decl(type-expr,expr,expr^b, [noexpr()| expr^r])>;

macro-decl ::= {'MACRO' type-expr '=' expr} <macro-decl(type-expr,expr)>;

ind-decl ::= {'INDUCTIVE' type-expr '=' expr} <ind-decl(type-expr,expr)>;

corec-decl ::= {'CORECURSIVE' type-expr '=' expr}
                  <corec-decl(type-expr,expr)>;

coind-decl ::= {'COINDUCTIVE' type-expr '=' expr} <coind-decl(type-expr,expr)>;
		
assumption ::= {'ASSUMPTION' expr} <assumption(expr)>;

formula-decl ::= {formula-name expr} <formula-decl(formula-name,expr)>;

type-expr ::= {name [arguments] ['WITH' type-extension]^e}
                <[[type-name(name)|type-appl(name,arguments)]
                 |[extended-type-name(name,type-extension)
                  |extended-type-appl(name,arguments,type-extension)]]^e>
	    | {type-expr-sans-name ['WITH' type-extension]}
                <[type-expr-sans-name
                 |extended-type(type-expr-sans-name,type-extension)]>
	    ;

type-expr-sans-name ::= { '(' expr ')'} <expr-as-type(expr)>
		      | {'{' set-formals ['|' expr] '}'}
			<[enumtype(set-formals) | subtype(set-formals,expr)]>
		      | comp-type-expr
                      | {{'FORALL' | 'EXISTS'} lambda-formals ':' type-expr}
                        <quant-type({forall()|exists()},lambda-formals,
                                    type-expr)>
		      ;

% Broken out so that type expressions could appear in actual parameters;
% names cause conflicts.

comp-type-expr	::= recordtype
		 |  {[fun-array]^f '[' [dep-type-exprs]^d
		     	[{'->' type-expr} <type-expr>]^r ']'}
		     <funtype(opt^f,[emptytuple()|dep-type-exprs]^d,opt^r)>
		 ;

recordtype ::= {'[#' [field-decls [{',' field-decls++','}|{'+' field-decls++'+'}]]^r '#]'}
                <[recordtype(fields(list()))|[recordtype(fields(list(field-decls)))
                 |{recordtype(fields(cons(field-decls,field-decls+)))
                  |varianttype(fields(cons(field-decls,field-decls+)))}]]^r>;

field-decls ::= {ids ':' type-expr} <field-decls(ids,type-expr)>;

fun-array ::= 'FUNCTION' <function()> | 'ARRAY' <array()>;

dep-type-exprs ::= {dep-type-expr
                    [{',' dep-type-expr++','}|{'+' dep-type-expr++'+'}]}
                   <[dom(list(dep-type-expr))
                    |{dom(cons(dep-type-expr,dep-type-expr+))
                     |cotupletype(cons(dep-type-expr,dep-type-expr+))}]>;

dep-type-expr ::= type-expr
	       |  {idop ':' type-expr} <dep-binding(idop,type-expr)>
	       ;

type-extension ::= {'[#' field-decls [{',' field-decls++','}|{'+' field-decls++'+'}] '#]'}
                <[record-extension(fields(list(field-decls)))
                 |{record-extension(fields(cons(field-decls,field-decls+)))
                  |variant-extension(fields(cons(field-decls,field-decls+)))}]>
	| {'[' dep-type-exprs ']'}
		<tuple-extension(dep-type-exprs)>;


%% Expressions

expr ::= string <string-expr(string)>
       | name <name-expr(name)>
       | {'(:' {expr ** ','} ':)'} <list-expr(expr*)>
       | {'[|' {expr ** ','} '|]'} <brack-expr(expr*)>
       | {'(|' {expr ** ','} '|)'} <paren-vbar-expr(expr*)>
       | {'{|' {expr ** ','} '|}'} <brace-vbar-expr(expr*)>
       | {'(#' {assignment ++ ','} '#)'} <rec-expr(assignments(assignment+))>
       | {'(' {expr ** ','} ')'} <tuple-expr(expr*)>
       | {'`' {id | number} [actuals]} <{fieldex(id,[noactuals()|actuals])
                                        |projex(number,[noactuals()|actuals])}>
       | {expr '`' {id | number}} <{fieldappl(expr,id)|projappl(expr,number)}>
       | {expr jux fun-arguments} <application(expr,fun-arguments)>
       | {expr 'O' expr^1} <term-expr(o(),expr-args(list(expr,expr^1)))>
       | {expr 'IFF' expr^1} <term-expr(iff(),expr-args(list(expr,expr^1)))>
       | {expr '<=>' expr^1} <term-expr(`\<=\>(),expr-args(list(expr,expr^1)))>
       | {expr 'IMPLIES' expr^1}
                    <term-expr(implies(),expr-args(list(expr,expr^1)))>
       | {expr '=>' expr^1} <term-expr(`=\>(),expr-args(list(expr,expr^1)))>
       | {expr 'WHEN' expr^1} <term-expr(when(),expr-args(list(expr,expr^1)))>
       | {expr 'OR' expr^1} <term-expr(or(),expr-args(list(expr,expr^1)))>
       | {expr '\\/' expr^1} <term-expr(`\\\/(),expr-args(list(expr,expr^1)))>
       | {expr 'AND' expr^1} <term-expr(and(),expr-args(list(expr,expr^1)))>
       | {expr '/\\' expr^1} <term-expr(`\/\\(),expr-args(list(expr,expr^1)))>
       | {expr '&' expr^1} <term-expr(`&(),expr-args(list(expr,expr^1)))>
       | {expr 'XOR' expr^1} <term-expr(xor(),expr-args(list(expr,expr^1)))>
       | {expr 'ANDTHEN' expr^1}
                    <term-expr(andthen(),expr-args(list(expr,expr^1)))>
       | {expr 'ORELSE' expr^1}
                    <term-expr(orelse(),expr-args(list(expr,expr^1)))>
       | {expr '^' expr^1} <term-expr(`^(),expr-args(list(expr,expr^1)))>
       | {expr '+' expr^1} <term-expr(`+(),expr-args(list(expr,expr^1)))>
       | {expr '-' expr^1} <term-expr(`-(),expr-args(list(expr,expr^1)))>
       | {expr '*' expr^1} <term-expr(`*(),expr-args(list(expr,expr^1)))>
       | {expr '/' expr^1} <term-expr(`\/(),expr-args(list(expr,expr^1)))>
       | {expr '++' expr^1} <term-expr(`++(),expr-args(list(expr,expr^1)))>
       | {expr '~' expr^1} <term-expr(`~(),expr-args(list(expr,expr^1)))>
       | {expr '**' expr^1} <term-expr(`**(),expr-args(list(expr,expr^1)))>
       | {expr '//' expr^1} <term-expr(`\/\/(),expr-args(list(expr,expr^1)))>
       | {expr '^^' expr^1} <term-expr(`\^\^(),expr-args(list(expr,expr^1)))>
       | {expr '|-' expr^1} <term-expr(`\|-(),expr-args(list(expr,expr^1)))>
       | {expr '|=' expr^1} <term-expr(`\|=(),expr-args(list(expr,expr^1)))>
       | {expr '<|' expr^1} <term-expr(`\<\|(),expr-args(list(expr,expr^1)))>
       | {expr '|>' expr^1} <term-expr(`\|\>(),expr-args(list(expr,expr^1)))>
       | {expr '=' expr^1} <term-expr(`=(),expr-args(list(expr,expr^1)))>
       | {expr '/=' expr^1} <term-expr(`\/=(),expr-args(list(expr,expr^1)))>
       | {expr '==' expr^1} <term-expr(`==(),expr-args(list(expr,expr^1)))>
       | {expr '<' expr^1} <term-expr(`\<(),expr-args(list(expr,expr^1)))>
       | {expr '<=' expr^1} <term-expr(`\<=(),expr-args(list(expr,expr^1)))>
       | {expr '>' expr^1} <term-expr(`\>(),expr-args(list(expr,expr^1)))>
       | {expr '>=' expr^1} <term-expr(`\>=(),expr-args(list(expr,expr^1)))>
       | {expr '<<' expr^1} <term-expr(`\<\<(),expr-args(list(expr,expr^1)))>
       | {expr '>>' expr^1} <term-expr(`\>\>(),expr-args(list(expr,expr^1)))>
       | {expr '<<=' expr^1} <term-expr(`\<\<=(),expr-args(list(expr,expr^1)))>
       | {expr '>>=' expr^1} <term-expr(`\>\>=(),expr-args(list(expr,expr^1)))>
       | {expr '#' expr^1} <term-expr(`#(),expr-args(list(expr,expr^1)))>
       | {expr '@@' expr^1} <term-expr(`\@\@(),expr-args(list(expr,expr^1)))>
       | {expr '##' expr^1} <term-expr(`\#\#(),expr-args(list(expr,expr^1)))>
       | {'NOT' expr} <unary-term-expr(not(),expr)>
       | {'~' expr} <unary-term-expr(`~(),expr)>
       | {'[]' expr} <unary-term-expr(`\[\](),expr)>
       | {'<>' expr} <unary-term-expr(`\<\>(),expr)>
       | {'+' expr} <unary-term-expr(`+(),expr)>
       | {'-' expr} <unary-term-expr(`-(),expr)>
       | {expr '::' type-expr} <coercion(expr,type-coercion(type-expr))>
       | {'IF' expr^c 'THEN' expr^t
          {{'ELSIF' expr^ic 'THEN' expr^it} <elsif(expr^ic,expr^it)>}*
          'ELSE' expr^e 'ENDIF'}
          <if-expr(expr^c,expr^t,elsifs(star),expr^e)>
       | {{'LAMBDA' <lambda-expr()> | 'FORALL' <forall-expr()>
                                     | 'EXISTS' <exists-expr()>}
		     lambda-body}
	  <bind-expr(alt,lambda-body)>
       | {id '!' {number | lambda-body}^1}
	  <{skovar(id,number)| name-bind-expr(id,lambda-body)}^1>
       | set-expr
       | {'LET' {bind++','} 'IN' expr}
           <let-expr(let-bindings(doubleplus),expr)>
       | {expr 'WHERE' {bind++','}}
	  <where-expr(let-bindings(doubleplus),expr)>
       | {expr 'WITH' '[' {assignment ++ ','} ']'}
	  <update-expr(expr,assignments(assignment+))>
       | {'CASES' expr 'OF' {selection ++ ','}
		[{'ELSE' expr^e} <expr^e>] 'ENDCASES'}
	  <cases-expr(expr,args(selection+),opt)>
       | {'COND' {cond-case ++ ','}
		[{',' 'ELSE' '->' expr^e}] 'ENDCOND'}
	  <cond-expr(args(cond-case+),[noelse()|expr^e])>
       | table-expr
       ;

set-expr ::= {'{' set-formals '|' expr '}'} <set-expr(set-formals,expr)>
           | {'{:' expr**',' ':}'} <set-list-expr(expr*)>;

cond-case ::= {expr^l '->' expr^r} <cond-case(expr^l,expr^r)>;

lambda-body ::= {lambda-formals ':' expr}
		   <lambda-body(lambda-formals,expr)>;

% What we would really like to say here is
%   lambda-formals ::= adformal++',' | pdformals+
% but this leads to problems: first, the adformals have optional ':'s,
% that can lead to ambiguities, second, the optional parens around the
% adformals clash with those around the pdformals.  Thus we make our own
% formals below.  Note that lambda-formals may be separated by a comma or
% not; an extra check is needed in parse.lisp to ensure it is being used
% correctly.

lambda-formals ::= {lambda-formal [[',']^c lambda-formals]}
			<[lambda-formal|
			  lambda-formals(lambda-formal,
					 [nocomma()|comma()]^c,
					 lambda-formals)]>;

lambda-formal ::= idop-not-number | pdformals ;

set-formals ::= {set-formal [[',']^c set-formals]}
		<[set-formal|
		  set-formals(set-formal,[nocomma()|comma()]^c,set-formals)]>;

%set-formals ::= {set-formal [set-formals-rest]}
%		<set-formals([no-set-formals()|set-formals-rest])>;
%
%set-formals-rest ::= {',' set-formal++','}
%			<set-formals-rest-commas(doubleplus)>
%		 |   {set-formal+}
%			<set-formals-rest(plus)>
%		 ;

set-formal ::= {{idop [':' type-expr]} | pdformals}
	       <{set-id(idop,[notype()|type-expr])|pdformals}>;

selection ::= {idop [{'(' idops ')'} <idops>] ':' expr}
	      <selection(idop,opt,expr)>;

% assignment	::= {expr {':='|'|->'} !+ @> expr^1 @^ !- }
%			<assignment(expr,expr^1,{ceq()|arr()})>;

assignment ::= {assign-arg+ {':='|'|->'} expr}
			<assignment(args(plus),expr,{ceq()|arr()})>;

assign-arg ::= {'(' expr++',' ')'} <assign-tuple(expr+)>
             | {'`' {id | number}} <{id-assign(id)|proj-assign(number)}>
	     | {id ['!' number]} <[assign-id(id)|assign-skoname(id,number)]>
             | number <assign-num(number)>
	     ;

table-expr ::= {'TABLE' [expr^1]^r [',' expr^2]^c [col-heading]^h
                 table-entries 'ENDTABLE'}
			<table-expr([norowvar()|expr^1]^r,
                                    [nocolvar()|expr^2]^c,
				    [nocolheading()|col-heading]^h,
				    table-entries)>;

col-heading ::= {'|[' expr^1 {'|' {expr | 'ELSE'}}+ ']|'}
		<col-heading(expr^1,colrest({expr|else()}+))>;

table-entries ::= {table-entry+} <table-entries(table-entry+)>;

table-entry ::= {{'|' [{expr | 'ELSE'}]}+ '||'}
			<table-entry([notableentry()|{expr|else()}]+)>;

bind ::= {{simplebind | {'(' simplebind++',' ')'}} '=' expr}
	 <bind({simplebind|binds(doubleplus)},expr)>;

simplebind ::= {idop pdformals* [':' type-expr]}
	       <simplebind(idop,pdf(star),[notype()|type-expr])>;

modnames ::= {modname ++ ','} <modnames(modname+)>;

modname ::= {[{id^1 '@'}]^p id [actuals] [mappings]^m [':->' modname]^t}
	    <modname(id,[nolib()|id^1]^p,[noactuals()|actuals],
                        [nomap()|mappings]^m, [notgt()|modname]^t)>;

theory-decl-modname ::= {[{id^1 '@'}]^p id [actuals]
	    [theory-decl-mappings]^m [':->' theory-decl-modname]^t}
	    <modname(id,[nolib()|id^1]^p,[noactuals()|actuals],
                        [nomap()|theory-decl-mappings]^m,
                        [notgt()|theory-decl-modname]^t)>;

names ::= {name ++ ','}	<names(name+)>;

fun-arguments ::= {'(' {expr ** ','} ')'} <fun-arguments(expr*)>;

arguments ::= {'(' {expr ++ ','} ')'} <arguments(expr+)>;

idops ::= {idop ++ ','} <idops(idop+)>;

idop ::=  id  <idop(id)> | opsym <idop(opsym)> | number <idop(number)> ;

idop-not-number ::= id  <idop(id)> | opsym <idop(opsym)> ;

ids ::= {id ++ ','} <ids(id+)>;

typed-id ::= {idop [':' type-expr]^t ['|' expr]^e} 
	     <typed-id(idop,[no-type-expr()|type-expr]^t,[no-pred()|expr]^e)>;

typed-ids ::= {idops [':' type-expr]^t ['|' expr]^e}
	      <{typed-ids(idops,[no-type-expr()|type-expr]^t,
				[no-pred()|expr]^e)>;

name ::= {[{id '@'}]^L idop [actuals] [mappings]^m [':->' modname]^t [{'.' idop^1}]^1}
	 <name(idop,[nolib()|id]^L,[noacts()|actuals],[nomod()|idop^1]^1,
	       [nomap()|mappings]^m, [notgt()|modname]^t)>;

unique-name ::= {name [':' {'TYPE'|type-expr|formula-name}]}
		<unique-name
                  (name,[noqual()|{type()|typed(type-expr)|formula(formula-name)}])>;

bname ::= {name ['!' number]} <[name|bname(name,number)]>;

opsym ::= '+' <`+()> | '-' <`-()> | '*' <`*()> | '/' <`\/()>
	| '=' <`=()> | '/=' <`\/=()> | '==' <`==()> | '<' <`\<()>
	| '<=' <`\<=()> | '>' <`\>()> | '>=' <`\>=()>
	| 'IFF' <iff()> | 'IMPLIES' <implies()> | 'WHEN' <when()>
	| 'OR' <or()> | 'AND' <and()> | 'NOT' <not()> | '&' <`&()>
	| '/\\' <`\/\\()> | '\\/' <`\\\/()> | '^' <`^()>
	| '[]' <`\[\]()> | '<>' <`\<\>()> | '~' <`~()>
	| '=>' <`=\>()> | '<=>' <`\<=\>()> | 'IF' <if()>
	| 'TRUE' <true()> | 'FALSE' <false()> | 'O' <o()>
	| 'XOR' <xor()> | 'ORELSE' <orelse()> | 'ANDTHEN' <andthen()>
	| '++' <`++()> | '**' <`**()> | '//' <`\/\/()>
	| '^^' <`\^\^()> | '<<' <`\<\<()> | '>>' <`\>\>()>
        | '<<=' <`\<\<=()> | '>>=' <`\>\>=()>
	| '#' <`#()> 
	| '@@' <`\@\@()> | '##' <`\#\#()> 
	| '|-' <`\|-()> | '|=' <`\|=()> | '<|' <`\<\|()>
	| '|>' <`\|\>()> | '[||]' <`\[\|\|\]()> | '(||)' <`\(\|\|\)()>
        | '{||}' <`\{\|\|\}()>
	;

actuals ::= {'[' {actual ++ ','} ']'} <actuals(actual+)>;

actual ::= expr | comp-type-expr;

mappings ::= {'{{' mapping++ ',' '}}'} <mappings(mapping+)>;

mapping ::= {mapping-lhs ':=' mapping-rhs}
              <{mapping-subst(mapping-lhs,mapping-rhs)}>;

theory-decl-mappings ::= {'{{' theory-decl-mapping++ ',' '}}'}
                           <mappings(theory-decl-mapping+)>;

theory-decl-mapping ::= {mapping-lhs {'='|':='|'::='} mapping-rhs}
              <{mapping-def(mapping-lhs,mapping-rhs)
               |mapping-subst(mapping-lhs,mapping-rhs)
               |mapping-rename(mapping-lhs,mapping-rhs)}>;

mapping-lhs ::= {idop [pdformals+]^a [':' {'TYPE'|'THEORY'|type-expr}]^q}
                  <mapping-lhs(idop,
                               [noformals()|pdf(plus)]^a,
                               [noqual()|{type()|theory()|typed(type-expr)}]^q)>;

mapping-rhs ::= expr | comp-type-expr;

formula-name	::= 'AXIOM' <`AXIOM()> | 'CHALLENGE' <`CHALLENGE()>
		|   'CLAIM' <`CLAIM()> | 'CONJECTURE' <`CONJECTURE()>
		|   'COROLLARY' <`COROLLARY()> | 'FACT' <`FACT()>
		|   'FORMULA' <`FORMULA()> | 'LAW' <`LAW()>
                |   'LEMMA' <`LEMMA()> | 'OBLIGATION' <`OBLIGATION()>
		|   'POSTULATE' <`POSTULATE()>
		|   'PROPOSITION' <`PROPOSITION()> | 'SUBLEMMA' <`SUBLEMMA()>
		|   'THEOREM' <`THEOREM()>
		;
