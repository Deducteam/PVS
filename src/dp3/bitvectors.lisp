(in-package dp3)

(defun bv-p (trm)
  #+dbg(assert (node-p trm))
  (or (and (leaf-p trm)
	   (eq (node-initial-type trm) 'bv))
      (and (application-p trm)
	   (eq (node-initial-type (funsym trm)) 'bv-op))))

(defun bv-index-p (i)
  (or (integerp size)
      (integer-p size)))

(defun index-value (i)
  (if (integerp i) i (constant-id i)))

(defun index= (i j)
  (= (index-value i) (index-value j)))

(defun index+ (i j)
  (+ (index-value i) (index-value j)))

(defdpfield bv-length)

(defun bv-size (bv)
  #+dbg(assert (node-p bv))
  (or (node-bv-length bv)
      (let ((n (bv-size* bv)))
	(setf (node-bv-length bv) n)
	n)))

(defun bv-size* (bv)
  (cond ((bv-const-p bv)
	 (arg 2 bv))
	((bv-zero bv)
	 (arg 1 bv))
	((bv-epsilon bv)
	 *zero*)
	((bv-one bv)
	 (arg 1 bv))
	((bv-concat-p bv)
	 (apply #'+ (map-funargs #'bv-size bv)))
	((bv-extract-p bv)
	 (multiple-value-bind (bv1 low high)
	     (destructure-bv-extract bv)
	   (num- (bv-size bv1)
		    (num1+ (num- high low)))))
	((bv-bitwise-p bv)
	 (bv-size (lhs bv)))
	(t (break))))
	    
;; Canonizer

(defun sig-bv (bv cs)
  "Canonizer for bitvectors"
  (declare (type node bv)
           (ignore cs))
  (let ((n (bv-size bv)))
     (sig-bv-extract bv *zero* (num1- n))))

(defun sig-bv-extract (bv i j)
  (declare (type node bv)
	   (type constant i)
	   (type constant j))
  (cond ((bv-zero-p bv)
	 (mk-bv-zero (num1+ (num- j i))))
	((bv-one-p bv)
	 (mk-bv-one (num1+ (num- j i))))
	((bv-const-p bv)
	 (sig-bv-extract-const bv i j))
	((bv-concat-p bv)
	 (sig-bv-extract-concat bv i j))
	((bv-extract-p bv)
	 (multiple-value-bind (bv1 k l)
	     (destructure-bv-extract bv)
	   (sig-bv-extract bv1 (num+ k i) (num+ k j))))
	((bv-bitwise bv)
	 (sig-bv-extract-bitwise bv i j))
	(t bv)))

(defun sig-bv-extract-const (bv i j)
  (multiple-value-bind (x m)
      (destructure-bv-const bv)
    (cond ((num< *zero* i)
	   (multiple-value-bind (x1 x2)
	       (cut-constant x i)
	     (declare (ignore x1))
	     (sig-bv-extract x2 *zero* (num- j i))))
	  ((num< j (num1- m))
	   (assert (num= i *zero*))
	   (multiple-value-bind (x1 x2)
	       (cut-constant x (num1+ j))
	     (declare (ignore x2))
	     x1))
	  (t x))))
	   

(defun sig-bv-extract-concat (bv i j)
  (multiple-value-bind (bv1 bv2)
      (destructure-concat)
    (cond ((bv-epsilon-p bv1)
	   (sig-bv-extract bv2 i j))
	  ((bv-epsilon-p bv2)
	   (sig-bv-extract bv1 i j))
	  (t (let ((n (bv-size bv1))
		   (m (bv-size bv2)))
	       (cond ((num<= n i)
		      (sig-bv-extract bv2 (num- i n) (num- j n)))
		     ((num< j n)
		      (sig-bv-extract bv1 i j))
		     ((and (num< i n) (num<= n j))
		      (simplified-bv-concat (sig-bv-extract bv1 i (num1- n))
					    (sig-bv-extract bv2 *zero* (num- j n))))
		     (t (mk-bv-extract bv i j))))))))
	     
  
(defun simplified-bv-concat (bv1 bv2)
  (cond ((bv-epsilon-p bv1) bv2)
	((bv-epsilon-p bv2) bv1)
	(t (mk-bv-concat bv1 bv2))))


(defun sig-bv-extract-bitwise (bv i j)
  (let ((op (funsym bv)))
    (sig-bv-bitwise* op (lhs bv) (rhs bv))))

(defun sig-bv-bitwise* (op bv1 bv2)
  (if (and (bv-epsilon-p bv1)
	   (bv-epsilon-p bv2))
      *bv-epsilon*
      (multiple-value-bind (s1 s2)
	  (destructure-bv-concat bv1)
	(multiple-value-bind (t1 t2)
	    (destructure-bv-concat bv1)
	  (let ((n (bv-size s1))
		(m (bv-size s2)))
	    (cond ((num= n m)
		   (simplified-bv-concat
		    (sig-bv-apply op s1 t1)
		    (sig-bv-bitwise* op s2 t2)))
		  ((num> m n)
		   (multiple-value-bind (g1 g2)
		       (cut t1 n)
		     (simplified-bv-concat
		      (sig-bv-apply op s1 g1)
		      (sig-bv-bitwise* op s2 (simplified-bv-concat g2 t2)))))
		  ((num< m n)
		   (multiple-value-bind (f1 f2)
		       (cut s1 m)
		     (simplified-bv-concat
		      (sig-bv-apply op f1 t1)
		      (sig-bv-bitwise* op (simplified-bv-concat f2 s2) t2))))
		  (t (sig-bv-apply op bv1 bv2))))))))
	
(defun sig-bv-apply (op bv1 bv2)
  (let* ((n (bv-size bv)))
     (with-bdd-environment ((mk-bv-zero n) (mk-bv-one n) 'bv-op)
	(case op
	  (*bv-and* (bdd-and (lhs bv) (rhs bv)))
	  (*bv-or*  (bdd-or (lhs bv) (rhs bv)))
	  (*bv-xor*  (bdd-or (lhs bv) (rhs bv)))
	  (t bv)))))

(defun cut (bv m)
  (declare (type node bv)
	   (type constant m))
  #+dbg(assert (num< m (bv-size bv)))
  (cond ((bv-zero-p bv)
	 (let ((l (bv-size bv)))
	    (values (mk-bv-zero m) (mk-bv-zero (num- l m)))))
	((bv-one-p bv)
	 (let ((l (bv-size bv)))
	   (values (mk-bv-one m) (mk-bv-one (num- l m)))))
	((bv-const-p bv)
	 (cut-const bv m))
	((bv-bitwise bv)
	 (cut-bitwise bv m))
	((bv-extract-p bv)
	 (cut-extract bv m))
	(t (break))))

(defun cut-const (bv m)
  (multiple-value-bind (x j)
      (values (sig-bv-extract x *zero* (num1- m))
	      (sig-bv-extract x m j))))

(defun cut-bitwise (bv m)
   (multiple-value-bind (s1 s2)
       (cut (lhs bv) m)
     (multiple-value-bind (t1 t2)
	 (cut (rhs bv) m)
       (let ((op (funsym bv)))
	 (values (mk-term (list op s1 t1))
		 (mk-term (list op s2 t2)))))))

(defun cut-extract (bv m)
  (multiple-value-bind (x i j)
      (destructure-bv-extract bv)
    (let ((x1 (sig-bv-extract x i (num1- (num+ i m))))
	  (x2 (sig-bv-extract x (num+ i m) j)))
      (values x1 x2))))
      	 

;; Solver

(defun bv-solve (eqn cs)
  (declare (ignore cs))
  #+dbg(assert (equality-p eqn))
  (list eqn))
  
(defun bv-solve-neq (trm cs)
  (declare (ignore cs))
  #+dbg(assert (disequality-p trm))
  (list trm))

;(defun bv-solve* (eqns rho)
;  (if (null eqns) (list *true*)
;      (let* ((eqn (car eqns))
;	     (lhs (lhs eqn))
;	     (rhs (rhs eqn)))
;	(cond ((eq lhs rhs)
;	       (bv-solve* (cdr eqns) rho))
;	      (break))
;	      (t (multiple-value-bind (s1 u)
;		     (destructure-bv-concat lhs)
;		   (multiple-value-bind (t1 v)
;		       (destructure-bv-concat rhs)
;		     (cond ((and (bv-epsilon-p u) (bv-epsilon-p v))
;			    (break))
;			   ((
;	


