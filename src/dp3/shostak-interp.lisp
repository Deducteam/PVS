;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; -*- Mode: Lisp -*- ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; shostak-interp.lisp -- 
;; Author          : David Cyrluk
;; Created On      : 1998/06/12 22:56:41
;;
;; HISTORY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(in-package dp3)

(defun dp-theory (term)
  "As you add new theories add them to this function.
   Used by solve to determine which solver to call."
  (cond ((equality-p term)
	 (or (dp-theory (lhs term))
	     (dp-theory (rhs term))))
	((arith-p term) 'arith)
	((record-p term) 'record)
	((tuple-p term) 'tuple)
	((update-p term) 'array)
	((adt-p term) 'adt)
	((bv-p term) 'bv)
	((set-p term) 'set)
	(t nil)))

(defun sigma (term cs &optional (after-solve nil))
  "Main interface to interpreted canonizers.
   Add new theory canonizers here.
   Assumes immediate args are already in sigma-normal form."
  (cond ((number-type-p term) (sigtype term cs))
	((arith-p term) (sigarith term cs))
	((update-p term) (sigupdate term cs))
	((applyupdate-p term) (sigapplyupdate term cs))
	((project-p term) (sigproject term cs))
	((constructor-p term) (sig-constructor term cs))
	((accessor-p term) (sig-accessor term cs))
	((equality-p term) (sig-equal term cs after-solve))
	((ineq-p term) (sig-ineq term cs))
	((set-p term) (sig-set term cs))
	((bool-p term) (sig-bool term cs after-solve))
	((bv-p term) (sig-bv term cs))
	((if-p term) (sig-if term cs))
	(t term)))

(defun sig-if (term cs)
  (let ((cond (arg 1 term))
	(then (arg 2 term))
	(else (arg 3 term)))
    (cond ((true-p cond) then)
	  ((false-p cond) else)
	  ((eq then else) then)
	  (t term))))

(defun recursive-sigma (term cs)
  (declare (type node term)
	   (type cong-state cs))
  (if (and (application-p term)
	   (interp? term))
      (let ((new-args (mapcar #'(lambda (arg)
				  (recursive-sigma arg cs))
			(funargs term))))
	(sigma (mk-term (cons (funsym term) new-args)) cs))
      term))
	
(defun sigtype (term cs)
  (case (node-initial-type (funsym term))
    (integer-pred
     (if (dp-integer-atom-p (arg 1 term) cs) *true* term))
    (rational-pred
     (if (dp-rational-atom-p (arg 1 term) cs) *true* term))
    (real-pred
     (if (dp-real-atom-p (arg 1 term)) *true* term))))

(defun solve-type (term cs)
  (case (node-initial-type (funsym term))
    (integer-pred
     (setf (dp-type (arg 1 term) cs) *integer*)))
  (list (mk-equality term *true*)))

(defun sig-equal (term cs &optional (after-solve nil))
  (declare (type node term)
	   (type cong-state cs))
  #+dbg(assert (equality-p term))
  (let ((lhs (lhs term))
	(rhs (rhs term)))
    (cond ((eq lhs rhs)
	   *true*)
	  ((and (constant-p lhs)
		(constant-p rhs)
		(not (eq lhs rhs)))
	   *false*)
	  ((set-p lhs)
	   (sig-set-eq term cs))
	  ((bool-p lhs)
	   (sig-bool term cs after-solve))
	  (t (let ((interp (dp-theory term)))
	       (cond ((eq interp 'arith)
		      (normineq term cs))
		     ((eq interp 'adt)
		      (sig-adt term cs))
		     ((and (node-constructor? lhs)
			   (node-constructor? rhs))
		      *false*)
		     (after-solve term)
		     ((monom-< lhs rhs) term)
		     (t (mk-equality rhs lhs))))))))

(defun sig-ineq (term cs)
  (declare (type node term)
	   (type cong-state cs))
  (normineq term cs))

(defun add-interp-use-of-term (term cs)
  "Some theories are such that there are interpreted uses of
   terms in addition to the simple syntactic uses.
   This function should be modified as those theories are added."
  (let ((theory (dp-theory term)))
    (if (eq theory 'array)
	(add-use-of-update term cs))))

(defun solve (eqn cs)
  "Main interface for the solvers.
   Eqn is assumed to be canonical, but not
   necessarily in the cong-state use universe.
   Solve first calls the individual solvers and then
   adds those results to the use universe."
  (let ((solved (solve* eqn cs)))
    (loop for seqn in solved
	  collect (sigma-after-solve seqn cs))))

(defun sigma-after-solve (seqn cs)
  "Called on solved equations. This function respects the orientation
   that the solvers return and adds the terms generated by the solvers
   to the use universe."
  (let ((sigma-eqn (after-solve-sigma seqn cs)))
    (adduse-of-term sigma-eqn cs)
    sigma-eqn))

(defun after-solve-sigma (seqn cs)
  "Like sigma, but won't reorient equations."
  (cond ((and (equality-p seqn)
	      (not (equality-p (lhs seqn)))
	      (not (negation-p (lhs seqn)))
	      (true-p (rhs seqn)))
	 seqn)
	((equality-p seqn)
	 (let ((new-lhs (dp-find (lhs seqn) cs))
	       (new-rhs (dp-find (rhs seqn) cs)))	
	   (sigma (mk-equality new-lhs new-rhs) cs t)))
	(t (sigma seqn cs t))))

(defun solve* (trm cs)
  "This calls the individual theory solvers.
   This looks at the top level predicate to decide
   which theory to call. All equalities are passed to solve-equality.
   Modify this function as new theories are added."
  (declare (type node trm)
	   (type cong-state cs))
  #+dbg(assert (bool-p trm))
  (cond ((equality-p trm)
	 (solve-equality trm cs))
	((ineq-p trm)
	 (arith-solve trm cs))
	((negation-p trm)
	 (solve-neq (mk-equality (arg 1 trm) *false*) cs))
	((bool-p trm)
	 (solve-bool trm cs))
	((subset-p trm)
	 (solve-subset trm cs))
	(t (list trm))))

(defun solve-neq (neq cs)
  "Solver for disequalities. If a new theory has a disequality
   solver, add it here."
  (declare (type node neq)
	   (type cong-state cs))
  #+dbg(assert (disequality-p neq))
  (unless (member neq (nequals cs))
    (case (theory (dp-theory (arg 1 neq)))
      (arith (arith-solve-neq neq cs))
      (array (array-solve-neq neq cs))
      (bv (bv-solve-neq neq cs))
      (set (set-solve-neq neq cs))
      (t (multiple-value-bind (lhs rhs)
	     (destructure-disequality neq)
	   (let ((subst (E-unify lhs rhs cs)))
	     (if (fail? subst)
		 (list neq)
		 (list *false*))))))))

(defun solve-equality (eqn cs)
   "This function is the main work-horse for solving equalities.
   It looks at the theories of the lhs or rhs of the equality to
   decide which theory solver to call. Modify this function as you
   add new theories."
   (declare (type node eqn)
	    (type cong-state cs))
   (cond ((true-p eqn) ())
	 ((false-p eqn) *false-list*)
	 (t #+dbg(assert (equality-p eqn))
	    (case (dp-theory eqn)
	      (arith  (arith-solve eqn cs))
	      (record (record-solve eqn cs))
	      (tuple  (tuple-solve eqn cs))
	      (array  (array-solve eqn cs))
	      (adt    (adt-solve eqn cs))
	      (bv     (bv-solve eqn cs))
	      (set    (set-solve eqn cs))
	      (t (list eqn))))))

(defun add-neq (neq cs)
  (declare (type node neq)
	   (type cong-state cs)
           (special *dp-changed*))
  #+dbg(assert (disequality-p neq))
  (let ((nequals (nequals cs)))
    (unless (member neq nequals)
      (setq *dp-changed* t)
      (setf (nequals cs)
	    (cons neq (nequals cs)))
      (when (equality-p neq)
	(process-neq-users neq cs)))))

(defun process-neq-users (neq cs)
  (declare (type node neq)
	   (type cong-state cs)
	   (special *contradiction*))
  #+dbg(assert (disequality-p neq))
  (multiple-value-bind (t1 t2)
      (destructure-disequality neq)
    (when (and (number-theory-p t1 cs)
	       (number-theory-p t2 cs))
      (let ((t1-gt-t2 (simplify-ineq-constraint
		       (mk-greatereq t1 t2) cs))
	    (t1-lt-t2 (simplify-ineq-constraint
		       (mk-lesseq t1 t2) cs)))
	(cond ((and (true-p t1-gt-t2)
		    (true-p t1-lt-t2))
	       (setq *contradiction* t)
	       *false*)
	      ((true-p t1-gt-t2)
	       (process* (sigma (mk-greater t1 t2) cs) cs))
	      ((true-p t1-lt-t2)
	       (process* (sigma (mk-less t1 t2) cs) cs)))))))








