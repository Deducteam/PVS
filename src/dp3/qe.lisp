(in-package :dp3)

;; Miscellaneous

(defun mk-integer-constraint (tr)
  (if (integer-p trm) *true*
      (canon (mk-equality trm (mk-floor trm)) *dummy* 'no-mod)))

(defun in-scope-of-p (x trm op &optional in-scope)
  (declare (type dp-variable x)
	   (type node trm)
	   (type constant op))
  (cond ((leaf-p trm)
	 (and in-scope (eq x trm)))
	((application-p trm)
         (let ((new-in-scope (or (eq (funsym trm) op) in-scope)))
	   (some #'(lambda (arg)
		     (in-scope-of-p x arg op new-in-scope))
		 (funargs trm))))))

(defun in-scope-of-floor-p (x trm)
  (declare (type dp-variable x)
	   (type node trm))
  (or (in-scope-of-p x trm *floor*)
      (in-scope-of-p x trm *integer-pred*)))

(defun occurs-in-bdd-p (x bdd)
  (declare (type dp-variable x)
	   (type node bdd))
  (bdd-some #'(lambda (arg) (occurs-p x arg)) bdd))

;; Top-level

(defun qe-trm (trm)
  (declare (type node trm))
  (with-bdd-environment (*false* *true* 'predicate)
     (let ((bdd (catch 'unable (qe* trm))))
       (if (null bdd) fml
	   (bdd-to-bool bdd)))))

(defun qe* (trm)
  (declare (type node trm))
  #+dbg(assert (bool-p trm))
  (cond ((constant-p trm)
	 trm)
	((exists-p trm)
	 (multiple-value-bind (vars body)
	     (destructure-bndng trm)
	   (qe-exists* vars (qe* body))))
	((forall-p trm)
	 (multiple-value-bind (vars body)
	     (destructure-bndng trm)
	   (bdd-not (qe-exists* vars (qe* (simplified-negation body))))))
	((negation-p trm)
	 (bdd-not (qe* (arg 1 trm))))
	((conjunction-p trm)
	 (bdd-and (qe* (lhs trm)) (qe* (rhs trm))))
	((disjunction-p trm)
	 (bdd-or (qe* (lhs trm)) (qe* (rhs trm))))
	((implication-p trm)
	 (bdd-implies (qe* (lhs trm)) (qe* (rhs trm))))
	((ite-p trm)
	 (multiple-value-bind (cond then else)
	     (destructure-ite trm)
	   (bdd-ite (qe* cond) (qe* then) (qe* else))))
	((and (disequality-p trm)
	      (bool-p (lhs trm))
	      (bool-p (rhs trm)))
	 (multiple-value-bind (lhs rhs)
	     (destructure-disequality trm)
	   (bdd-xor (qe* (lhs trm)) (qe* (rhs trm)))))
	((and (equality-p trm)
	      (bool-p (lhs trm))
	      (bool-p (rhs trm)))
	 (bdd-iff (qe* (lhs trm)) (qe* (rhs trm))))
	(t trm)))

(defun qe-exists* (xs bdd)
  (declare (type list xs)
	   (type node bdd))
  #+dbg(assert (every #'dp-variable-p xs))
  #+dbg(assert (bdd-p bdd))
  (if (null xs) bdd
      (qe-exists* (cdr xs)
		  (qe-exists1 (car xs) bdd))))

(defun qe-exists1 (x bdd)
  "Tries to eliminate x in trm. Returns
   a BDD if successful; otherwise :unable"
  (declare (type dp-variable x)
	   (type node bdd))
  (assert (bdd-p bdd))
  (let ((bdd1 (qe1 x bdd)))
    #+dbg(assert(bdd-every #'(lambda (trm)
			       (not (occurs-p x trm)))
			   bdd1))
    bdd1))

(defun qe1 (x bdd &optional conjunct)
  (assert (bdd-p bdd))
  (cond ((bdd0-p bdd)
	 bdd)
	((bdd1-p bdd)
	 (qe-term x conjunct))
	(t (multiple-value-bind (trm pos neg)
	       (destructure-ite bdd)
	     (assert (not (ite-p trm)))
	     (bdd-or (qe1-rec x trm pos conjunct)
		     (qe1-rec x (simplified-negation trm) neg conjunct))))))

(defun qe1-rec (x trm bdd conjunct)
  (declare (type dp-variable x)
	   (type node trm)
	   (type node bdd)
	   (type list conjunct))
  (with-pushed-cong-state ()
     (let ((ctrm (canon-then-solve x trm)))
       (cond ((true-p ctrm) (bdd1))
	     ((false-p ctrm) (bdd0))
	     ((solved-equality-p x ctrm)
	      (let ((subst (acons x (solved-form x ctrm))))
		(bdd-simplify bdd subst)))
	     ((and (integer-p x)
		   (in-scope-of-floor-p x ctrm))
	      (multiple-value-bind (x1 bdd1)
		  (eliminate-shielded x trm)
		(if (occurs-in-bdd-p x1 bdd1)
		    (throw 'unable nil)
		    (qe1 x1 (bdd-and bdd1 bdd) (cons trm conjunct)))))
	     (t (let ((res (invoke-process ctrm (cs))))
		  (cond ((true-p res) (bdd1))
			((false-p res) (bdd0))
			(t (bdd-and (bdd-var trm)
				    (qe1 x bdd (cons trm conjunct)))))))))))

(defun qe-term (x conjunct)
  (break)
  (multiple-value-bind (eqlts diseqlts ineqs noccurs others)
      (partition-conjunct x conjunct)
    (cond ((and (null eqlts) (null others))
	   (multiple-value-bind (lowers uppers)
	       (partition-ineqs x ineqs)
	     (if (or (null lowers) (null uppers))
	        (bdd-and* others)
		(throw 'unable nil))))
	  (t (throw 'unable nil)))))


(defun partition-conjunct (x trms)
  (declare (type dp-variable-p x)
           (type list trms))
  (let ((eqlts) (diseqlts) (ineqs) (noccurs) (others))
    (loop for trm in trms
	  do (cond ((not (occurs-in x trm))
		    (push trm noccurs))
		   ((disequality-p trm)
		    (push trm diseqlts))  
	           ((equality-p trm)
		    (push trm eqlts))
		   ((ineq-p trm)
		    (push trm lowers))
		   ((upper-ineq-p x trm)
		    (push trm uppers))
		   (t (push trm others))))
    (values eqlts diseqlts ineqs noccurs others)))

(defun partition-ineqs (x trms &optional lowers uppers)
  (if (null trms)
      (values (nreverse lowers) (nreverse uppers))
      (let ((trm (car trms)))
	(cond ((and (or (less-p trm) (lesseq-p trm))
		    (eq (lhs trm) x)
		    (not (occurs-p x (rhs trm))))
	       (partition-ineqs x (cdr trms) lowers (cons trm uppers)))
	      ((and (or (greater-p trm) (greatereq-p trm))
		    (eq (lhs trm) x)
		    (not (occurs-p x (rhs trm))))
	       (partition-ineqs x (cdr trms) (cons trm lowers) uppers))
	      (t (break))))))

(defun find-solution (x eqns &optional processed)
  (if (null eqns)
      (values nil processed)
    (let ((lhs (lhs (car eqns)))
	  (rhs (rhs (car eqns))))
      (cond ((and (eq lhs x) (not (occurs-p x rhs)))
	     (values rhs processed))
	    ((and (eq rhs x) (not (occurs-p x lhs)))
	     (values lhs processed))
	    (t (find-solution x (cdr eqns)
			         (cons (car eqns) processed)))))))

;; Tries to eliminate occurrences of binding bndng from the scope of
;; some floors in the term trm. If successful,
;; it returns a new binding and a modified bdd; this new bdd
;; guaranteed not to contain the original binding anymore.
;; Otherwise, an 'unable exception is raised.

(defun eliminate-shielded (x trm) 
  (let* ((new-x (fresh-bind-decl x))
	 (bdd (eliminate-shielded* x new-x trm)))
    (if (bdd-some #'(lambda (arg)
		      (occurs-p x arg))
		  bdd)
	(throw 'unable nil)
	(values new-x bdd))))
	  
(defun eliminate-shielded* (x y trm)
  (let ((delta (delta x trm)))
    (cond ((or (not (integerp delta))
	       (<= delta 0))
	   (throw 'unable nil))
	  ((= delta 1)
	   (bdd-var trm))
	  (t (let* ((c (mk-times (list (mk-constant delta) y))))
	       (eliminated-disjunct x c delta trm))))))

(defun eliminated-disjunct (x c k trm &optional (bdd (bdd0)))
  (if (= k 0) bdd
      (let* ((e (mk-plus (list c (mk-constant (1- k)))))
	     (ntrm (replace-by trm (acons x e nil)))
	     (nbdd (bdd-or (bdd-var ntrm) bdd)))
	(eliminated-disjunct x c (1- k) trm nbdd))))

(defun fresh-bind-decl (x)
  (let* ((type (node-type x))
	 (newid (intern (format nil "~a~a" (leaf-id x) (gensym))))
	 (y (mk-variable newid type)))
    (setf (node-type y) (node-type x))
    y))

;; Least common multiple of the of accumulated coefficients of occurences of
;; bound variable x within the scope of a floor; e.g. 
;;        (delta x (7/17 * x  + (1/2 * [1/5 + [2/3 * x + 1/4]])) = 6
;; Throws 'unable exception if there is a non-linear multiplication
;; or no occurrence of x.

(defun delta (x trms)
  (let ((coeffs (coefficient1 x trm)))
    (if coeffs (apply #'lcm (mapcar #'denominator coeffs)) 1)))

(defun coefficient1 (x trm)
  (if (negation-p trm)
      (coefficient1 x (arg 1 trm))
      (and (in-scope-of-floor-p x trm)
	   (or (equality-p trm)
	       (disequality-p trm)
	       (and (application-p trm)
		    (arith-pred-p (funsym trm))))
	   (mapcan #'(lambda (arg)
		       (coefficients-plus* x arg))
	     (funargs trm)))))

(defun coefficients-plus* (x trm)
    (cond ((times-p trm)
	   (coefficients-times x (lhs trm) (rhs trm)))
	  ((plus-p trm)
	   (coefficients-plus x (lhs trm) (rhs trm)))
	  ((floor-p trm)
	   (coefficients-plus* x (arg 1 trm)))
	  ((eq x trm)
	   (list 1))
	  (t nil)))

(defun coefficients-plus (x lhs rhs)
  (union (coefficients-plus* x lhs)
	 (coefficients-plus* x rhs)))

(defun coefficients-times (x lhs rhs)
  (cond ((eq x lhs)
	 (let ((val (rational-val rhs)))
	   (if val (list val)
	       (throw 'unable nil))))
	((eq x rhs)
	 (let ((val (rational-val lhs)))
	   (if val (list val)
	       (throw 'unable nil))))
	((floor-p lhs)
	 (let ((val (rational-val rhs))
	       (coeffs (coefficients-plus* x (arg 1 lhs))))
	   (if val (and coeffs (cons val coeffs))
	       (throw 'unable nil))))
	((floor-p rhs)
	 (let ((val (rational-val lhs))
	       (coeffs (coefficients-plus* x (arg 1 rhs))))
	   (if val (and coeffs (cons val coeffs))
	       (throw 'unable nil))))
	(t nil)))

(defun rational-val (trm)
  (or (pos-rational-val trm)
      (neg-rational-val trm)))

(defun pos-rational-val (trm)
  (or (and (divide-p trm)
	   (dp-numberp (lhs trm))
	   (dp-numberp (rhs trm))
	   (/ (numer trm) (denom trm)))
      (and (constant-p trm)
	   (let ((val (constant-id trm)))
	     (and (rationalp val)
		  val)))))

(defun neg-rational-val (trm)
  (and (minus-p trm)
       (let ((val (rational-val (arg 1 trm))))
	 (and val (- val)))))

;; Fourier Motzkin Elimination for a set of lower and upper inequalities.
;; Newly generated inequations are added to the current *state*, redundant
;; inequations are disregarded, and the exception 'unsatisfiable is raised
;; if an inconsistency has been deteceted. The resulting set of inequalities
;; may still contain the variable bndng if bndng is not an integer and if
;; there is a combination of strict and nonstrict constraints.

(defun FME (lowers uppers *x*)
  (declare (special *x*))
  (FME* lowers uppers))
  
(defun FME* (lowers uppers &optional acc)
  (if (null lowers) (nreverse acc)
      (FME* (cdr lowers) uppers
	   (union (FME1 (car lowers) uppers) acc))))

(defun FME1 (lower uppers &optional acc)
  (if (null uppers) (nreverse acc)
      (let ((new-ineq (eliminate-variable lower
					  (car uppers))))
	(if (null new-ineq)
	    (FME1 lower (cdr uppers) (cons lower (cons (car uppers) acc)))
	  (let* ((result (invoke-process new-ineq (cs)))
		 (newacc (cond ((true-p result)
				acc)
			       ((false-p result)
				(throw 'fastexit *false-dnf*))
			       (t (adjoin new-ineq acc)))))
	    (FME1 lower (cdr uppers) newacc))))))

(defun eliminate-variable (lower upper)
  (declare (special *x*))
  (let* ((lb (lower-bound lower *x*))
         (ub (upper-bound upper *x*)))
    (cond ((and (strict-ineq-p lower)
                (strict-ineq-p upper))
           (if (integer-p *x*)
               (mk-less (mk-plus (list (mk-floor lb) *one*))
                         ub)
               (mk-less lb ub)))
          ((and (nonstrict-ineq-p lower)
                (nonstrict-ineq-p upper))
           (mk-lesseq lb ub))
	  (t (if (integer-p *x*)
		 (cond ((and (strict-ineq-p lower)
			     (nonstrict-ineq-p upper))
			(mk-lesseq (mk-plus (list lb *one*)) ub))
		       ((and (nonstrict-ineq-p lower)
			     (strict-ineq-p upper))
			(mk-less (mk-plus (list lb *one*)) ub))
		       (t (error "unreachable")))
	       nil))))) ; could not eliminate
     
(defun lower-bound (ineq x)
  (or (and (or (less-p ineq) (lesseq-p ineq))
	   (eq x (rhs ineq))
	   (not (occurs-p x (lhs ineq)))
	   (lhs ineq))
      (and (or (greater-p ineq) (greatereq-p ineq))
	   (eq x (lhs ineq))
	   (not (occurs-p x (rhs ineq)))
	   (rhs ineq))))

(defun upper-bound (ineq x)
  (or (and (or (greater-p ineq) (greatereq-p ineq))
	   (eq x (rhs ineq))
	   (not (occurs-p x (lhs ineq)))
	   (lhs ineq))
      (and (or (less-p ineq) (lesseq-p ineq))
	   (eq x (lhs ineq))
	   (not (occurs-p x (rhs ineq)))
	   (rhs ineq))))


;; Solving for a variable

(defun canon-then-solve (x trm)
  (assert (node-p trm))
  (assert (leaf-p x))
  (with-pushed-cong-state ()
     (let ((ctrm (canon trm (cs) 'no-mod)))
       (cond ((or (not (occurs-p x trm))
		  (occurs-in-scope-of-uninterp-p x ctrm)
		  (true-or-false-p ctrm))
	      ctrm)
	     ((number-p x)
	      (let ((strm (normineq ctrm (cs) x)))
		(if (well-formed-node-p strm) strm ctrm)))
	     (t (let ((seqn (find-if #'(lambda (trm)
					 (and (application-p trm)
					      (= (length (funargs trm)) 2)
					      (let ((lhs (lhs trm))
						    (rhs (rhs trm)))
						(or (and (eq x lhs)
							 (not (occurs-p x rhs)))
						    (and (eq x rhs)
							 (not (occurs-p x lhs)))))))
			      (solve ctrm (cs)))))
		  (or seqn ctrm)))))))


