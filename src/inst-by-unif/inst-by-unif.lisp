(in-package :pvs)

(defstep inst! (&optional (fnums *)
			  subst
			  (where *)
			  copy?
			  (if-match :best))
  (let ((sforms (s-forms (current-goal *ps*)))
	(inst-sforms (gather-seq sforms fnums nil
				 (compose #'essentially-existential? #'formula)))
	(inst-fnums (gather-fnums sforms fnums nil
				  (compose #'essentially-existential? #'formula))))
    (if (null inst-sforms)
	(skip-msg "Could not find a suitable quantified formula.")
      (let ((inst-fmlas (mapcar #'formula inst-sforms))
	    (where-fmlas (mapcar #'formula
			   (select-seq sforms where)))
	    (insts (search-for-instantiations inst-fnums
					      subst
					      inst-fmlas
					      (remove-if #'(lambda (fmla)
							     (member fmla
								     inst-fmlas
								     :test #'tc-eq))
						where-fmlas)
					      if-match
					      copy?)))
	(if insts
	    (let ((inst-rule (make-inst-rules insts copy?)))
	      inst-rule)
	    (skip-msg "No suitable instantiation found")))))
  "Tries to find instantiations for the top-level, existentially
   quantifying variables in the formulas specified by 'fnums'.
   First, a full case split for the formulas specified by 'fnums' and
   'where' is computed; e.g. a formula in the hypothesis of the form
   'FORALL (x: { y: T | P(y)}): Q(x) => R(x)' gives rise to three
   sequents in the split. Then, a set of candidate substitutions is
   generated by unifying complementary pairs in the resulting sequents.
   If there are several such candidates, the procedures chooses some
   supposedly best substitution, whereby the measure for each substitution
   consists of a list of numbers, where each number roughly corresponds to the
   number of complementary pairs in a sequent of the full case split.
   The 'copy?' argument specifies if the formulas to be instantiated
   are copied, 'verbose?' set to true provides some additional output,
   and 'inst?' directs the strategy to apply the inst? strategy in case
   the search for an instantiation fails.

   CAVEAT: This strategy is only included for experimental purposes
   and its functionality (and speed!) is most likely to change in future
   releases. Thus, proof scripts that are using it are likely to break
   in the future!"
  "Instantiating quantified variables")

;; Splits a set of formulas into a list of arguments of negated
;;   formulas (negative formulas, hypotheses) and a list of
;;   (positive) formulas (conclusions)

(defun search-for-instantiations (fnums initial-subst inst-fmlas where-fmlas if-match copy? &optional (state *dp-state*))
   (let ((*start-state* state))
     (declare (special *start-state*))
     (multiple-value-bind (list-of-bndngs bodies renamings)
	 (destructure-inst-fmlas inst-fmlas initial-subst)
       (let ((lvars (mapcar #'cdr renamings))
	     (all-bndngs (mapcan #'identity list-of-bndngs))
	     (fmlas (union bodies where-fmlas :test #'tc-eq)))
	 (let ((*bound-variables* (append all-bndngs *bound-variables*)))
	   (declare (special *bound-variables*))
	   (multiple-value-bind (trms new-lvars new-renamings)
	       (herbrandize fmlas lvars renamings)
	     (declare (ignore new-renamings))
	     (let ((score-substs (dp::gensubsts new-lvars trms)))
	       (if (null score-substs) nil
		   (let ((substs (choose-substs score-substs if-match)))
		     (construct-instantiate-input fnums list-of-bndngs substs renamings))))))))))

(defun destructure-inst-fmlas (fmlas initial-subst &optional list-of-bndngs bodies renamings)
  (if (null fmlas)
      (values (nreverse list-of-bndngs) (nreverse bodies) (nreverse renamings))
    (multiple-value-bind (bndngs body)
	(destructure-existential (car fmlas))
      (let ((*bound-variables* (append bndngs *bound-variables*)))
	(declare (special *bound-variables*))
	(let ((assocs (mapcar #'(lambda (bndng)
				  (cons (top-translate-to-dc bndng)
					(mk-new-var bndng)))
			bndngs)))
	  (destructure-inst-fmlas (cdr fmlas)
				  (cons bndngs list-of-bndngs)
				  (cons body bodies)
				  (append assocs renamings)))))))

;(defun construct-assocs (bndngs subst &optional assocs)
;  (if (null bndng) assocs
;      (let* ((bndng (car bndngs))
;	     (x     (top-translate-to-dc bndng)))
;	 (multiple-value-bind (trm subst1)
;	     (if (symbol-name= (id bndng))
;			  (mk-new-var bndng))))
;      (construct-assocs (cdr bndngs) subst)))
			
(defun choose-substs (score-substs if-match)
  (if (eq if-match :all)
      (mapcar #'(lambda (score-subst)
		   (dp::subst-of score-subst))
	score-substs)
    (choose-best-subst score-substs)))

(defun choose-best-subst (score-substs &optional (best-score 0) best-subst)
  (if (null score-substs)
      best-subst
      (let ((current-score  (dp::score-of (car score-substs)))
	    (current-subst (dp::subst-of (car score-substs))))
	(if (> current-score best-score)
	    (choose-best-subst (cdr score-substs) current-score current-subst)
	  (choose-best-subst (cdr score-substs) best-score best-subst)))))

    
;; Construct a PVS rule from instantiations of the form;
;; e.g.  ((1 (e1 e2 e3)) (-4 (f1 f2))) indicates 3 instantiations
;; for the top-level bindings of the sequence formula numbered 1
;;  and two instantiations for the sequent formula -4.

(defun construct-instantiate-input (fnums list-of-bndngs subst renamings)
  (loop for fnum in fnums
	as bndngs in list-of-bndngs
	collect (list fnum (construct-terms bndngs renamings subst))))

(defun construct-terms (bndngs renamings subst)
  (let ((*bound-variables* (append bndngs *bound-variables*)))
    (declare (special *bound-variables*))
    (loop for bndng in (reverse bndngs)
       collect (let ((lvar (cdr (assoc (top-translate-to-dc bndng) renamings))))
		 (if lvar
		     (let ((trm (translate-from-dc 
				 (cdr (assoc lvar subst)))))
		       (or trm "_"))
		     "_")))))

(defmethod make-inst-rules ((insts null) copy?)
  (declare (ignore copy?))
  '(skip))

(defmethod make-inst-rules ((insts cons) copy?)
  (let ((inst (car insts)))
    `(then* (instantiate ,(car inst) ,@(cdr inst) :copy? ,copy?)
	    ,(make-inst-rules (cdr insts) copy?))))








