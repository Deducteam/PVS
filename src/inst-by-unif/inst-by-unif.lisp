(in-package :pvs)

(defstep inst! (&optional (fnums *)
			  subst
			  (where *)
			  copy?
			  (if-match :best))
  (let ((sforms (s-forms (current-goal *ps*)))
	(inst-sforms (gather-seq sforms fnums nil
				 (compose #'essentially-existential? #'formula)))
	(inst-fnums (gather-fnums sforms fnums nil
				  (compose #'essentially-existential? #'formula))))
    (if (null inst-sforms)
	(skip-msg "Could not find a suitable quantified formula.")
      (let ((inst-fmlas (mapcar #'formula inst-sforms))
	    (where-fmlas  (remove-if #'(lambda (fmla)
					 (member fmla
						 inst-fmlas
						 :test #'tc-eq))
			    (mapcar #'formula
			      (select-seq sforms where))))
	    (rule (construct-inst-rule inst-fnums
				       subst
				       inst-fmlas
				       where-fmlas
				       if-match
				       copy?)))
	(if rule rule
	    (skip-msg "No suitable instantiation found")))))
  "Tries to find instantiations for the top-level, existentially
   quantifying variables in the formulas specified by 'fnums'.
   First, a full case split for the formulas specified by 'fnums' and
   'where' is computed; e.g. a formula in the hypothesis of the form
   'FORALL (x: { y: T | P(y)}): Q(x) => R(x)' gives rise to three
   sequents in the split. Then, a set of candidate substitutions is
   generated by unifying complementary pairs in the resulting sequents.
   If there are several such candidates, the procedures uses
   all instantiations if :if-match is set to :all; otherwise it
   chooses some supposedly best substitution. The 'copy?' argument
   specifies if the formulas to be instantiated are copied.

   CAVEAT: This strategy is only included for experimental purposes
   and its functionality (and speed!) is most likely to change in future
   releases. Thus, proof scripts that are using it are likely to break
   in the future!"
  "Instantiating quantified variables")

;; Splits a set of formulas into a list of arguments of negated
;;   formulas (negative formulas, hypotheses) and a list of
;;   (positive) formulas (conclusions)

(defun construct-inst-rule (fnums initial-subst inst-fmlas where-fmlas
				  if-match copy? &optional (state *dp-state*))
   (let ((*start-state* state))
     (declare (special *start-state*))
     (multiple-value-bind (list-of-bndngs bodies renamings)
	 (destructure-inst-fmlas inst-fmlas initial-subst)
       (let ((lvars (collect-vars renamings))
	     (all-bndngs (mapcan #'identity list-of-bndngs))
	     (fmlas (union bodies where-fmlas :test #'tc-eq)))
	 (let ((*bound-variables* (union all-bndngs *bound-variables*)))
	   (declare (special *bound-variables*))
	   (if (null lvars)
	       (inst!-rule-top fnums list-of-bndngs (list renamings) renamings copy?)
	       (multiple-value-bind (trms new-lvars new-renamings)
		   (herbrandize fmlas lvars renamings)
		 (declare (ignore new-renamings))
		 (let ((score-substs (dp::gensubsts new-lvars trms)))
		   (if (null score-substs) nil
		       (let ((substs (choose-substs score-substs if-match)))
			 (inst!-rule-top fnums list-of-bndngs substs renamings copy?)))))))))))

(defun collect-vars (renamings)
  (if (null renamings) nil
      (let ((assoc (car renamings)))
	(if (dp::dp-variable-p (cdr assoc))
	    (adjoin (cdr assoc) (collect-vars (cdr renamings)))
	  (collect-vars (cdr renamings))))))
  
(defun destructure-inst-fmlas (fmlas initial-subst &optional list-of-bndngs bodies renamings)
  (assert (listp fmlas))
  (if (null fmlas)
      (values (nreverse list-of-bndngs) (nreverse bodies) (nreverse renamings))
      (multiple-value-bind (bndngs body)
	  (destructure-toplevel-existential (car fmlas))
	(let ((*bound-variables* (union bndngs *bound-variables*)))
	  (declare (special *bound-variables*))
	  (multiple-value-bind (assocs new-initial-subst)
	      (construct-assocs bndngs initial-subst)
	    (destructure-inst-fmlas (cdr fmlas)
				    new-initial-subst
				    (cons bndngs list-of-bndngs)
				    (cons body bodies)
				    (append assocs renamings)))))))

(defun destructure-toplevel-existential (fmla)
    (cond ((exists-expr? fmla)
	   (let ((fmla1 (relativize-quantifier fmla)))
	     (values (bindings fmla1) (expression fmla1))))
	  ((and (negation? fmla)
		(forall-expr? (args1 fmla)))
	   (let ((fmla1 (relativize-quantifier (args1 fmla))))
	     (values (bindings fmla1) (make!-negation (expression fmla1)))))
	  (t (values nil fmla))))

(defun construct-assocs (bndngs subst &optional assocs)
  "Construct a list of associations (x . trm) where x is the translation
   of a binding and trm is either a new variable or a term constructed from
   the initial substitution."
  (if (null bndngs)
      (values (nreverse assocs) subst)
      (let* ((bndng (car bndngs))
	     (x1    (top-translate-to-dc bndng)))
	(multiple-value-bind (trm1 subst1)
	    (cond ((< (length subst) 2)
		   (values (mk-new-var bndng) nil))
		  ((string= (symbol-name (id bndng)) (first subst))
		   (let ((trm (pc-typecheck (pc-parse (second subst) 'expr))))
		     (values (or (and trm
				      (top-translate-to-dc trm))
				 (mk-new-var bndng))
			     (nthcdr 2 subst))))
		  (t (values (mk-new-var bndng) subst)))
	  (construct-assocs (cdr bndngs) subst1 (acons x1 trm1 assocs))))))
			
(defun choose-substs (score-substs if-match)
  (if (eq if-match :all)
      (mapcar #'(lambda (score-subst)
		   (dp::subst-of score-subst))
	score-substs)
    (list (choose-best-subst score-substs))))

(defun choose-best-subst (score-substs &optional (best-score 0) best-subst)
  (if (null score-substs)
      best-subst
      (let ((current-score  (dp::score-of (car score-substs)))
	    (current-subst (dp::subst-of (car score-substs))))
	(if (> current-score best-score)
	    (choose-best-subst (cdr score-substs) current-score current-subst)
	  (choose-best-subst (cdr score-substs) best-score best-subst)))))

    
;; Construct a PVS rule from instantiations of the form;
;; e.g.  ((1 (e1 e2 e3)) (-4 (f1 f2))) indicates 3 instantiations
;; for the top-level bindings of the sequence formula numbered 1
;;  and two instantiations for the sequent formula -4.

(defun inst!-rule-top (fnums list-of-bndngs substs renamings copy?)
  (let ((*fnums* fnums)
	(*list-of-bndngs* list-of-bndngs)
	(*renamings* renamings)
	(*copy* copy?))
    (declare (special *fnums*) (special *list-of-bndngs* *renamings* *copy*))
    (inst!-rule* substs)))

(defun inst!-rule* (substs)
  (if (null substs)
      '(skip)
      `(then* ,(inst!-rule (instantiate-input (car substs)))
	      ,(inst!-rule* (cdr substs)))))

(defun inst!-rule (insts)
  (if (null insts) '(skip)
      (let ((inst (car insts)))
	`(then* (instantiate ,(car inst) ,@(cdr inst) :copy? ,*copy*)
		,(inst!-rule (cdr insts))))))

(defun instantiate-input (subst)
  (error-format-if "~%Substitution:")
  (loop for fnum in *fnums*
	as bndngs in *list-of-bndngs*
	collect (let ((trms (construct-terms bndngs subst)))
		  (display-substitution fnum bndngs trms)
		  (list fnum trms))))

(defun construct-terms (bndngs subst)
  (loop for bndng in bndngs
	collect (let ((pair (assoc (top-translate-to-dc bndng) *renamings*)))
		  (if (not pair) "_"
		      (let ((trm (cdr pair)))
			(cond ((null (dp::vars-of trm)) ; from initial substitution
			       (translate-from-dc trm))
			      ((dp::dp-variable-p trm)  ; from computes substitution
			       (or (translate-from-dc
				    (cdr (assoc trm subst)))
				   "_"))
			      (t "_")))))))

(defun display-substitution (fnum bndngs trms)
  (error-format-if "~%   ~a: ~{~a~^, ~}" fnum (pairlis bndngs trms)))







