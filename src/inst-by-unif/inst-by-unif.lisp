(in-package :pvs)

(defstep inst-by-unif (&optional (fnums *)
				 (where *)
				 copy?
				 verbose?
				 (inst? T))
  (let ((sforms (s-forms (current-goal *ps*)))
	(inst-sforms (gather-seq sforms fnums nil
				 (compose #'existential? #'formula)))
	(inst-fnums (gather-fnums sforms fnums nil
				  (compose #'existential? #'formula))))
    (if (null inst-sforms)
	(skip-msg "Could not find a suitable quantified formula.")
      (let ((inst-fmlas (mapcar #'formula inst-sforms))
	    (where-fmlas (mapcar #'formula
			   (select-seq sforms where)))
	    (insts (let ((*verbose* verbose?)
			 (*all*))
		     (declare (special *verbose*)
			      (special *all*))
		     (ignore-errors
		       (search-for-instantiations inst-fnums
						  inst-fmlas
						  (remove-if #'(lambda (fmla)
								 (member fmla
									 inst-fmlas
									 :test #'tc-eq))
						    where-fmlas))))))
	(if insts
	    (let ((inst-rule (make-inst-rules insts copy?)))
	      inst-rule)
	  (if inst?
	      (inst? :fnums fnums
		     :where where
		     :copy? copy?)
	    (skip-msg "No suitable instantiation found"))))))
  "Tries to find instantiations for the top-level, existentially
   quantifying variables in the formulas specified by 'fnums'.
   First, a full case split for the formulas specified by 'fnums' and
   'where' is computed; e.g. a formula in the hypothesis of the form
   'FORALL (x: { y: T | P(y)}): Q(x) => R(x)' gives rise to three
   sequents in the split. Then, a set of candidate substitutions is
   generated by unifying complementary pairs in the resulting sequents.
   If there are several such candidates, the procedures chooses some
   supposedly best substitution, whereby the measure for each substitution
   consists of a list of numbers, where each number roughly corresponds to the
   number of complementary pairs in a sequent of the full case split.
   The 'copy?' argument specifies if the formulas to be instantiated
   are copied, 'verbose?' set to true provides some additional output,
   and 'inst?' directs the strategy to apply the inst? strategy in case
   the search for an instantiation fails.

   CAVEAT: This strategy is only included for experimental purposes
   and its functionality (and speed!) is most likely to change in future
   releases. Thus, proof scripts that are using it are likely to break
   in the future!"
  "Instantiating quantified variables")

;; Construct a PVS rule from instantiations of the form;
;; e.g.  ((1 (e1 e2 e3)) (-4 (f1 f2))) indicates 3 instantiations
;; for the top-level bindings of the sequence formula numbered 1
;;  and two instantiations for the sequent formula -4.

(defmethod make-inst-rules ((insts null) copy?)
  (declare (ignore copy?))
  '(skip))

(defmethod make-inst-rules ((insts cons) copy?)
  (let ((inst (car insts)))
    `(then* (instantiate ,(car inst) ,@(cdr inst) :copy? ,copy?)
	    ,(make-inst-rules (cdr insts) copy?))))

;; Splits a set of formulas into a list of arguments of negated
;;   formulas (negative formulas, hypotheses) and a list of
;;   (positive) formulas (conclusions)

(defun search-for-instantiations (fnums inst-fmlas where-fmlas &optional (state *dp-state*))
   (let ((*current-context* (copy-context *current-context*))
	 (*start-state* state))
     (declare (special *current-context*)
	      (special *start-state*))
     (multiple-value-bind (list-of-bndngs lvars bodies)
	 (destructure-inst-fmlas inst-fmlas)
       (let ((fmlas (union bodies where-fmlas :test #'tc-eq))
	     (renamings (initial-renamings list-of-bndngs lvars)))
	 (multiple-value-bind (hfmlas new-lvars new-renamings)
	     (herbrandize fmlas lvars renamings)
	   (declare (ignore new-renamings))
	   (let* ((*lvars* new-lvars)
		  (*num-of-lvars* (length *lvars*)))
	     (declare (special *lvars*)
		      (special *num-of-lvars*)) 
	     (let ((subst (search-for-subst hfmlas))) 
	       (if (or (fail? subst) (null subst))
		   nil
		   (construct-instantiate-input fnums list-of-bndngs subst renamings)))))))))
		   
(defun initial-renamings (list-of-bndngs lvars)
  (pairlis (mapcan #'identity list-of-bndngs) lvars))

(defun destructure-inst-fmlas (fmlas &optional list-of-bndngs lvars bodies)
  (if (null fmlas)
      (values (nreverse list-of-bndngs) (nreverse lvars) (nreverse bodies))
    (multiple-value-bind (bndngs body)
	(destructure-existential (car fmlas))
      (let ((new-lvars (mk-new-lvars bndngs)))
	(destructure-inst-fmlas  (cdr fmlas)
				 (cons bndngs list-of-bndngs)
				 (append new-lvars lvars)
				 (cons body bodies))))))

(defun construct-instantiate-input (fnums list-of-bndngs subst renamings)
  (loop for fnum in fnums
	as bndngs in list-of-bndngs
	collect (list fnum
		      (reverse
		      (loop for bndng in bndngs
			    collect (let ((lvar (cdr (assoc bndng renamings
							    :test #'tc-eq))))
				      (if lvar
					  (cdr (assoc lvar subst :test #'tc-eq))
					  "_")))))))

;; Substitutions with scores

(defvar *lvars* nil)

;; Searching for an adequate substitution

(defun search-for-subst (fmlas)
  (let ((subst (search-best-subst fmlas)))
    (unless (fail? subst)
      (error-format-if "~%Using ~{~a~^, ~}" subst))
    subst))

(defun search-best-subst (fmlas)
  (multiple-value-bind (ha hn ca cn)
      (flatten-sequent () () () () () fmlas)
    (let* ((sequents (split-sequent ha hn ca cn))
	   (substs (generate-substs sequents)))
	 (choose-best-subst substs sequents))))

(defun choose-best-subst (substs sequents)
  (cond ((= (length substs) 0)
	 *fail*)
	((= (length substs) 1)
	 (first substs))
	(t
	 (choose-best-subst* substs
			     sequents
			     *fail*
			     (mapcar #'(lambda (sequent)
					 (declare (ignore sequent))
					 0)
			       sequents)))))

(defun choose-best-subst* (substs sequents best-subst best-score)
  (if (null substs) best-subst
      (let* ((subst (car substs))
	     (score (score-of subst sequents)))
	(if (better? score best-score)
	    (choose-best-subst* (cdr substs) sequents subst score)
	  (choose-best-subst* (cdr substs) sequents best-subst best-score)))))

(defun better? (score1 score2)
  (or (> (length (remove 0 score1))
	 (length (remove 0 score2)))
      (> (apply #'+ score1)
	 (apply #'+ score2))))

;; Collect all possible substitutions for a given set of sequents

(defun generate-substs (sequents)
  (let ((insts (generate-insts sequents)))
    (insts-to-substs insts)))

(defun insts-to-substs (insts &optional (acc '(())))
  (if (null insts) acc
      (let* ((inst (car insts))
	     (pairs (mapcar #'(lambda (expr)
			       (cons (car inst) expr))
		      (cdr inst))))
	(insts-to-substs (cdr insts)
			 (mapcan #'(lambda (pair)
				     (add-to-substs pair acc))
			   pairs)))))

(defun add-to-substs (pair substs)
  (mapcar #'(lambda (subst)
	      (cons pair subst))
    substs))
  

(defun generate-insts (sequents &optional (insts (empty-insts)))
  (if (null sequents) insts
      (let ((new-insts (destructuring-bind (hyps concs)
			   (car sequents)
			 (let ((*init-state* (init-dp-state hyps)))
			   (declare (special *init-state*))
			   (generate-insts1 hyps concs insts)))))
	(generate-insts (cdr sequents)
			new-insts))))

(defun generate-insts1 (hyps concs insts)
  (let ((*insts* insts))
    (loop for hyp in hyps
       do (loop for conc in concs
	     do (when  (or (contains-lvar? hyp)
		    	   (contains-lvar? conc)) 
		 (let ((subst (unify hyp conc)))
		   (unless (fail? subst)
		     (setf *insts* (add-insts subst *insts*)))))))
    *insts*))
 
;; The score of a substitutions is a list of the numbers of
;; successful unifications (involving logical variables) for each sequent

(defun score-of (subst sequents)
  (let ((score (mapcar #'(lambda (sequent)
			   (num-of-unifications sequent subst))
		 sequents)))  
    (error-format-if "~%~a: ~a" score subst)
    score))
 
(defun num-of-unifications (sequent subst)
  (destructuring-bind (hyps concs) sequent
    (let ((*init-state* (init-dp-state hyps)))
      (declare (special *subst*)
	       (special *init-state*))
      (unifications1 hyps concs subst))))

(defun unifications1 (hyps concs subst)
  (let ((*num* 0))
    (loop for hyp in hyps
       do (loop for conc in concs
	     do (when  (or (contains-lvar? hyp)
		    	   (contains-lvar? conc)) 
		 (let ((new-subst (unify hyp conc subst)))
		   (unless (fail? new-subst)
		     (when *verbose*
		       (error-format-if "~%  unify(~a, ~a)(~a) --> ~a"
					hyp conc subst new-subst))
		     (setf *num* (1+ *num*)))))))
    *num*))

;; Instantiations are list of associations (x . (e1 e2 ... en))
;; where x is a variable and the e's are possible instantiations

(defun empty-insts ()
  (loop for x in *lvars*
     collect (cons x ())))

(defun add-insts (subst insts)
  (if (null subst) insts
      (let ((pair (car subst)))
	(add-insts (cdr subst)
		   (add-inst (car pair) (cdr pair) insts)))))

(defun add-inst (x expr insts)
  (if (contains-lvar? expr) insts
      (loop for (y . l) in insts
	    collect (if (tc-eq x y)
			(cons x (adjoin expr l :test #'tc-eq))
			(cons y l)))))

(defun contains-lvar? (expr)
  (some #'(lambda (lvar)
	    (occurs-in lvar expr))
	*lvars*))


;; Splitting

(defun split-sequent (ha hn ca cn)
  (split* ha hn ca cn))

(defmethod split* (ha (hn null) ca (cn null))
  (list (list (remove-duplicates ha :test #'tc-eq)
	      (remove-duplicates ca :test #'tc-eq))))
  
(defmethod split* (ha hn ca (cn cons))
   (split+ ha hn ca (car cn) (cdr cn)))

(defmethod split* (ha (hn cons) ca cn)
   (split- ha (car hn) (cdr hn) ca cn))

(defmethod split+ (ha hn ca (e conjunction) cn)
  (multiple-value-bind (ha1 hn1 ca1 cn1)
      (flatten-sequent ha hn () ca cn (list (args1 e)))
    (multiple-value-bind (ha2 hn2 ca2 cn2)
	(flatten-sequent ha hn () ca cn (list (args2 e)))
      (append (split* ha1 hn1 ca1 cn1)
	      (split* ha2 hn2 ca2 cn2)))))
	
(defmethod split+ (ha hn ca (e iff-or-boolean-equation) cn)
  (split+ ha hn ca (expand-fml e) cn))

(defmethod split+ (ha hn ca (e expr) cn)
  (split- ha hn (cons e ca) cn))

(defmethod split- (ha (e disjunction) hn ca cn)
  (multiple-value-bind (ha1 hn1 ca1 cn1) 
	(flatten-sequent ha hn (list (args1 e)) ca cn ())
      (multiple-value-bind (ha2 hn2 ca2 cn2) 
	  (flatten-sequent ha hn (list (args2 e)) ca cn ())
	(append (split* ha1 hn1 ca1 cn1)
		(split* ha2 hn2 ca2 cn2)))))
	
(defmethod split- (ha (e implication) hn ca cn)
  (multiple-value-bind (ha1 hn1 ca1 cn1) 
      (flatten-sequent ha hn (list (args2 e)) ca cn ())
    (multiple-value-bind (ha2 hn2 ca2 cn2)
	(flatten-sequent ha hn () ca cn (list (args1 e)))
      (append (split* ha1 hn1 ca1 cn1)
	      (split* ha2 hn2 ca2 cn2)))))

(defmethod split- (ha (e expr) hn ca cn)
  (split- (cons ha e) hn ca cn))

;;

(defmethod expand-fml ((fml iff-or-boolean-equation))
  (make!-conjunction (make!-implication (args1 fml) (args2 fml))
		     (make!-implication (args2 fml) (args1 fml))))

(defmethod expand-fml ((fml expr))
  fml)


;; Propositional simplification, labeling, and categorizing propositional
;; formulas into atomic formulas and other processed (seen) formulas.
;; Does not do splitting.
;; (hs == 'seen hypotheses', ha == 'atomic hypotheses', h == 'remaining hypotheses',
;;  cs == 'seen conclusions', ca == 'atomic conclusions', c == 'remaining conclusions')

(defun flatten-sequent (ha hs hn ca cs cn)
  (flatten-sequent* ha hs hn ca cs cn))

(defmethod flatten-sequent* (ha hs (hn null) ca cs (cn null))
  (values ha hs ca cs))

(defmethod flatten-sequent* (ha hs (hn list) ca cs (cn cons))
  (flatten-sequent+ ha hs hn ca cs (car cn) (cdr cn)))

(defmethod flatten-sequent* (ha hs (hn cons) ca cs cn)
  (flatten-sequent- ha hs (car hn) (cdr hn) ca cs cn))

(defmethod flatten-sequent+ (ha hs hn ca cs (c negation) cn)
  (flatten-sequent* ha hs (cons (args1 c) hn) ca cs cn))

(defmethod flatten-sequent+ (ha hs hn ca cs (c disjunction) cn)
  (flatten-sequent* ha hs hn
		    ca cs (cons (args1 c) (cons (args2 c) cn))))

(defmethod flatten-sequent+ (ha hs hn ca cs (c implication) cn)
  (flatten-sequent* ha hs (cons (args1 c) hn)
		    ca cs (cons (args2 c) cn)))

(defmethod flatten-sequent+ (ha hs hn ca cs (c conjunction) cn)
  (flatten-sequent* ha hs hn
		    ca (cons c cs) cn))

(defmethod flatten-sequent+ (ha hs hn ca cs (c iff-or-boolean-equation) cn)
  (flatten-sequent* ha hs hn
		    ca (cons c cs) cn))

(defmethod flatten-sequent+ (ha hs hn ca cs (c expr) cn)
  (flatten-sequent* ha hs hn
		    (cons c ca) cs cn))

(defmethod flatten-sequent- (ha hs (h negation) hn ca cs cn)
  (flatten-sequent* ha hs hn
		    ca cs (cons (args1 h) cn)))

(defmethod flatten-sequent- (ha hs (h conjunction) hn ca cs cn)
  (flatten-sequent* ha hs (cons (args1 h) (cons (args2 h) hn))
		    cs ca cn))

(defmethod flatten-sequent- (ha hs (h disjunction) hn ca cs cn)
  (flatten-sequent* ha (cons h hs) hn
		    ca cs cn))

(defmethod flatten-sequent- (ha hs (h implication) hn ca cs cn)
  (flatten-sequent* ha (cons h hs) hn
		    ca cs cn))

(defmethod flatten-sequent- (ha hs (h iff-or-boolean-equation) hn ca cs cn)
  (let ((h1 (args1 h))
	(h2 (args2 h)))
    (flatten-sequent* ha hs (cons (make!-implication h1 h2)
				  (cons (make!-implication h2 h1) hn))
		      ca cs cn)))

(defmethod flatten-sequent- (ha hs (h expr) hn  ca cs cn)
  (flatten-sequent* (cons h ha) hs hn
		    ca cs cn))

;; 

(defvar *fail* :fail)

(defvar *empty* (dp::null-single-cong-state))

(defun fail? (sub)
  (eq sub *fail*))

(defun lookup (x sub)
  (cdr (assoc x sub :test #'tc-eq)))


;; Interface to Ground Unification

(defun unify (expr1 expr2 &optional subst)
  (let ((state (dp::push-new-cong-state (init-dp-state))))
    (loop for (x . e) in subst
           do (assert-eqn! x e state))
    (unwind-protect
	(let ((res (dp::unify (top-translate-to-dc expr1)
			      (top-translate-to-dc expr2)
			      state)))
	  (if (symbolp res) *fail*
	      (make-subst res)))
      (dp::npop-cong-state state))))

(defun init-dp-state (&optional fmlas)
  (let ((state ;(dp::copy-cong-state* *start-state*)))
	    (dp::null-single-cong-state)))
    (loop for fmla in fmlas
	  do (when (equation? fmla)
	       (dp::dp-union (top-translate-to-dc (args1 fmla))
			     (top-translate-to-dc (args2 fmla))
			     state)))
    state))
	
(defun subst= (sub1 sub2)
  (every #'(lambda (x)
	     (let ((e1 (lookup x sub1))
		   (e2 (lookup x sub2)))
	       (or (and e1 e2 (tc-eq e1 e2))
		   (and (not e1) (not e2)))))
	 *lvars*))

(defun make-subst (cs)
  (if (fail? cs) *fail*
      (translate-from-dc-subst
       (dp::make-subst (mapcar #'top-translate-to-dc *lvars*)
		       cs))))

(defun assert-eqn! (x e state)
  (dp::dp-union (top-translate-to-dc x)
		(top-translate-to-dc e)
		state))


