/* 10-bit counter */

/* Init: */
Let S0 = L
C[9], C[8], C[7], C[6], C[5], C[4], C[3], C[2], C[1], C[0] .
none_of (
C[9], C[8], C[7], C[6], C[5], C[4], C[3], C[2], C[1], C[0]
);

let N = L

Y[0], Y[1], Y[2], Y[3], Y[4], Y[5], Y[6], Y[7], Y[8], Y[9],
@Y[0], @Y[1], @Y[2], @Y[3], @Y[4], @Y[5], @Y[6], @Y[7], @Y[8], @Y[9]
.
E in, E[0], E[1] .

(E[0] == Y[6] & Y[7] & Y[8] & Y[9])
&
(E[1] == Y[3] & Y[4] & Y[5] & E[0])
&
(@Y[0] == in & (Y[0] * Y[1] & Y[2] & E[1]) + !in & Y[0])
&
(@Y[1] == in & (Y[1] * Y[2] & E[1]) + !in & Y[1])
&
(@Y[2] == in & (Y[2] * E[1]) + !in & Y[2])
&
(@Y[3] == in & (Y[3] * Y[4] & Y[5] & E[0]) + !in & Y[3])
&
(@Y[4] == in & (Y[4] * Y[5] & E[0]) + !in & Y[4])
&
(@Y[5] == in & (Y[5] * E[0]) + !in & Y[5])
&
(@Y[6] == in & (Y[6] * Y[7] & Y[8] & Y[9]) + !in & Y[6])
&
(@Y[7] == in & (Y[7] * Y[8] & Y[9]) + !in & Y[7])
&
(@Y[8] == in & (Y[8] * Y[9]) + !in & Y[8])
&
(@Y[9] == (in * Y[9]))
;

let Reach =
mu Z .
S0 +
[ L
Y[0], Y[1], Y[2], Y[3], Y[4], Y[5], Y[6], Y[7], Y[8], Y[9]
.
E
W[0], W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9]
.
Z (
W[0], W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9]
)
&
N (
W[0], W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9]
,
Y[0], Y[1], Y[2], Y[3], Y[4], Y[5], Y[6], Y[7], Y[8], Y[9]
)
]
;

write ("1: States reachable from initial state are:\n");
Reach (
Y[0], Y[1], Y[2], Y[3], Y[4], Y[5], Y[6], Y[7], Y[8], Y[9]
);

/*
write ("2: States reachable from initial state are:\n");
Reachable(N,S0) (
Y[0], Y[1], Y[2], Y[3], Y[4], Y[5], Y[6], Y[7], Y[8], Y[9]
);
*/
