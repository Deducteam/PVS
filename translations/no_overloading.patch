diff --git a/lib/prelude.pvs b/lib/prelude.pvs
index 767f4804..b078e3c2 100644
--- a/lib/prelude.pvs
+++ b/lib/prelude.pvs
@@ -277,27 +277,27 @@ functions [D, R: TYPE]: THEORY
 
   graph(f)(x, y): bool = (f(x) = y)
 
-  preserves(f, Drel, Rrel): bool =
+  preserves(Drel, Rrel)(f): bool =
       FORALL x1, x2: Drel(x1, x2) IMPLIES Rrel(f(x1), f(x2))
 
   % Curried form
-  preserves(Drel, Rrel)(f): bool = preserves(f, Drel, Rrel)
+  %preserves(Drel, Rrel)(f): bool = preserves(f, Drel, Rrel)
 
-  inverts(f, Drel, Rrel): bool =
+  inverts(Drel, Rrel)(f): bool =
       FORALL x1, x2: Drel(x1, x2) IMPLIES Rrel(f(x2), f(x1))
 
   % Curried form
-  inverts(Drel, Rrel)(f): bool = inverts(f, Drel, Rrel)
+  %inverts(Drel, Rrel)(f): bool = inverts(f, Drel, Rrel)
 
  END functions
 
 
-functions_alt [D, R: TYPE, Drel: PRED[[D, D]], Rrel: PRED[[R, R]]]: THEORY
- BEGIN
-  f: VAR [D -> R]
-  preserves: [[D -> R] -> bool] = preserves(Drel, Rrel)
-  inverts: [[D -> R] -> bool] = inverts(Drel, Rrel)
- END functions_alt
+%functions_alt [D, R: TYPE, Drel: PRED[[D, D]], Rrel: PRED[[R, R]]]: THEORY
+% BEGIN
+%  f: VAR [D -> R]
+%  preserves: [[D -> R] -> bool] = preserves(Drel, Rrel)
+%  inverts: [[D -> R] -> bool] = inverts(Drel, Rrel)
+% END functions_alt
 
 
 transpose[T1, T2, T3: TYPE]: THEORY
@@ -562,23 +562,23 @@ orders [T: TYPE]: THEORY
 
   upper_bound?(<)(x, pe): bool = FORALL (y: (pe)): y < x
 
-  upper_bound?(<)(pe)(x): bool = upper_bound?(<)(x, pe)
+  %upper_bound?(<)(pe)(x): bool = upper_bound?(<)(x, pe)
 
   lower_bound?(<)(x, pe): bool = FORALL (y: (pe)): x < y
 
-  lower_bound?(<)(pe)(x): bool = lower_bound?(<)(x, pe)
+  %lower_bound?(<)(pe)(x): bool = lower_bound?(<)(x, pe)
 
   least_upper_bound?(<)(x, pe): bool =
     upper_bound?(<)(x, pe) AND
       FORALL y: upper_bound?(<)(y, pe) IMPLIES (x < y OR x = y)
 
-  least_upper_bound?(<)(pe)(x): bool = least_upper_bound?(<)(x, pe)
+  %least_upper_bound?(<)(pe)(x): bool = least_upper_bound?(<)(x, pe)
 
   greatest_lower_bound?(<)(x, pe): bool =
     lower_bound?(<)(x, pe) AND
       FORALL y: lower_bound?(<)(y, pe) IMPLIES (y < x OR x = y)
 
-  greatest_lower_bound?(<)(pe)(x): bool = greatest_lower_bound?(<)(x, pe)
+  %greatest_lower_bound?(<)(pe)(x): bool = greatest_lower_bound?(<)(x, pe)
 
  END orders
 
@@ -586,10 +586,10 @@ orders [T: TYPE]: THEORY
 orders_alt [T: TYPE, < : pred[[T, T]], pe: nonempty_pred[T]]: THEORY
  BEGIN
   x: VAR T
-  upper_bound?: [T -> bool] = upper_bound?(<)(pe)
-  least_upper_bound?: [T -> bool] = least_upper_bound?(<)(pe)
-  lower_bound?: [T -> bool] = lower_bound?(<)(pe)
-  greatest_lower_bound?: [T -> bool] = greatest_lower_bound?(<)(pe)
+  upper_bound?(x: T): bool = upper_bound?(<)(x, pe)
+  least_upper_bound?(x: T): bool = least_upper_bound?(<)(x, pe)
+  lower_bound?(x: T): bool = lower_bound?(<)(x, pe)
+  greatest_lower_bound?(x: T): bool = greatest_lower_bound?(<)(x, pe)
   
   least_upper_bound_is_upper_bound: JUDGEMENT
     (least_upper_bound?) SUBTYPE_OF (upper_bound?)
@@ -810,11 +810,11 @@ sets [T: TYPE]: THEORY
 
   every(p)(a): bool = FORALL (x:(a)): p(x)
 
-  every(p, a): bool = FORALL (x:(a)): p(x)
+  % every(p, a): bool = FORALL (x:(a)): p(x)
 
   some(p)(a): bool = EXISTS (x:(a)): p(x)
 
-  some(p, a): bool = EXISTS (x:(a)): p(x)
+  %some(p, a): bool = EXISTS (x:(a)): p(x)
 
   singleton?(a): bool = (EXISTS (x:(a)): (FORALL (y:(a)): x = y))
 
@@ -1506,35 +1506,35 @@ function_props [T1, T2, T3: TYPE]: THEORY
     image(f2, image(f1, X)) = image(f2 o f1, X)
 
   preserves_composition: LEMMA
-    preserves(f1, R1, R2) AND preserves(f2, R2, R3)
-      IMPLIES preserves(f2 o f1, R1, R3)
+    preserves(R1, R2)(f1) AND preserves(R2, R3)(f2)
+      IMPLIES preserves(R1, R3)(f2 o f1)
 
   inverts_composition1: LEMMA
-    preserves(f1, R1, R2) AND inverts(f2, R2, R3)
-      IMPLIES inverts(f2 o f1, R1, R3)
+    preserves(R1, R2)(f1) AND inverts(R2, R3)(f2)
+      IMPLIES inverts(R1, R3)(f2 o f1)
 
   inverts_composition2: LEMMA
-    inverts(f1, R1, R2) AND preserves(f2, R2, R3)
-      IMPLIES inverts(f2 o f1, R1, R3)
+    inverts(R1, R2)(f1) AND preserves(R2, R3)(f2)
+      IMPLIES inverts(R1, R3)(f2 o f1)
       
  END function_props
 
 
-function_props_alt [T1, T2, T3: TYPE, R1: PRED[[T1, T1]],
-                    R2: PRED[[T2, T2]], R3: PRED[[T3, T3]]]: THEORY
- BEGIN 
-   composition_preserves: JUDGEMENT
-     o(f2: (preserves[T2, T3, R2, R3]), f1: (preserves[T1, T2, R1, R2]))
-       HAS_TYPE (preserves[T1, T3, R1, R3])
-
-   composition_inverts1: JUDGEMENT
-     o(f2: (preserves[T2, T3, R2, R3]), f1: (inverts[T1, T2, R1, R2]))
-       HAS_TYPE (inverts[T1, T3, R1, R3])
-
-   composition_inverts2: JUDGEMENT
-     o(f2: (inverts[T2, T3, R2, R3]), f1: (preserves[T1, T2, R1, R2]))
-       HAS_TYPE (inverts[T1, T3, R1, R3])
- END function_props_alt  
+%function_props_alt [T1, T2, T3: TYPE, R1: PRED[[T1, T1]],
+%                    R2: PRED[[T2, T2]], R3: PRED[[T3, T3]]]: THEORY
+% BEGIN 
+%   composition_preserves: JUDGEMENT
+%     o(f2: (preserves[T2, T3, R2, R3]), f1: (preserves[T1, T2, R1, R2]))
+%       HAS_TYPE (preserves[T1, T3, R1, R3])
+%
+%   composition_inverts1: JUDGEMENT
+%     o(f2: (preserves[T2, T3, R2, R3]), f1: (inverts[T1, T2, R1, R2]))
+%       HAS_TYPE (inverts[T1, T3, R1, R3])
+%
+%   composition_inverts2: JUDGEMENT
+%     o(f2: (inverts[T2, T3, R2, R3]), f1: (preserves[T1, T2, R1, R2]))
+%       HAS_TYPE (inverts[T1, T3, R1, R3])
+% END function_props_alt  
 
 
 % function_props2 defines the associativity of function composition.  It
@@ -4529,19 +4529,19 @@ sequences[T: TYPE]: THEORY
 
   every(p)(seq): bool = (FORALL n: p(nth(seq, n)))
 
-  every(p, seq): bool = (FORALL n: p(nth(seq, n)))
+  % every(p, seq): bool = (FORALL n: p(nth(seq, n)))
 
   some(p)(seq): bool = (EXISTS n: p(nth(seq, n)))
 
-  some(p, seq): bool = (EXISTS n: p(nth(seq, n)))
+  %some(p, seq): bool = (EXISTS n: p(nth(seq, n)))
 
   sequence_induction: LEMMA
     p(nth(seq, 0)) AND (FORALL n: p(nth(seq, n)) IMPLIES p(nth(seq, n + 1)))
       IMPLIES every(p)(seq)
 
-  ascends?(seq, Trel): bool = preserves(seq, (LAMBDA i, n: i <= n), Trel)
+  ascends?(seq, Trel): bool = preserves((LAMBDA i, n: i <= n), Trel)(seq)
 
-  descends?(seq, Trel): bool = inverts(seq, (LAMBDA i, n: i <= n), Trel)
+  descends?(seq, Trel): bool = inverts((LAMBDA i, n: i <= n), Trel)(seq)
 
  END sequences
 
@@ -4878,8 +4878,8 @@ list_props [T: TYPE]: THEORY
 
   list_rep: LEMMA (: a, b, c :) = cons(a, cons(b, cons(c, null)))
 
-  every_unc_eq_cur: LEMMA
-    every(P, l) = every(P)(l)
+  % every_unc_eq_cur: LEMMA
+  %   every(P, l) = every(P)(l)
 
   every_append: LEMMA
     every(P)(append(l1, l2)) IFF (every(P)(l1) AND every(P)(l2))
